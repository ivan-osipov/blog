<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ivan Osipov</title>
    <link>https://i-osipov.ru/post/index.xml</link>
    <description>Recent content in Posts on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Fri, 20 Apr 2018 07:35:10 +0400</lastBuildDate>
    <atom:link href="https://i-osipov.ru/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kotlin Updates Report 1.2.40</title>
      <link>https://i-osipov.ru/post/kotlin-updates-report-1.2.40/</link>
      <pubDate>Fri, 20 Apr 2018 07:35:10 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-updates-report-1.2.40/</guid>
      <description>

&lt;p&gt;Вчера вечером вышло описание нововведений в Kotlin 1.2.40. Сегодня, по традиции, мы с вами взглянем на
очередной релиз и актуализируем знания по языку.&lt;/p&gt;

&lt;p&gt;Список изменений:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;множественное использование expectedBy зависимостей;&lt;/li&gt;
&lt;li&gt;поддержка crossinline suspend параметров в inline функциях;&lt;/li&gt;
&lt;li&gt;экспериментальная поддержка аннотации @JvmDefault для создания методов интерфейсов из Java 8 с модификатором default;&lt;/li&gt;
&lt;li&gt;добавлены новые инспекции и интеншены в плагин;&lt;/li&gt;
&lt;li&gt;прямое обращение к классам внутри companion object в скоупе наследования теперь deprecated;&lt;/li&gt;
&lt;li&gt;фиксы в компиляторе и IDE плагине, улучшения производительности.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот update совместим с Intellij IDEA от 2017.1 до 2018.1, также как с Android Studio 3.x.&lt;/p&gt;

&lt;h3 id=&#34;улучшения-мультиплатформенных-проектах&#34;&gt;Улучшения мультиплатформенных проектах&lt;/h3&gt;

&lt;p&gt;Платформенные модули теперь позволяют реализовывать платформенно-специфичные декларации для более чем одного мультиплатформенного
модуля. Теперь вы можете использовать &lt;code&gt;expectedBy&lt;/code&gt; в зависимостях несколько раз. Выглядит это, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;kotlin-platform-jvm&#39;
// ...
 
dependencies {
    expectedBy project(&amp;quot;:io-common&amp;quot;)
    expectedBy project(&amp;quot;:data-common&amp;quot;)
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такие зависимости нетранзитивны, разберемся с этим. Пусть есть вот такая цепочка зависимостей: &lt;code&gt;my-common -&amp;gt; lib-common&lt;/code&gt;
Это два common модуля (напомню, что мы разделяем платформенные и common модули), где первый зависит от второго.
При попытке установить зависимость на my-common модуль в платформенном модуле у нас есть один из двух путей:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;либо мы вручную определяем две &lt;code&gt;expectedBy&lt;/code&gt; зависимости;&lt;/li&gt;
&lt;li&gt;или добавляем &lt;code&gt;expectedBy&lt;/code&gt; только на &lt;code&gt;my-common&lt;/code&gt; и компилируем зависимость на существующем платформенном модуле для &lt;code&gt;lib-common&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Напомню, что для мультиплатформенных проектов есть понятие expect/actual модификатора. Эти модификаторы позволяют связывать
&amp;ldquo;ожидания реализации&amp;rdquo; интерфейса и фактические платформенные реализации. Так вот, для expect функций и конструкторов в
Kotlin 1.2.40 появилась поддержка значений по умолчанию, пример ниже:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;expect class StringMatcher {
    fun match(value: String, matchStrictly: Boolean = false): Boolean
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;При этом, default параметры поддерживаются только для expect конструкторов/функций, но не для их actual двойников.&lt;/p&gt;

&lt;h3 id=&#34;поддержка-crossinline-suspend-параметров-функций&#34;&gt;Поддержка crossinline suspend параметров функций&lt;/h3&gt;

&lt;p&gt;Напомню, что crossinline модификатор говорит о том, что лямбда, передаваемая в качестве параметра inline функции, может
быть передана в другой контекст, а, например, если мы передадим лямбду без этого модификатора, то компилятор не знает
как поступать в случае non-local возвратов. Для того, чтобы решить эту проблему добавим модификатор crossinline,
который подскажет компилятору, что нужно запретить non-local return и благодаря этому запрету появится возможность передавать
лямбды в другие контексты.&lt;/p&gt;

&lt;p&gt;До версии Kotlin 1.2.40 в случае совместного использования crossinline и suspend для лямбд, мы получали сообщение:
&lt;code&gt;Inline lambda parameters of suspend function type are not fully supported. Add noinline modifier&lt;/code&gt;. Теперь конструкция ниже компилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun schedule(crossinline runner: suspend () -&amp;gt; Unit)  {
    launch(CommonPool) {
        runner()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jvmdefault&#34;&gt;@JvmDefault&lt;/h3&gt;

&lt;p&gt;Экспериментальная фича, которая при таргете на JVM 1.8 генерирует default методы интерфейса при наличии аннотации @JvmDefault. Фича
выключена по умолчанию, чтобы включить передаем компилятору флаг &lt;code&gt;-Xenable-jvm-default&lt;/code&gt;. Т.к. фича экспериментальная, то она
может быть передизайнена, изменена, ровно как может быть изменено название ключа для компилятора.&lt;/p&gt;

&lt;h3 id=&#34;ограничения-видимости-типов-через-наследование-companion-object&#34;&gt;Ограничения видимости типов через наследование companion object&lt;/h3&gt;

&lt;p&gt;В Kotlin 1.3 планируются потенциально ломающие изменения связанные с видимостью через companion object.
Для того чтобы сглядить этот переход в Kotlin 1.2.40 вводится warning на использование краткого имени (non-qualified)
для доступа к внутренностям companion object&amp;rsquo;а родительского класса.
В примере ниже безо взякого импорта, мы можем получить доступ к классу внутри companion object&amp;rsquo;а нашего супертипа. Именно это
и хотят постепенно запретить. Хорошая новость, Kotlin Plugin на борту содержит туллинг для миграции этого кейса, так что, если
вы писали подобный код, то миграция поможет вам обновиться. Пример кода, ниже:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Bar {
    companion object {
        class FromBarCompanion
    }
}

class Foo : Bar {
    fun foo(): FromBarCompanion = TODO()
    // Warning: access to this type by short name 
    // is deprecated and is going to be removed.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В Kotlin 1.3 запретят такие конструкции в принципе. Мне нравится, что разработчики языка тестируют доступную кодовую базу
на 1.5 млн. строк кода для оценки важности этого изменения. В данном случае влияние изменения ожидается минимальным.&lt;/p&gt;

&lt;h3 id=&#34;intellij-idea-улучшения-плагина&#34;&gt;Intellij IDEA. Улучшения плагина&lt;/h3&gt;

&lt;p&gt;Добавлен интеншен для добавления явного return из лямбды. Гифка скажет всё за меня:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2018/04/return-at-label-anim.gif&#34; alt=&#34;Intention1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Добавлен интеншен для добавления и удаления use-site targets аннотаций. В Kotlin на одну аннотацию
(например, в primary конструкторе) может приходиться несколько Java аннотаций. Для контроля того какая именно аннотация
нужна вводятся Use-Site Target. Их-то мы и контролируем. Для интересующихся,
&lt;a href=&#34;http://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets&#34; target=&#34;_blank&#34;&gt;вот ссылка&lt;/a&gt;
на документацию по этому виду аннотаций.&lt;/p&gt;

&lt;p&gt;Добавлена инспекция на подсветку и удаление необязательных явных ссылок на companion object&amp;rsquo;ы.&lt;/p&gt;

&lt;p&gt;Сделаны улучшения по стабильности и производительности.&lt;/p&gt;

&lt;h3 id=&#34;изменения-в-компиляторе&#34;&gt;Изменения в компиляторе&lt;/h3&gt;

&lt;p&gt;Улучшена производительность и поправлены некоторые известные проблемы.&lt;/p&gt;

&lt;p&gt;Обещают более эффективный генерируемый компилятором код для следующийх ситуаций: доступ к private свойствам companion
object&amp;rsquo;ов, проверка enum&amp;rsquo;ов на равенство, сравнение Long&amp;rsquo;ов.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Релиз понравится тем, кто не может жить без inline лямбд в корутинах, любителям плодить common модули в мультиплатформенных проектах,
тем кто пишет Kotlin &amp;ldquo;рядом&amp;rdquo; с Java. В целом есть приятные маленькие улучшения в плагине и радостно видеть, что ошибки дизайна,
как в случае с видимостью типов из чужих companion object&amp;rsquo;ов, исправляются по намеченому плану: deprecated -&amp;gt; restricted.&lt;/p&gt;

&lt;p&gt;Чтобы быть в курсе последних событий &lt;a href=&#34;https://t.me/from_junior_to_senior&#34; target=&#34;_blank&#34;&gt;присоединяйтесь к Telegram&lt;/a&gt; (@from_junior_to_senior)&lt;/p&gt;

&lt;a href=&#34;http://blog.jetbrains.com/kotlin/2018/04/kotlin-1-2-40-is-out/?utm_source=i-osipov.ru&amp;amp;utm_medium=site&#34; target=&#34;_blank&#34;&gt;Источник&lt;/a&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin Updates Report 1.2.20-1.2.30</title>
      <link>https://i-osipov.ru/post/kotlin-updates-report-1.2.20-1.2.30/</link>
      <pubDate>Sat, 31 Mar 2018 11:14:07 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-updates-report-1.2.20-1.2.30/</guid>
      <description>

&lt;p&gt;За первую четверть этого года успело релизнуться несколько версий Kotlin. Для начала давайте перечислим основные
изменения.&lt;/p&gt;

&lt;h3 id=&#34;изменения-из-1-2-20&#34;&gt;Изменения из 1.2.20:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;добавлена поддержка Gradle build cache;&lt;/li&gt;
&lt;li&gt;улучшена инкрементальная компиляция;&lt;/li&gt;
&lt;li&gt;поддержка IDE для Kotlin style guide;&lt;/li&gt;
&lt;li&gt;хинты в IDE для неявный параметров и контекстов лямбд и значений, которые возвращаются из лямбд;&lt;/li&gt;
&lt;li&gt;поддержан делопмент мод в JavaScript DCE Gradle Task;&lt;/li&gt;
&lt;li&gt;мелкие улучшения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;изменения-из-1-2-30&#34;&gt;Изменения из 1.2.30:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;добавлена новая декларация в стандартную библиотеку, которая иммитирует suspend модификатор для лямбд;&lt;/li&gt;
&lt;li&gt;добавлена поддержка для TestNG в kotlin.test;&lt;/li&gt;
&lt;li&gt;притащили поддержку мультиплатформенных модулей для Android;&lt;/li&gt;
&lt;li&gt;добавлена новая вощможность в kapt для репортинга ошибок обработки аннотаций;&lt;/li&gt;
&lt;li&gt;добавлено много новых инспекций и интеншенов в Intellij IDEA, улучшена их производительность;&lt;/li&gt;
&lt;li&gt;поправлены некоторые баги в плагине и компиляторе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ну, а теперь подробно взглянем только на интересные фичи. Полный обзор смотрите в оригинальных источниках (ссылки в конце).&lt;/p&gt;

&lt;h4 id=&#34;gradle-build-cache-precise-java-tracking&#34;&gt;Gradle Build Cache &amp;amp; Precise Java Tracking&lt;/h4&gt;

&lt;p&gt;При использовании версии Gradle 4.3+ вы можете использовать флаги &lt;code&gt;--build-cache&lt;/code&gt; или &lt;code&gt;org.gradle.caching=true&lt;/code&gt;. В этом случае
плагин будет переиспользовать предыдущие результаты сборки. Например, вы собрали версию приложения под master веткой, затем переключились
на ветку feature_X, собрали снова и вернулись назад на мастер. Если вы воспользуетесь флагом выше, то ваш код не будет пересобран
на мастере, т.к. результаты были закешированы.&lt;/p&gt;

&lt;p&gt;Если ваш Java класс изменился так, что это не аффектит ваш Kotlin код, то, в теории, компилятор, может нерекомпилировать
ваш Kotlin код. Для того, чтобы воспользоваться этой &lt;strong&gt;экспериментальной&lt;/strong&gt; фичей нужно добавить следующую проперти в gradle.properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;kotlin.incremental.usePreciseJavaTracking=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;code-conventions&#34;&gt;Code Conventions&lt;/h4&gt;

&lt;p&gt;Ранее были опубликован &lt;a href=&#34;http://kotlinlang.org/docs/reference/coding-conventions.html&#34; target=&#34;_blank&#34;&gt;официальный style guide&lt;/a&gt;.
Начиная с 1.2.20 форматтер Intellij IDEA поддерживает его.&lt;/p&gt;

&lt;h4 id=&#34;клёвые-хинты&#34;&gt;Клёвые Хинты&lt;/h4&gt;

&lt;p&gt;Среди изменений прилетело одно, ну очень полезное, для разработки и использования Kotlin DSL - это хинты для
контекстов лямбд, их неявных параметров и результатов выполнения этих лямбд. Выглядит всё это следующим образом:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/kotlin-updates-report-1.2.20-1.2.30/hints-example.png&#34; alt=&#34;Hints&#34; title=&#34;Hints&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;интересные-интеншены&#34;&gt;Интересные Интеншены&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Появился интеншен для конвертации функции let &amp;lt;-&amp;gt; run и also &amp;lt;-&amp;gt; apply. По сути, конвертер превращает одну функцию в другую и наоброт.
Пожалуй эта фича хороша по следующей причине. Не секрет, что из-за этой кучки функций постоянно появлялись
сомнения что-же использовать, теперь с этим проще и подобные фичи помогают запоминать и укладывать в голове
назначение этих функций, либо каждый раз конвертировать.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Вставка Kotlin кода в пакет. Не до конца понимаю назначение фичи, но выглядит как такой, быстрый рефакторинг.
По сути, вы делаете Ctrl + X, т.е. вырезаете класс, а затем указываете в какой пакет его положить, жмете Ctrl + V и код
перемещается в сгенерированный файл.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;analyzing-data-flow&#34;&gt;Analyzing Data Flow&lt;/h4&gt;

&lt;p&gt;Анализ потоков данных теперь поддержен для смешаных Java-Kotlin проектов. Круто! Если кто-то не знает, что это, то
в Intellij IDEA есть фича в меню Analyze, которая помогает вам в большом и запутанном легаси проекте понять откуда
приходят данные в то или иное место или куда они уходят. Фича классная, помогает не нажимать бесконечно Ctrl + B, а
увидеть, например, дерево вызовов метода get и понять куда забирают наши данные и как с ними работают.&lt;/p&gt;

&lt;h3 id=&#34;вместо-заключения&#34;&gt;Вместо заключения&lt;/h3&gt;

&lt;p&gt;Приятно видеть, что разработчики принимают множество пул реквестов от сторонних разработчиков.&lt;/p&gt;

&lt;p&gt;На этом, на мой взгляд, интересные нововведения исчерпаны. Ниже ссылки на источники. Успехов!&lt;/p&gt;

&lt;p&gt;Источники:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2018/01/kotlin-1-2-20-is-out/&#34; target=&#34;_blank&#34;&gt;Kotlin 1.2.20 is out&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2018/03/kotlin-1-2-30-is-out/&#34; target=&#34;_blank&#34;&gt;Kotlin 1.2.30 is out&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/help/idea/analyzing-data-flow.html&#34; target=&#34;_blank&#34;&gt;Analyzing Data Flow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin Generics</title>
      <link>https://i-osipov.ru/post/kotlin-generics/</link>
      <pubDate>Sun, 04 Feb 2018 06:17:17 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-generics/</guid>
      <description>

&lt;p&gt;Первый релиз языка Kotlin включает в себя Kotlin Generics. Обобщенные типы, благодаря которым
мы с вами можем писать более гибкие приложения с меньшим дублированием кода и большей типобезопасностью.
Одно из важных преимуществ, которое дает вашему приложению использование Generics - проверка типов на этапе компиляции.
Дизайнеры языка Kotlin ввели новые ключевые слова для работы с дженериками, что по началу может ввести в ступор даже
опытного Java разработчика. Сегодня мы с вами обсудим что такое &amp;ldquo;дженерики&amp;rdquo;, удалим страх перед словами типа &amp;ldquo;контравариантность&amp;rdquo;,
а заодно познакомимся с reified generics и star-projection.&lt;/p&gt;

&lt;h2 id=&#34;generics&#34;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Для тех кто вовсе не знаком с обобщенными типами (generics) и для тех, кто порядком подзабыл, я напомню,
что обобщенные типы это возможность выполнять контроль типов в вашем приложении при том, что точный тип вам не известен.
Приведу пример, у вас есть коллекция Set, которая может быть хранилищем для абсолютно разных объектов, так, в одном
месте приложения вы возпользуетесь &lt;code&gt;Set&amp;lt;User&amp;gt;&lt;/code&gt; для работы с множеством пользователей, а в другой части приложения это
будет &lt;code&gt;Set&amp;lt;Task&amp;gt;&lt;/code&gt; - коллекция, которая хранит выполненные задачи. В обоих случаях коллекция Set выполняет возложенные
на неё обязательства, более того, компилятор может проверить, что метод add принимает объект соответствующего типа, ровно
как мы получим объекты этого типа проходя по коллекции.&lt;/p&gt;

&lt;p&gt;Создание классов с обобщенными Kotlin типами в простейшем виде выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;T - это лишь типичный пример именования неизвестного типа, вместо T вы можете использовать любой идентификатор для
удобства. В примере выше мы описали класс, единственный параметр класса имеет общенный тип. Обратите внимание, что свойство
класса имеет модификатор &lt;code&gt;var&lt;/code&gt; и здесь это не с проста, ниже я объясню почему. Воспользуемся контейнером
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container = Container(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обратите внимание, в сравнении с Java нам нет необходимости явно указывать Generic тип для контейнера, т.к. компилятор
обладает полной информацией для выведения этого типа. Аналогично, начиная с Java 7, мы имеем возможность писать сокращенный
вариант с использованием &lt;a href=&#34;http://www.rootfront.com/article/219061/2011-04-21/v-jdk-7-pojavitsja-diamond-operator&#34; target=&#34;_blank&#34;&gt;Diamond Operator&lt;/a&gt;.
В совокупности с возможностью Kotlin выводить типы и для переменных мы имеем сокращенный синтаксис и при этом гибкий набор инструментов.&lt;/p&gt;

&lt;p&gt;Но что, если мы хотим положить в наш контейнер другой Int? Легко!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;container.contained = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Затем, мы можем прочитать его, также легко.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;println(container.contained)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На каждом этапе, на каждой строке компилятор проверяет, что мы работаем именно с Int, а не с чем бы то ни было другим, благодаря
этому, мы, например, не можем записать в наш контейнер String.&lt;/p&gt;

&lt;h2 id=&#34;инвариантный-ковариантный-контравариантный&#34;&gt;Инвариантный, ковариантный, контравариантный&lt;/h2&gt;

&lt;p&gt;Должен вам признаться, если не работать со сложными вариациями обобщенных типов, то со временем всё забывается и приходится
обновлять знания, вспоминать некоторые термины и иногда это дается с трудом, т.к. множество источников по generics пестрят
красивыми словами &lt;em&gt;инвариантный&lt;/em&gt;, &lt;em&gt;ковариантный&lt;/em&gt;, &lt;em&gt;контравариантный&lt;/em&gt;, однако, эти же источники совершенно невнятно объясняют
терминологию. Сегодня я нацелен исправить это и перешагнуть через тонкую грань непонимания в данном вопросе.&lt;/p&gt;

&lt;h3 id=&#34;инвариантность&#34;&gt;Инвариантность&lt;/h3&gt;

&lt;p&gt;Возвращаясь к примеру с контейнером из предыдущего раздела, мы имеем тип &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt;, где вместо T может оказаться
любой тип с верхней границей Any? (об этом позже, коротко, любой nullable и не-nullable тип). Допустим, что мы
сохранили в контейнер значение с типом Int следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Я определяю тип переменной и дженерик для очевидности, по умолчанию, компилятор вполне справляется с их выводом&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Сможем ли мы обобщить нашу переменную чуть больше. Int наследуется от Number, и допустим мы хотим хранить в переменной
контейнер не только с Int, а в принципе с Number, т.е. в нем может находиться любое число, например, Double.
Интуитивно хочется написать:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, такой код не скомпилируется, т.к. не смотря на то, что Int наследуется от Number, то типы с дженериками
&lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt; и &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; не находятся в одной иерархии, по сути, это абсолютно разные типы, никак не
совместимые. Другим языком, &lt;strong&gt;класс Container неизменен (инвариантен) по типу T&lt;/strong&gt;. Следовательно, независимо от иерархии
наследования самих обобщенных типов, по умолчанию, мы не можем говорить об каком-либо следствии иерархии классов
использующих их.&lt;/p&gt;

&lt;h3 id=&#34;ковариантность&#34;&gt;Ковариантность&lt;/h3&gt;

&lt;p&gt;Вы можете задаться вопросом: &amp;ldquo;А зачем это сделано? Почему не дать иерархию как следствие иерархии обобщенных типов по
умолчанию?&amp;ldquo;. Дело в том, что основная задача обобщенных типов - обеспечить безопасность типизации в вашем коде,
уменьшить количество выбрасываемых исключений во времени выполнения уже на этапе компиляции, ну и конечно сделать всё
это гибко. Обрисовать проблему мне помогут массивы из Java. Так получилось, что в Java массивы появились на много
раньше чем обобщенные типы. Когда вводили массивы дали возможность сказать, что если у вас есть массив целочисленных значений (Integer[]), то вы можете
присвоить это значение в переменную Number[]. Казалось бы, вот мы и получили наследование, но давайте рассмотрим
следующий кусочек кода:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 }; //создаем массив Integer 
Number[] b = a; // делаем еще одну ссылку на массив с типом Number[] и это допустимо
b[1] = 4.4; //сохраняем Double значение в массив Integer
//Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException: java.lang.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто мы можем получить ошибку, которую увидим только на этапе выполнения (в JVM есть специальная проверка, которая
выполняется на записи), следовательно, наследование
как следствие по умолчанию - это плохая идея. Однако, следующий код допустим, не так ли?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 };
Number[] b = a;
System.out.println(b[1]);
//output: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь всё законно, мы сделали те же самые действия, но вместо присвоения значения, мы его прочитали. Получается, что иногда
поведение передачи наследования в соответствии с обобщенным типом может быть безопасно. Например, у нас есть метод, который
будет только распечатывать значения из входного параметра и, в принципе, он может принимать любые числа, хоть
Integer и Double в одном массиве, а затем печатать их. Так мы можем вывести правило:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если наша пременная только предоставляет значения, то мы можем допустить, что в ней может находиться значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;аналогично для классов с обобщенными типами:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если объект нашего класса только предоставляет значения, то мы можем допустить, что в нём хранится значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Что значит &amp;ldquo;ниже по иерархии&amp;rdquo;? В Kotlin, как и в любом другом типизированном языке, существует иерархия типов. Если вы
слабо представляете её, то я могу порекомендовать вам вот &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt;
статью, которая поможет разобраться в системе типов. Ну а сейчас, для краткости, я лишь скажу, что для типа Number типы Int и Double
лежат ниже по иерархии типов (могут быть безопасно приведены к Number), а тип Any лежит выше по иерархии типов (к нему можно
безопасно привести Number).&lt;/p&gt;

&lt;p&gt;Другими словами, нужно как-то объяснить компилятору, что в некоторых ситуациях мы готовы к ковариантности. Тут то мы и подобрались
к этому страшному слову. &lt;strong&gt;Ковариантностью&lt;/strong&gt; называется сохранение иерархии типов в производных типах в том же порядке.&lt;/p&gt;

&lt;p&gt;Мы можем сказать, что &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt; ковариантен своему параметру-типу T. Это будет означать, что если Int - потомок
Number, то &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; будет тоже считаться потомком &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;. Напомню, что выше мы убедились
в том, что ковариантность допустима, только когда мы говорим о получении значения, а по умолчанию обобщенные типы инвариантны,
т.е. мы можем безопасно &lt;strong&gt;получить&lt;/strong&gt; Number, если работаем с &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; или контейнером для любого другого наследника Number.
Существует два способа объяснить компилятору то, что Container ковариантен по параметру-типу T в Kotlin. Давайте их рассмотрим.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-уровне-класса-на-месте-объявления&#34;&gt;Ковариантность на уровне класса (на месте объявления)&lt;/h4&gt;

&lt;p&gt;Когда мы объявляем класс, мы можем изначально говорить о том, что класс ковариантен своему типу-параметру. Работать с ковариантными
типами нам помогает ключевое слово &lt;code&gt;out&lt;/code&gt;. Семантика его крайне проста в понимании. Если класс выступает в качестве Producer&amp;rsquo;a,
т.е. мы планируем значения типа Т &lt;strong&gt;только&lt;/strong&gt; получать, то мы используем ключевое слово &lt;code&gt;out&lt;/code&gt;, т.е. класс поставляет
значения типа &lt;strong&gt;наружу&lt;/strong&gt;. Давайте изменим декларацию нашего класса Container следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Тут же мы получаем ошибку компиляции, но какую?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type parameter T is declared as &#39;out&#39; but occurs in &#39;invariant&#39; position in type T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Какая странная ошибка, где это у нас возникает потребность в инвариантном состоянии? Точно! Ключевое слово &lt;code&gt;var&lt;/code&gt;!
Мы совсем забыли о том, что &lt;code&gt;var&lt;/code&gt; отличается от &lt;code&gt;val&lt;/code&gt; наличием возможности изменить это значение, а как мы помним,
ковариантность возможна только в случае, если вы запретите любые изменения значения. Заменим var на val&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(val contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот и всё. Теперь наш класс Container ковариантен параметру-типу T, это означает, что мы легко можем использовать следующую
конструкцию:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инвариантность как рукой сняло! Но чем мы за это заплатили?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
val container2: Container&amp;lt;Number&amp;gt; = container
container2.contained = 4.0 //не компилируется, т.к. нельзя менять значение, зато мы
// защищены от ошибок как с Java массивами
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы видите теперь тип &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; наследник типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, благодаря чему мы можем свободно присваивать его переменным
типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, но не можем менять значения типа T и это правильно. Представьте, если бы последняя строчка
компилировась. Это значит, что через свойство contained было бы записано Double значение! Получается, что переменная
container с типом &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; содержала бы не Int, а Double, ведь и container, и container2 это две ссылки на один и
тот же объект в памяти. И при попытке получения container.contained мы бы словили &lt;code&gt;ClassCastException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ковариантность на уровне класса - дело хорошее, оно гребёт под себя весь класс и заставляет нас не менять значения, но, что
если нам не нужна ковариантность для всего класса? Пора разобраться с ковариантностью на месте использования.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-месте-использования&#34;&gt;Ковариантность на месте использования&lt;/h4&gt;

&lt;p&gt;Один из мощных механизмов управления иерархиями обобщенных типов это ковариантность на уровне объявления. Вспомним нашу
первую версию инвариантного контейнера:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если наш класс не ковариантен какому-либо параметру T, то мы можем свободно менять его значения как хотим:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val sourceContainer: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
sourceContainer.contained = 4 // компилируется
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А в тот момент, когда нам понадобится завести общую переменную под контейнеры с разными параметрами-типами, мы сможем это сделать, воспользовавшись
ковариантностью на месте использования (проекцией типа).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val covariantContainer: Container&amp;lt;out Number&amp;gt; = sourceContainer
covariantContainer.contained = 4 
/*  не компилируется, работаем с переменной у которой тип ковариантен параметру-типу
    значит нельзя менять значения, т.к. мы не знаем исходный тип, 
    там может быть любой контейнер с параметром-типом наследником Number
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря, ковариантности на уровне объявления мы можем делать многие вещи очень гибко, например, написать следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T: Any&amp;gt; { //что такое T: Any вы узнаете чуть позже
    /* 
        Пусть на момент создания контейнера мы еще не знаем,
        что конкретно он будет содержать, но знаем точно, что 
        что-то с некоторым типом T он должен, следовательно после 
        создания, рано или поздно, мы поменяем значение поля contained,
        а значит оно по определению не может быть val. В такой ситуации,
        мы не можем объявлять ковариантность на уровне класса
     */
    lateinit var contained: T

    override fun toString(): String {
        return &amp;quot;Container(contained=$contained)&amp;quot;
    }

}

/*
    Возвращаемый тип Container&amp;lt;out Number&amp;gt; создает ковариантность
    на месте использования, следовательно, из метода мы возвращаем 
    контейнер, который типизирован чем-то ниже в иерархии наследования
 */
fun createIntContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Int&amp;gt;()
    container.contained = 42
    return container
}

fun createDoubleContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Double&amp;gt;()
    container.contained = 42.0
    return container
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    var covariantContainer = createIntContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
    covariantContainer = createDoubleContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вывод в консоли:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Container(contained=42)
Container(contained=42.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом, мы успешно хранили в одной переменной контейнеры с разным параметром-типом, при том, что сам контейнер
инвариантен по своему параметру-типу Т.&lt;/p&gt;

&lt;p&gt;С ковариантностью разобрались, осталась контравариантность.&lt;/p&gt;

&lt;h3 id=&#34;контравариантность&#34;&gt;Контравариантность&lt;/h3&gt;

&lt;p&gt;Кроме того, чтобы описывать классы как producer&amp;rsquo;ы, иногда, нам может понадобиться
описать классы как consumer&amp;rsquo;ы или &lt;strong&gt;потребители&lt;/strong&gt;. Давайте рассмотрим следующую иерархию типов:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Пользователь
   /           \
Работник  Администратор   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пусть перед нами стоит задача написать логгер тех, кто входит в систему. Каждый пользователь системы имеет логин и именно его
мы будем распечатывать.&lt;/p&gt;

&lt;p&gt;Объявление такой иерархии типов может выглядеть, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;open class User(var login: String)

class Worker(login: String): User(login)

class Admin(login: String): User(login)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим класс Printer, который инкапсулирует в себе логику печати:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;T: User&amp;gt; {
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пока класс инвариантен и в большинстве случаев этого будет достаточно благодаря автоматическому приведению типов. Подумайте,
если бы мы передали в метод print объект типа Admin, то он спокойно был бы принят компилятором и приведен к верней границе
обобщенного типа User, но все приложения разные. Допустим, у нас есть метод &lt;code&gt;printAdmin&lt;/code&gt;, который знает какие предобработки нужно
сделать, а затем вызывает правильный метод у объекта класса &lt;code&gt;Printer&lt;/code&gt;. Напишем метод &lt;code&gt;printAdmin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun printAdmin(printer: Printer&amp;lt;Admin&amp;gt;, admin: Admin) {
    //admin specific
    printer.print(admin)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такой метод в своём использовании сужает вариативность нашего принтера, теперь принтер должен уметь печатать именно администратора.
Принтер для работника здесь не подойдет, а подойдет ли принтер для пользователя в принципе? Почему бы и нет, админ - тоже пользователь,
значит мы должны уметь печатать его тем же принтером, что и других пользователей. Получается, если Админ наследуется от Пользователя, то
принтер пользователя, должен быть наследником принтера админа (только в этом случае мы сможем безопасно привести тип
&lt;code&gt;Printer&amp;lt;User&amp;gt;&lt;/code&gt; к типу &lt;code&gt;Printer&amp;lt;Admin&amp;gt;&lt;/code&gt;). За сим мы наблюдаем разворот иерархии в другую сторону - это и обозначают сложным
словом контравариантность. Схематично контравариантность можно обозначить следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   User         Printer&amp;lt;Admin&amp;gt;       
    ↑     →         ↑
  Admin         Printer&amp;lt;User&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы, уверен, уже запомнили, обобщенные типы сами по себе инвариантны, по этому следующий код не скомпилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, мы можем это изменить. Для этого в нашем арсенале есть ключевое слово &lt;code&gt;in&lt;/code&gt;. Применять мы можем его как на уровне объявления,
так и на уровне использования, аналогично ковариантной аннотации обобщенного типа &lt;code&gt;out&lt;/code&gt;. Выглядит применение на уровне класса
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;in T: User&amp;gt; { //появился in
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Компилятор будет всячески не давать заполучть T из объектов типа контравариантного типу-параметру. После манипуляций выше наш
код ниже компилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И печатает:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User admin is logged in
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;producer-out-consumer-in&#34;&gt;Producer Out, Consumer In&lt;/h2&gt;

&lt;p&gt;В классической книге Effective Java автор Joshua Bloch предлагает аббревиатуру PECS для запоминания правила использования
ключевых слов extends и super в обобщенных типах Java. Аббревиатура гласит, &lt;code&gt;Producer Extends, Consumer Super&lt;/code&gt;, что
означает если класс является Producer&amp;rsquo;ом обобщенного типа, то необходимо использовать ключевое слово extends, а если потребителем, то
super. В Kotlin всё на много проще. Хотя мы можем переизобрести аббревиатуру блоха POCI (Producer Out, Consumer In),
это того не стоит. На самом деле, ключевые слова out и in говорят сами за себя, только думать нужно не в терминах иерархии типов,
а, скорее, думать о том как перемещаются данные. Если ваш класс поставляет обобщенно-типизированные значения наружу,
то вам нужен &lt;code&gt;out&lt;/code&gt;, а если класс потребляет значения обобщенного типа, то нужен &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;верхняя-граница-обобщенного-типа&#34;&gt;Верхняя граница обобщенного типа&lt;/h2&gt;

&lt;p&gt;Как вы уже заметили, несколько раз за статью я использовал конструкции вида &lt;code&gt;&amp;lt;T: SomeClass&amp;gt;&lt;/code&gt;. Прежде всего я хочу вас спросить,
а какой тип находится на вершине иерархии типов в Kotlin? Аналогично Object в Java, к чему можно привести любой тип?
Правильным ответом будет &lt;code&gt;Any?&lt;/code&gt;. Сам по себе класс &lt;code&gt;Any&lt;/code&gt; это аналог &lt;code&gt;Object&lt;/code&gt;, однако, в следствие поддержки Nullable и не
Nullable типов в Kotlin мы получили &lt;code&gt;Any?&lt;/code&gt;. Фактически, &lt;code&gt;Any?&lt;/code&gt; соответствует любому типу и &lt;code&gt;null&lt;/code&gt;, а &lt;code&gt;Any&lt;/code&gt; только любому типу.
Подробнее об иерархии типов я предлагаю прочитать статью, которую вы найдете в последнем разделе &amp;ldquo;Бонус&amp;rdquo;. Обобщенные
типы ограничены сверху максимально широким типом, а именно &lt;code&gt;Any?&lt;/code&gt; из-за чего может возникать некоторое недопонимание в использовании их.
Следовательно, по умолчанию дженерик тип - Nullable, это означает, что свойства с таким типом могут принимать значения
&lt;code&gt;null&lt;/code&gt;, но когда мы будем работать с ними, то компилятор потребует удостовериться, что через свойство доступно не null значение.
Таким образом, когда мы пишем &lt;code&gt;&amp;lt;T: Any&amp;gt;&lt;/code&gt; мы явно говорим, что тип, указываемый в качестве конкретного варианта вместо
обобщенного типа не может содержать &lt;code&gt;null&lt;/code&gt;. Аналогично, мы можем понизить верхнюю границу по иерархии еще ниже и потребовать, например,
указывать в качестве типов только чила: &lt;code&gt;&amp;lt;T: Number&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Верхних границ может быть несколько, в этом случае необходимо указывать их в специальном разделяющем &lt;code&gt;where&lt;/code&gt; условии:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T) 
        where T: Number, 
              T: Comparable&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Аналогично для функции для которой объявлен обобщенный тип.&lt;/p&gt;

&lt;h2 id=&#34;star-projection&#34;&gt;Star-Projection&lt;/h2&gt;

&lt;p&gt;Часто мы сталкиваемся с так называемой &lt;em&gt;проекцией типов&lt;/em&gt;. Простым языком, это ограничение типа на месте использования. Например,
мы не хотим, чтобы в наш контейнер могли по ошибке что-то записать внутри метода, для этого ограничиваем тип:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;out Number&amp;gt;) {
    container.contained = 4 //не компилируется    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря out здесь мы можем только читать из контейнера, но не записывать. В примерах выше мы обсуждали это поведение.&lt;/p&gt;

&lt;p&gt;Однако, иногда возникает ситуация, что у нас нет информации о необходимом нам типе проекции, но мы знаем, что Container, к примеру, имеет
верхнюю границу для ковариантного параметра-типа - Number и нам этого достаточно. Тогда, мы можем воспользоваться star-projection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;*&amp;gt;) { // символ *
    println(container.value) // мы можем печатать значения, т.к. знаем верхнюю границу обобщенного типа
    container.value = 4 // но мы не можем писать значения, т.к. не знаем типа
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для ковариантных параметров * означает &amp;ldquo;могу читать значения с типом верхней границы обобщенного типа&amp;rdquo;.
Для контравариантных параметров * означает &amp;ldquo;не могу ничего безопасно писать&amp;rdquo;
Для инвариантных параметров символ * означает: &amp;ldquo;при чтении аналогично * для ковариантного, при записи аналогично * для контравариантного параметра&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;стирание-типов&#34;&gt;Стирание типов&lt;/h2&gt;

&lt;p&gt;Аналогично с Java в Kotlin происходит стирание информации об обобщенных типах, т.е. обобщенные типы - наши помощники только
на этапе компиляции. На этапе выполнения кода информации уже нет, однако, есть хитрые способы, которые вы можете найти для
частного решения в некоторых случаях.&lt;/p&gt;

&lt;h2 id=&#34;reified-generics-и-inline-function&#34;&gt;Reified Generics и inline function&lt;/h2&gt;

&lt;p&gt;Модификатор inline для функций позволяет встраивать код в место вызова без какого-либо обращения к реальной функции.
Такой модификатор позволяет не создавать слишком много лямбд, которые передаются в методы и является небольшой оптимизацией.
Кроме того, этот модификатор позволяет сохранить информацию об обобщенных типах объявленных в рамках методов даже на этапе выполнения. Рассмотрим
небольшой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T: Number&amp;gt; printClass(value: T) {
    println(T::class)
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    printClass(4)
    printClass(4.0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Результат выполнения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class kotlin.Int
class kotlin.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ключевое слово &lt;code&gt;reified&lt;/code&gt; говорит о том, что нужно иметь доступ к информации о типе T. Таким образом, в некоторых случаях,
даже явно не передавая тип, мы можем работать с ним.&lt;/p&gt;

&lt;h2 id=&#34;резюме&#34;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;Подводя итоги статьи, хочется отметить, что обобщенные типы - довольно сложная часть как Java, так и Kotlin и их понимание
крайне важно для бесстрашного построения гибких классов, готовых к разностороннему применению. Можно долго спорить,
что понятнее Java программисту, который пришел в Kotlin, Java синтаксис обобщенных типов или &lt;code&gt;out&lt;/code&gt; и &lt;code&gt;in&lt;/code&gt;. На мой взгляд,
если у вас есть понимание того для чего вы применяете обобщенные типы, то никакой синтаксис не помешает вам их использовать.&lt;/p&gt;

&lt;h2 id=&#34;бонус&#34;&gt;Бонус&lt;/h2&gt;

&lt;p&gt;Погружаясь в тему обобщенных типов вы можете посмотреть видео с конференции JPoint2016 &amp;ldquo;Неочевидные Дженерики&amp;rdquo; об обобщенных типах из Java
вот &lt;a href=&#34;https://www.youtube.com/watch?v=_0c9Fd9FacU&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Статья об &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;иерархии типов в Kotlin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Альтернативное &lt;a href=&#34;https://kotlinlang.ru/docs/reference/generics.html&#34; target=&#34;_blank&#34;&gt;чтение&lt;/a&gt; на тему дженериков&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Instant View in Action</title>
      <link>https://i-osipov.ru/post/instant-view-in-action/</link>
      <pubDate>Sat, 20 Jan 2018 00:00:00 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/instant-view-in-action/</guid>
      <description>

&lt;p&gt;Telegram идет большими шагами по планете и масштабы постоянно растут. Многие из нас часто читают
статьи на каналах, нажимают кнопку Instant View и вот, статья уже перед нами, но как это получилось?
Instant View работает по первой ссылке, но почему не по каждой? Сегодня мы с вами разберемся как взять
свой сайт и адаптировать Instant View к нему. Действовать мы будем на примере i-osipov.ru.&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;h1 id=&#34;с-чем-мы-имеем-дело&#34;&gt;С чем мы имеем дело&lt;/h1&gt;

&lt;p&gt;Под капотом у i-osipov.ru находится hugo, hugo это генератор статического контента. Для понимания,
когда я пишу пост - у меня есть отдельный проект на диске в котором есть предопределенные директории.
В директориях лежит контент, например, в &lt;em&gt;content/post/*&lt;/em&gt; находятся все посты на сайте, а при
выполнении команды hugo в терминале стоя в корневой папке у меня генерируется статика, html + css + js,
используется преднастроенная тема, в итоге статика выгружается в GitHub репозиторий, публикуется с
помощью GitHub Pages, а i-osipov.ru лишь альтернативное имя, через которое доступен контент.&lt;/p&gt;

&lt;p&gt;Как вы можете догадаться, формат статики определяю не я, определяет hugo. Теперь передо мной стоит
задача разобраться в этом формате и научить Telegram генерировать Instant View для моего сайта.
Прежде всего, источниом информации по этому вопросу для меня является
&lt;a href=&#34;https://instantview.telegram.org/&#34;&gt;instantview.telegram.org&lt;/a&gt;. С этой страницы мы узнаем о том, что
Instant View (&lt;strong&gt;IV&lt;/strong&gt;) - это механизм позволяющий открывать ваши ссылки прямо в телеграм, это отличный user
friendly способ подать ваш контент, ваш сайт может быть не оптимизирован для мобильных устройств
(это нас не так волнует, т.к. у hugo с этим почти всё в порядке), а слово &lt;em&gt;Instant&lt;/em&gt; означает мгновенную
загрузку и кеширование на серверах телеграмма.&lt;/p&gt;

&lt;h1 id=&#34;как-работает-instant-view&#34;&gt;Как работает Instant View&lt;/h1&gt;

&lt;p&gt;Втавка ссылки на внешний контент в текстовое поле влечет за собой цепочку событий: генерируется link preview -
это короткая инфрмация о том какой контент доступен по ссылке, специальный &lt;em&gt;Instant View Bot&lt;/em&gt; проверяет,
есть ли шаблон IV для указанного сайта. После &lt;a href=&#34;https://instantview.telegram.org/#publishing-templates&#34;&gt;публикации шаблона&lt;/a&gt;
он становится доступен всем пользователям Telegram. До процесса глобальной публикации вы можете давать ссылку
читателям без процесса публикации и подтверждения, но об этом в разделе &lt;em&gt;Публикация&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;создание-instant-view&#34;&gt;Создание Instant View&lt;/h1&gt;

&lt;h2 id=&#34;редактор-instant-view&#34;&gt;Редактор Instant View&lt;/h2&gt;

&lt;p&gt;С этого момента начинается процесс разработки, так что если у вас есть к чему прикрутить IV, то самое время взять ноутбук и приготовится.&lt;/p&gt;

&lt;p&gt;Все манипуляции вашими IV происходят на странице &lt;a href=&#34;https://instantview.telegram.org/my&#34;&gt;instantview.telegram.org/my&lt;/a&gt;
При первом входе вас попросят залогиниться через telegram. Далее вы даёте ссылку на любой контент (пост на котором мы будем
отлаживать шаблон) на вашем сайте.
Что именно вы выберете - не так важно, главное, чтобы верстка контента была примерно одинаковой. Я возьму один из последних постов.
Редактор открылся, теперь мы видим следующую картину&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/instant_view_in_action/iv_editor.jpg&#34; alt=&#34;InstantViewEditor&#34; title=&#34;Instant View Editor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Перед нами 3 рабочих пространства. Слева мы видим подгруженную, словно с телефона, версию страницы блога, по центру
расположилось поле для указания правил (это наше рабочее пространство), а справа мы видим результат - то, как примерно
будет выглядеть IV. На скриншоте по центру по умолчанию пусто, но для полноты я вписал туда &lt;code&gt;body: //article&lt;/code&gt;. Такая
простая конфигурация говорит о том, что тело нашего Instant View будет парситься Instant View Bot&amp;rsquo;ом прямо из html тега
под названием &lt;em&gt;article&lt;/em&gt; (выбранного благодаря xpath). Это первое из двух обязательных полей для создания Instant View, дальше мы разберем правила,
которые помогут сформировать качественное встроенное представление внутри Telegram из того контента, который доступен на
странице. При необходимости, вы можете перезагрузить исходную страницу и сохранить ваши описанные правила с помощью
&lt;code&gt;ctrl + S&lt;/code&gt; или &lt;code&gt;cmd + S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;В нижней части страницы располагается результат последней операции и вывод функции @debug на которую мы взглянем в
разделе &lt;em&gt;Дебаггер&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;С помощью символа &lt;code&gt;#&lt;/code&gt; обозначается начало комментария, текст справа этого символа не интерпритируется.&lt;/p&gt;

&lt;h2 id=&#34;панель-разработчика&#34;&gt;Панель разработчика&lt;/h2&gt;

&lt;p&gt;Важнейший инструмент на этапе построения Instant View это Панель разработчика в вашем браузере. К примеру, в Google
Chrome она открывается при нажатии &lt;code&gt;F12&lt;/code&gt; или &lt;code&gt;Ctrl + Shift + I&lt;/code&gt;, либо поищите в меню Дополнительные инструменты -
Инструменты разработчика.&lt;/p&gt;

&lt;h2 id=&#34;фильтрация-контента&#34;&gt;Фильтрация контента&lt;/h2&gt;

&lt;p&gt;Помните, что Instant View предназначен для относительно стачесных статей, центральная страница динамичного сайта -
плохой кандидат для IV. Следовательно и не каждая станица интересующего сайта нам подойдет. Часто, статьи обособляются
html тегом &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; и это знак того, что на странице есть статья. Для того, чтобы по ошибке Instant View Bot не интерпретировал
ссылки на другие страницы сайта как встроенные, нам необходимо добавить условия.&lt;/p&gt;

&lt;h2 id=&#34;условия&#34;&gt;Условия&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#conditions&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Условия начинаются либо с &lt;code&gt;?&lt;/code&gt;, либо с &lt;code&gt;!&lt;/code&gt; по следующему формату:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?condition:  xpath_query   # пример условия
!condition:  regexp        # в правой части условия находится регулярное выражение
?condition                 # условие без параметров
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если условия следуют друг за другом, то они интерпретируются как единый блок, где &lt;code&gt;?&lt;/code&gt;-правила это ИЛИ, а &lt;code&gt;!&lt;/code&gt;-правила
это И. В блоке условий должно быть как минимум одно условие ИЛИ.&lt;/p&gt;

&lt;p&gt;Несколько блоков условий выглядят следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
# здесь мы пишем правила, которые применим когда на странице есть тег article

?exists: //content
# здесь мы пишем правила, которые применим когда на странице есть тег content, а тега article может и не быть

?exists: //content
!exists: //article
# здесь мы пишем правила, которые применим когда на странице и есть тег contentи тег article
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конечно, кроме условия &lt;code&gt;exists&lt;/code&gt; существуют и другие, ниже их полный список на текущий момент:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?domain: regexp # проверяет соответствует ли домен регулярному выражению

?domain_not: regexp # проверят не запрещен ли домен

?path: regexp # проверяет путь до текущей страницы соответствует регулярному выражению

?path_not: regexp # проверяет, что путь не соответствует регулярному выражению

?exists: xpath_query # проверяет наличие узла на странице

?not_exists: xpath_query # проверяет отсутствие узла на странице

?true
# правила здесь будут применены всегда
?false
# правила здесь не применятся никогда (по сути место для неработающих правил)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для нашего примера я выбрал следующие условия:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
!domain: i-osipov\.ru
!path: /post/.+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Посты находятся всегда под i-osipov.ru/post/* и в каждом посте должен существовать тег &lt;em&gt;article&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;свойства&#34;&gt;Свойства&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#properties&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Свойства содержат в себе значения и имеют следующий формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;property: xpath_query
property: &amp;quot;Some string&amp;quot;
property: null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;По умолчанию свойства не переопределяются, т.е. если не нулевое значение было записано в свойство, то для того, чтобы
его переопределить, нужно испрользовать символ &lt;code&gt;!&lt;/code&gt;, т.е. конструкция &lt;code&gt;property!: //content&lt;/code&gt; сможет обновить свойство,
если правая часть вернет не возвращает пустой результат и не &lt;code&gt;null&lt;/code&gt;. Если же правая часть вернет пустой результат,
то значение не переопределится, для того, чтобы это произошло, необходимо воспользоваться &lt;code&gt;!!&lt;/code&gt;. В результате,
&lt;code&gt;property!!: //content&lt;/code&gt; перезапишет значение свойства вне зависимости от результата.&lt;/p&gt;

&lt;p&gt;Ранее, я упоминал о том, что есть два свойства, которые обязательно нужно определить. Мы уже познакомились со свойством
&lt;code&gt;body: //article&lt;/code&gt;, которое помогает Instant View Bot определить где же находится основной контент статьи. Второе,
обязательное к определению свойство это &lt;code&gt;title&lt;/code&gt;, например, правило &lt;code&gt;title: //article//h1&lt;/code&gt; выберет заголовок первого уровня внутри
блока статьи и объяснит IV Bot&amp;rsquo;у, через свойство &lt;em&gt;title&lt;/em&gt;, где же смотреть название статьи.&lt;/p&gt;

&lt;p&gt;Рассмотрим другие свойства, которые нам доступны из коробки:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Формат описания
название: тип # пояснение
Для создания свойства в конструкциях ниже тип нужно заменить конкретным значением

title: RichText # заголовок страницы
body: RichText # тело страницы
author: String # имя автора
author_url: URL # ссылка на автора
published_date: Unixtime # дата публикации
description: String # краткое описание для превью ссылки
image_url: Url # ссылка на фото для превью ссылки
document_url: Url # ссылка на документ для превью ссылки
channel: String # указатель на авторский канал, например, @channelName
cover: Media # Обложка страницы
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для нашего примера, я обозначу следующие свойства&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body: //article
title: //h1
channel: &amp;quot;@from_junior_to_senior&amp;quot;
description: //h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Наших текущих знаний хватает только на такие простые манипуляции, но даже их достаточно для минимального варианта.
Для полноты картины пока &amp;ldquo;захардкодим&amp;rdquo; остальные интересующие нас значения, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;author: &amp;quot;Ivan Osipov&amp;quot;
author_url: &amp;quot;https://i-osipov.ru&amp;quot;
published_date: &amp;quot;2017-07-23&amp;quot;
image_url: &amp;quot;https://i-osipov.ru/img/posts/how_to_create_telegram_bot/header.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В следующих разделах мы с вами перепишем этот хардкод, но пока так.&lt;/p&gt;

&lt;p&gt;Результат таких манипуляций ниже на скриншоте редактора:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/instant_view_in_action/iv_step1.jpg&#34; alt=&#34;Instant View. Шаг 1&#34; title=&#34;Instant View. Шаг 1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;типы-данных&#34;&gt;Типы данных&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#supported-types&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В главе выше мы затронули типы и прежде всего необходимо пояснить, что страница Instant View содержит разные типы.
Каждый тип ассоциирован с html тегом, например, тип &lt;code&gt;Header&lt;/code&gt; определяет объекты созданные на основе тегов &lt;code&gt;&amp;lt;h1&amp;gt; - &amp;lt;h4&amp;gt;&lt;/code&gt;.
У типов есть допустимые дочерние типы, по сути, это те, кто могут быть вложены внутрь. Благодаря типам, практически
весь контент под тегом &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; может быть распознан без дополнительных усилий. Типы важная, но при этом довольно
простая составляющая Instant View, по этому полный перечень с описанием доступен по
&lt;a href=&#34;https://instantview.telegram.org/docs#supported-types&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;На ваших страницах может быть представлен какой-либо код на опрежеденном языке, телеграм не поддерживает подстветку
синтаксиса, но они планируют сделать это в будущем. По этой причине, для больших блоков кода обособленных в &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;
желательно указывать аттрибут &lt;code&gt;data-language&lt;/code&gt;, как результат, подстветка кода в Instant View появится сама собой со
временем.&lt;/p&gt;

&lt;h2 id=&#34;переменные&#34;&gt;Переменные&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#variables&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Концепция переменных знакома вам из любого языка программирования. Здесь основное предназначение переменных - гибкое
манипулирование ими перед назначением их значений свойствам. Кратко, у нас есть идентификатор, который начинается с &lt;code&gt;$&lt;/code&gt;,
например, &lt;code&gt;$myvariable&lt;/code&gt; и есть значение. Идентификатор может быть только в нижнем регистре. Значение переменной может
быть xpath или строка, в последнем  случае переменная будет содержать
список из одного текстового элемента в котором определен заданный в строке текст. Кроме того, вы можете назначить
переменной &lt;code&gt;null&lt;/code&gt;, что позволяет сбросить значение в ней. Вы можете свободно менять значение переменной, если же вы
хотите назначить переменной значение только в том случае, если раньше никакое значение не было присвоено, то можно
воспользоваться символом &lt;code&gt;?&lt;/code&gt;, написанным после идентификатора, вот так &lt;code&gt;$myvariable?&lt;/code&gt;,
в том месте, где происходит смена значений.&lt;/p&gt;

&lt;p&gt;Резюмируя, мы можем менять значения переменных следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$images:  //img
$images: //img[@src]  # значение переменной $images будет переопределено
$images?: //article//img  # новое значение для переменной $images будет выставлено, если в переменной ничего не записано
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы объяснить вторую строчку и что же такое &lt;code&gt;//img[@src]&lt;/code&gt; давайте поговорим о расширенном XPath.&lt;/p&gt;

&lt;h2 id=&#34;расширенный-xpath&#34;&gt;Расширенный XPath&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#extended-xpath&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Прежде всего нужно сказать, что у нас есть чуть больше чем XPath для формирования выборки узлов html документа. Если вы пока не
знакомы с XPath, то самое время это сделать. Начать можно &lt;a href=&#34;https://ru.wikipedia.org/wiki/XPath&#34;&gt;отсюда&lt;/a&gt;. Кратко,
XPath это язык, который позволяет навигироваться по XML. Нtml и Xml родственные форматы, по этому мы можем навигироваться и
по Html.
Взглянем на дополнительные возможности, которые дает нам расширенный XPath от Telegram.&lt;/p&gt;

&lt;h3 id=&#34;относительный-xpath&#34;&gt;Относительный XPath&lt;/h3&gt;

&lt;p&gt;В разделе &lt;em&gt;Переменные&lt;/em&gt; мы узнали о таком типе правил как объявление переменных, здесь этот концепт нам пригодится.
Стандартный XPath выполняет поиск по всему документу (мы указываем абсолютное выражение для поиска, искать будем от
корня документа), однако, это порождает длинные цепочки описания путей до узлов. В расширенном XPath мы можем объяснить
в каком контексте необходимо выполнять поиск при помощи переменных. Представим, что у нас есть следующее html дерево.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;
    &amp;lt;article&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок 1 уровня&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;Заголовок 2 уровня&amp;lt;/h2&amp;gt;
    &amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для навигации по такому дереву мы можем использовать стандартный XPath&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//article/h1 # находит &#39;Заголовок 1 уровня&#39;
//article/h2 # находит &#39;Заголовок 2 уровня&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Либо, так как мы изначально знаем о том, что поиск будет выполняться внутри узла &lt;code&gt;article&lt;/code&gt;, то можем воспользоваться
переменной и таким образом задать контекст:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$myArticle: //article
$myArticle/h1 # находит &#39;Заголовок 1 уровня&#39;
$myArticle/h2 # находит &#39;Заголовок 2 уровня&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;один-узел-вместо-нескольких&#34;&gt;Один узел вместо нескольких&lt;/h3&gt;

&lt;p&gt;Иногда, мы знаем, что XPath вернет нам несколько результатов, но мы хотим только первый, второй или любой другой из
них. По умолчанию XPath возвращает список узлов, однако, для того, чтобы сузить область поиска мы можем явно выбрать
один из полученных узлов с помощью выражения &lt;code&gt;(xpath_query)[n]&lt;/code&gt;, здесь &lt;code&gt;n&lt;/code&gt; - это порядковый номер узла в списке,
полученном с помощью &lt;code&gt;xpath_query&lt;/code&gt;. Нумерация начинается с 1, либо на месте &lt;code&gt;n&lt;/code&gt; можно записать &lt;code&gt;last()&lt;/code&gt; и тогда
будет выбран последний элемент. Такой синтаксис поддерживается только для всего выражения целиком. Ниже несколько примеров:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$headers:    //h1                    # все &amp;lt;h1&amp;gt; узлы на странице
$header2:    (//h1)[2]               # второй &amp;lt;h1&amp;gt; узел на странице
$header2:    ($headers)[2]           # аналогично предыдущему
$last_link:  ($header2//a)[last()]   # последняя ссылка (&amp;lt;a&amp;gt;) внутри контекста $header2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;выбор-по-css-классу&#34;&gt;Выбор по css классу&lt;/h3&gt;

&lt;p&gt;Отличный инструмент, который мы получили с расширенным XPath это выражение &lt;code&gt;has-class(&amp;quot;class&amp;quot;)&lt;/code&gt;, которое позволяет выбирать
узлы имеющие определенный класс. Это выражение - сокращение следующего
&lt;code&gt;contains(concat(&amp;quot; &amp;quot;, normalize-space(@class), &amp;quot; &amp;quot;), &amp;quot; class &amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Я покажу практическое применение инструмента на своём же блоге, для которого настраиваю Instant View. Ранее мы присвоили
свойствам title и description следующие значения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title: //h1
description: //h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но это не до конца верно, правильнее ограничить контекст поиска и мы можем это сделать. Все заголовки документа могут
быть доступны только через &lt;code&gt;div&lt;/code&gt; элемент с классом &lt;code&gt;post-heading&lt;/code&gt;, зная это, мы можем воспользоваться &lt;code&gt;has-class&lt;/code&gt; и
получим следующее обновление для нашего шаблона.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$header: //div[has-class(&amp;quot;post-heading&amp;quot;)]
title: $header/h1
description: $header/h2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;элемент-одного-уровня&#34;&gt;Элемент одного уровня&lt;/h3&gt;

&lt;p&gt;XPath дает нам мощные возможности для поиска, но не всегда они легко читаемы, последние два улучшения - это сокрщенные
формы стандарных XPath выражений. В стандартном XPath мы можем донянуться до предшествующего &lt;code&gt;sibling&lt;/code&gt; узла (по русски это
&amp;ldquo;элемент одного уровня&amp;rdquo;) следующим образом: &lt;code&gt;preceding-sibling::*[1]/self&lt;/code&gt;, расширенный XPath дает нам сокращения в виде
&lt;code&gt;prev-sibling&lt;/code&gt;, можно сравнить в применении:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$divsAfter: //div[./preceding-sibling::*[1]/self::img] # Собирает все div элементы предшествующие узлам img

$divsAfter: //div[./prev-sibling::img] # Сокращенная форма того же самого
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для последующих элементов есть аналогичное выражение &lt;code&gt;next-sibling&lt;/code&gt;, которое является сокращением
&lt;code&gt;following-sibling::*[1]/self&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;функции&#34;&gt;Функции&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#functions&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Пожалуй важнейший и очень гибкий вид правил - функции. С их помощью вы сможете удалять ненужные элементы, производить
трансформации одних элементов в другие и так далее. Функции начинаются с символа &lt;code&gt;@&lt;/code&gt; и есть несколько разных форматов
их применения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@function:                 xpath_query   # функция без параметров
@function(param):          xpath_query   # дополнительный параметр указывается в скобках
@function(p1 p2):          xpath_query   # параметры могут быть разделены пробелом
@function(p1, &amp;quot;param #2&amp;quot;): xpath_query   # или запятой и заключены в кавычки при необходимости
@function:                 &amp;quot;Some text&amp;quot;   # вместо xpath можно использовать строки
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;У функции определяется основной аргумент, например, xpath выражение или строка. Основной аргумент записывается справа
от &amp;ldquo;:&amp;ldquo;. В случае строки в качестве аргумента, на самом деле, будет передан список с одним тектовым элементом, который
содержит указанный текст.&lt;/p&gt;

&lt;p&gt;Разберем пример. Внутри тега &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, который содержит контент статьи, находится блок с комментариями, это встроенные
Disqus комментарии. Однако, эти комментарии не поддерживаются в Instant View и нам необходимо их исключить. Для его
мы воспользуемся функцией &lt;code&gt;@remove&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Открыв консоль разработчика в Chrome и выбрав элемент, который я хочу удалить, я обнаружил, что в DOM дереве исходной
страницы есть два элемента. Эта часть дерева выглядит примерно так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;...
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;amp;lt;a href=&amp;quot;http://disqus.com/?ref_noscript&amp;quot;&amp;amp;gt;comments powered by Disqus.&amp;amp;lt;/a&amp;amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&amp;quot;http://disqus.com&amp;quot; class=&amp;quot;dsq-brlink&amp;quot;&amp;gt;comments powered by &amp;lt;span class=&amp;quot;logo-disqus&amp;quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Узел &lt;code&gt;noscript&lt;/code&gt; довольно просто обнаружить и удалить. &lt;code&gt;$body&lt;/code&gt; ниже это отсылка к телу статьи, к свойству
&lt;code&gt;body&lt;/code&gt;, которое мы проинициализировали в самом начале используя XPath &lt;code&gt;//article&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Со ссылкой, следующей за узлом &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt; всё не так очевидно, здесь мне помогла функция &lt;code&gt;@debug&lt;/code&gt;, благодаря этой
функции вы можете понять находит ли XPath желаемый элемент или нет. Применение выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@debug: $body//noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Результат применения вы увидите в самом низу страницы редактора.
Здесь я могу применить расширенный XPath и сказать &amp;ldquo;Удали все узлы &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; перед которыми есть узел того же уровня &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Успех? Нет! Оказывается, из-за того, что сначала мы удалили &lt;em&gt;noscript&lt;/em&gt;, а затем опирались на него при поиске &lt;em&gt;a&lt;/em&gt;, то
интерпритатор в конце не нашел ни одного &lt;em&gt;a&lt;/em&gt; у которого предшественник &lt;em&gt;noscript&lt;/em&gt;. Понять это получилось опять же,
благодаря функции &lt;code&gt;@debug&lt;/code&gt;. В результате, поменяв местами вызовы функции &lt;code&gt;@remove&lt;/code&gt; мы последовательно удалили оба
не нужных элемента.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]   # Сначала удаляем ссылку следующую за noscript
@remove: $body//noscript                    # Затем удаляем сам noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Также функции могут явно или неявно работать со специальными переменными.&lt;/p&gt;

&lt;h3 id=&#34;специальные-переменные&#34;&gt;Специальные переменные&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#special-variables-and&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Когда мы работаем с функцией у которой справа записан xpath, то мы можем на следующей строке получитьрезультат этого
выражения не повторяя его. Этот результат хранится в переменной &lt;code&gt;$$&lt;/code&gt;, т.е. мы можем сделать, например, так&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: $header/h2
@debug: $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После чего внизу редактора увидим, какой же результат мы записали в description. Также каждая функция выполняет некую
трансформацию, обрабатывает входящие элементы и получает какой-то результат. Собственно, сам результат можно получить
из переменной &lt;code&gt;$@&lt;/code&gt;. Итак:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; - содержит результат самого последнего XPath выражения;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; - содержит значение возвращаемое последней запущенной функцией.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;description: $header/h2     # определяет описание страницы
@debug                      # выводит описание, по умолчанию вместо xpath подразумевается $$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;другие-функции&#34;&gt;Другие функции&lt;/h3&gt;

&lt;p&gt;В конце этого руководства я приведу описание каждой из доступных функций, но для специфик применения, предлагаю обратиться к оригинальной
документации по ссылкам. См. приложение А.&lt;/p&gt;

&lt;p&gt;Используя изученные в приложении А функции мы можем, для начала, улучшить последний процесс удаления хвостов от disqus.
Раньше мы удаляли хвосты так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]   # Сначала удаляем ссылку следующую за noscript
@remove: $body//noscript                    # Затем удаляем сам noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь мы воспользуемся функцией &lt;code&gt;@combine&lt;/code&gt;, которая склеивает заданные узлы в один &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt; узел. А затем удалим результат
склейки.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@combine: $body//noscript/next-sibling::a
@remove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Нам осталось разобраться, как правильно обозначить автора, дату публикации и ссылку на картинку для превью.&lt;/p&gt;

&lt;p&gt;Для получения картинки, воспользуемся функцией &lt;code&gt;@background_to_image&lt;/code&gt;, она преобразует стиль в элемент &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;.
Результат функции присвоим переменной &lt;code&gt;$main_image&lt;/code&gt;, значение атрибутта &lt;code&gt;src&lt;/code&gt; присвоим свойству &lt;code&gt;image_url&lt;/code&gt;, а саму картинку
добавим в начало статьи. Всё это делается следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@background_to_image: //header[has-class(&amp;quot;intro-header&amp;quot;)]   # нашли картинку
$main_image: $@                                             # сохранили узел в переменную

@prepend_to($body): $main_image                             # вставили в начало контента
image_url: $main_image/@src                                 # обозначили её как картинку для preview
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инструменты разработчика Chrome подсказывают, что оставшаяся интересующая нас информация находится в той же части
дерева элементов, что и заголовки для статей, по этому воспользуемся, уже определенным ранее &lt;code&gt;$header&lt;/code&gt;. Нам осталось
извлечь из дерева имя автора и дату публикации. Извлечение данных, я сделал следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$extra_meta: $header/span       # уточняем поддерево с метаданными

$author: ($extra_meta/a)[1]     # выбираем первую ссылку в списке
author: $author/text()          # извлекаем её название, в моем случае это автор

@match(&amp;quot;Дата публикации: ([0-9]{4}-[0-9]{2}-[0-9]{2})&amp;quot;, 1): $extra_meta # в поддереве с метаданными ищем дату по регулярному выражению и забираем первую группу
published_date: $@              # присваиваем результат поиска
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;встраиваемые-элементы&#34;&gt;Встраиваемые элементы&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#embedded-elements&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В вашем случае могут быть медиа элементы, которые вы так же хотели бы встроить. Сегодня телеграм поддерживает следующие
сервисы для встраивания в Instant View:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Youtube&lt;/li&gt;
&lt;li&gt;Vimeo&lt;/li&gt;
&lt;li&gt;Tweets &amp;amp; Twitter Videos&lt;/li&gt;
&lt;li&gt;Facebook Posts &amp;amp; Videos&lt;/li&gt;
&lt;li&gt;Instagram&lt;/li&gt;
&lt;li&gt;Giphy&lt;/li&gt;
&lt;li&gt;SoundCloud&lt;/li&gt;
&lt;li&gt;GithubGist&lt;/li&gt;
&lt;li&gt;Aparat&lt;/li&gt;
&lt;li&gt;VK.com Videos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;включения-системные-правила&#34;&gt;Включения (системные правила)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#include&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Включения - это системные правила и вам их нет необходимости использовать для собственных нужд, но знание того что
это пригодится для понимания работы Telegram Instant View.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ core.telegram.org # вставляет блок правил, который используется для core.telegram.org
?not_exists: $body  # если не найдет, то ...
+ telegram.org      # вставляет другой блок
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Я вижу один вариант использования. Это если ваш сайт на одном движке с кем-то, для кого уже есть готовые правила&lt;/p&gt;

&lt;h2 id=&#34;обработка-страниц&#34;&gt;Обработка страниц&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#processing-pages&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Все страницы обрабатываются по следующим правилам:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Url: http://example.com/some_page.html
+ example.com
?true
+ ..after
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если же страница находится на поддомене, то она обрабатывается так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Url: http://some.subdomain.example.com/some_page.html
+ some.subdomain.example.com
?not_exists: $body
+ subdomain.example.com
?not_exists: $body
+ example.com
?true
+ ..after
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Следовательно, сначала Instant View Bot ищет шаблон для полного домена и если он не находит проинициализированного свойства
&lt;em&gt;body&lt;/em&gt;, то понижает уровнь домена и ищет шаблон для него. Блок правил &lt;code&gt;..after&lt;/code&gt; выполняется для всех доменов.&lt;/p&gt;

&lt;h2 id=&#34;instant-view-для-поддоменов&#34;&gt;Instant View для поддоменов&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#working-with-subdomains&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Если страница обрабатывается для поддомена, то необходимо вручную выбрать уровень домена, который необходим в левом
верхнем углу редактора.&lt;/p&gt;

&lt;h2 id=&#34;публикация&#34;&gt;Публикация&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/#publishing-templates&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Для того, чтобы посмотреть результат нажмите на кнопку View In Telegram и если у вас есть десктопное приложение, то в нем
вам предложат отправить кому-нибудь ссылку, которая будет открывать ваш тестовый пример через Instant View.&lt;/p&gt;

&lt;p&gt;Публикация для всех пользователей Telegram происходит только после подтверждения вашего шаблона командой Telegram.
До этого момента вы можете распространять ссылки с истользованием шаблона, даже без подтверждения. Для этого вам нужно
составить ссылку в формате: &lt;code&gt;t.me/iv?url=...&amp;amp;rhash=...&lt;/code&gt;, где url это ссылка на публикацию, а &lt;code&gt;rhash&lt;/code&gt; - идентификатор
шаблона.&lt;/p&gt;

&lt;h2 id=&#34;бонус-instant-view-и-cloudflare&#34;&gt;Бонус. Instant View и Cloudflare&lt;/h2&gt;

&lt;p&gt;В своих прошлых статьях, я рассказывал о том, что в качестве DNS серверов для i-osipov.ru используются DNS сервера
Cloudflare. Кроме того, Cloudflare это прокси защищающий от DDOS и при реализации Instant View я заметил одну небольшую
особенность. Из коробки этот замечательный сервис предоставляет услугу, которая называется &amp;lsquo;Email protection&amp;rsquo;, по сути
в определенном наборе ситуаций, которые можно детектировать как &amp;ldquo;бот, который обходит интернет и собирает email&amp;rsquo;ы для
спама&amp;rdquo;, Cloudflare заменят все email&amp;rsquo;ы обсусцирует email&amp;rsquo;ы на странице. Instant View Bot такой же подозрительный тип,
но всё ради безопасности. Тем ни менее, в статье про то &amp;ldquo;как написать бота для телеграма&amp;rdquo; есть полная форма команды
оправляемая телеграм боту, напомню что выглядит она вот так: &lt;code&gt;/command@BotName&lt;/code&gt;. Проблема в том, что cloudflare распознает
как email всё что справа от слеша и отдает неправильную страничку боту. Как это исправить? Все подробности есть
&lt;a href=&#34;https://support.cloudflare.com/hc/en-us/articles/200170016-What-is-Email-Address-Obfuscation-&#34;&gt;здесь&lt;/a&gt;, если коротко,
то вы должны встроить в код страницы тег &lt;code&gt;&amp;lt;!--email_off--&amp;gt; здесь cloudflare не будет защищать email&#39;ы &amp;lt;!--/email_off--&amp;gt;&lt;/code&gt;.
Да, вы правильно поняли, для того, чтобы показать вам команду для бота и в этой статье, мне пришлось снова встроить
комментарии отключающие cloudflare email protection.&lt;/p&gt;

&lt;h2 id=&#34;шаблон-для-i-osipov-ru&#34;&gt;Шаблон для i-osipov.ru&lt;/h2&gt;

&lt;p&gt;В итоге, мы получили следующий шаблон:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
!domain: i-osipov\.ru
!path: /post/.+

body: //article

$header: //div[has-class(&amp;quot;post-heading&amp;quot;)]
title: $header/h1
description: $header/h2

channel: &amp;quot;@from_junior_to_senior&amp;quot;

$extra_meta: $header/span

$author: ($extra_meta/a)[1]
author: $author/text()

author_url: &amp;quot;https://i-osipov.ru&amp;quot;

@match(&amp;quot;Дата публикации: ([0-9]{4}-[0-9]{2}-[0-9]{2})&amp;quot;, 1): $extra_meta
published_date: $@

@background_to_image: //header[has-class(&amp;quot;intro-header&amp;quot;)]
$main_image: $@

@prepend_to($body): $main_image
image_url: $main_image/@src

@combine: $body//noscript/next-sibling::a
@remove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На самом деле в шаблон входит еще и обнотка неподдерживаемых таблиц, вместо них можно отображать ссылку на сайт с
полным контентом. Как это сделать вы можете подглядеть в публичком шаблоне для i-osipov.ru или поразмышлять самостоятельно.&lt;/p&gt;

&lt;h2 id=&#34;заключение&#34;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Telegram Instant View это мощный инструмент, который поможет вам интегрировать ваш контент в инфраструктуру Telegram.
Относиться к Instant View можно по разному, но на мой взгляд, если вы можете сделать жизнь вашего читателя еще лучше -
сделайте это. Со своей стороны, я надеюсь, что этот документ поможет вам легко разобраться в создании Instant View и
улучшить UX ваших статей. Для достижения совершенства обратите внимание на
&lt;a href=&#34;https://instantview.telegram.org/checklist&#34;&gt;Чеклист Идеального Instant View&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;приложение-а&#34;&gt;Приложение А&lt;/h1&gt;

&lt;p&gt;Функции для детальной настройки форматирования&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#debug&#34;&gt;@debug&lt;/a&gt; отладка команд, вывод результов в нижней части редактора;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#append&#34;&gt;@append&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;в начало&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#prepend&#34;&gt;@prepend&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;в конец&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#after&#34;&gt;@after&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;после&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#before&#34;&gt;@before&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;перед&lt;/strong&gt; каждым найденным по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#append-to&#34;&gt;@append_to&lt;/a&gt; вставляет целевой узел в конец базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#prepend-to&#34;&gt;@prepend_to&lt;/a&gt; вставляет целевой узел в начало базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#after-el&#34;&gt;@after_el&lt;/a&gt;  вставляет целевой узел после базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#before-el&#34;&gt;@before_el&lt;/a&gt; вставляет целевой узел перед базовым;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#replace-tag&#34;&gt;@replace_tag&lt;/a&gt; изменяет имя тега;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#wrap&#34;&gt;@wrap&lt;/a&gt; заворачивает целевой элемент в заданный тег;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#clone&#34;&gt;@clone&lt;/a&gt; создает копию целевого узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#detach&#34;&gt;@detach&lt;/a&gt; отделяет целевой узел от оставшейся части, создает копию родительского узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#pre&#34;&gt;@pre&lt;/a&gt; помечает текст внутри целевого узла как отформатированный;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#set-attr&#34;&gt;@set_attr&lt;/a&gt; устанавливает аттрибут в каждом соответствующем узле;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#set-attrs&#34;&gt;@set_attrs&lt;/a&gt; устанавливает несколько аттрибутов;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#match&#34;&gt;@match&lt;/a&gt; выполняет поиск на основе регулярного выражения, в результате, заменяет содержимое целевого узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#replace&#34;&gt;@replace&lt;/a&gt; выполняет замену на основе регулярного выражения;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#urlencode&#34;&gt;@urlencode&lt;/a&gt; кодирует url в соответствии с RFC 3986;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#urldecode&#34;&gt;@urldecode&lt;/a&gt; декодирует url в соответствии с RFC 3986;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#htmlencode&#34;&gt;@htmlencode&lt;/a&gt; кодирует специальные символы в целевом узле в HTML сущности;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#htmldecode&#34;&gt;@htmldecode&lt;/a&gt; декодирует специальные символы в целевом узле в HTML сущности;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#background-to-image&#34;&gt;@background_to_image&lt;/a&gt; трансформирует целевой узел в &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; тэг с &lt;code&gt;src&lt;/code&gt; атрибуттом;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#json-to-xml&#34;&gt;@json_to_xml&lt;/a&gt; трансформирует json контент целевого узла в xml;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#html-to-dom&#34;&gt;@html_to_dom&lt;/a&gt; парсит html узел и вставляет его в документ (в документации есть очевидный пример);&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#combine&#34;&gt;@combine&lt;/a&gt; склеивает каждый следующий с предыдущим узлом, если такой существет;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#datetime&#34;&gt;@datetime&lt;/a&gt; трансформирует дату и время из строки в unix time;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#simplify&#34;&gt;@simplify&lt;/a&gt; системная функция для понимания того, как работает преобразование в Instant View;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#inline&#34;&gt;@inline&lt;/a&gt; встраивает iframe;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#unsupported&#34;&gt;@unsupported&lt;/a&gt; определяет, какие элементы не поддерживаются, для того чтобы не давать пользователю Instant View с неполным контентом.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;
</description>
    </item>
    
    <item>
      <title>Telegram API. Как написать бота?</title>
      <link>https://i-osipov.ru/post/how_to_create_telegram_bot/</link>
      <pubDate>Sun, 23 Jul 2017 23:10:24 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/how_to_create_telegram_bot/</guid>
      <description>&lt;p&gt;Всем привет!&lt;/p&gt;

&lt;p&gt;Сегодня мы побеседуем о том как делаются Telegram боты.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кто ты по жизни?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Telegram боты бывают двух видов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Боты основанные на Webhoock&lt;/li&gt;
&lt;li&gt;Боты основанные на Long Polling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый вариант бота требует от вас поднять сервер и установить &amp;ldquo;вебхуки&amp;rdquo; для асинхронного оповещения вас о новых изменениях. На вашем сервере должен быть соответствующий роутинг.&lt;/p&gt;

&lt;p&gt;Второй вариант бота - это имитация асинхронности. Ваш бот с определенным периодом будет запрашивать последние изменения с сервера телеграм на основании механизма long polling. Т.е. бот делает запрос и подвисает, а отвисает либо по таймауту, либо по получению новыйх обновлений. Об этом виде ботов сегодня и пойдет речь.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long polling в разрезе работы с сетью&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Когда вы работаете с Telegram Api вы нагружаете сервера Telegram. Все запросы вы отправляете по одному URL, но в один момент времени может работать только один обработчик для Telegram бота.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Интересно, что в API предусмотрена умная обработка ошибок, среди прочего, в ответе телеграм сервера, который вы за DDOS&amp;rsquo;или, может сообщить вам сколько нужно подождать, чтобы вы могли взаимодействовать с Telegram снова&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Как сказано выше у вас фактически однопоточная обработка запросов к телеграм. По этому, кажется, здравым принять одну из следующих реализаций ботов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;реализовать поток, который будет отправлять запросы и складировать ответы в общую очередь из которой потоки-обработчики будут их разбирать;&lt;/li&gt;
&lt;li&gt;поставить прокси-сервер, который будет затягивать последние изменения и шарить их между нодами (другими серверами) бота. В этом случае можно подменяя прокси-сервер менять реализации взаимодействия с telegram api не меняя реализацию для нод. Это решение мне нравится несколько больше, его масштабируемость зависит от потребностей в функциональности бота, т.к. если можно обрабатывать параллельно несколько чатов независимо друг от друга, то масштабируемость на пределе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оставим использование прокси-сервера для будущих статей, а пока давайте рассмотрим как вы можете реализовать своего бота.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Красная или синяя таблетка?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;На сколько вы любите писать велосипеды? В зависимости от этого у вас есть 2 пути реализации Telegram бота:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;писать всё самому с нуля;&lt;/li&gt;
&lt;li&gt;воспользоваться существующей библиотекой.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если вы используете динамически типизируемые языки, которые поддерживают нативную работу с JSON, то первый вариант, не так уж и плох, однако, уже существует большое количество библиотек для разработки ботов их публичный перечень вы можете увидеть &lt;a href=&#34;https://core.telegram.org/bots/samples&#34;&gt;здесь&lt;/a&gt;. Вы найдете много вариантов для PHP, Java, Python, Node.js и так далее. Я сейчас реализую собственную библиотеку на языке Kotlin - &lt;a href=&#34;https://clabo.i-osipov.ru/&#34;&gt;Clabo&lt;/a&gt;. Эта библиотека поможет вам на основании расширяемого DSL описать работу своего бота, например, всё что надо для запуска бота, который говорит &amp;ldquo;Привет!&amp;rdquo; по команде /start это небольшой кусочек кода по &lt;a href=&#34;https://gist.github.com/ivan-osipov/266204f3560a6c5e64d381df5c73bf22&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BotFather&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В телеграме есть специальный бот, который позволяет создавать других ботов и настраивать их. Некоторые действия вы, как пользователь, не можете сделать из интерфейса, например, сменить имя бота или задать набор команд, для этого нужен &lt;a href=&#34;http://t.me/botfather&#34;&gt;BotFather&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Теперь у вас есть представление, как реализовать бота, но что с ним можно сделать? Об этом я расскажу ниже.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;И зачем всё это?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Боты очень способные, они обладают следующими возможностями:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;ul&gt;
&lt;li&gt;Встраиваемый мод (Inline mode). Вы можете встроить бота прямо в строку с вводом, хорошие примеры таких ботов это GifBot и YouTubeBot. Вы вписываете имя бота, например, @youtube и он предлагает вам результаты поиска видео или вы можете авторизоваться и результаты будут специфичны для вас.&lt;/li&gt;
&lt;li&gt;Клавиатуры. Есть два вида клавиатур: &amp;ldquo;Клавиатура для быстрого ответа&amp;rdquo; и &amp;ldquo;Встроенная клавиатура&amp;rdquo;. Первый вариант позволяет пользователю не писать сообщение, а просто отправить его выбрав один из вариантов. Встроенная клавиатура размещается прямо под сообщением и ассоциирована именно с ним.&lt;/li&gt;
&lt;li&gt;Команды. Всё что вы пишете после &amp;ldquo;/&amp;rdquo; в телеграм называется командами, чтобы избежать коллизий, когда два бота в одном чате имеют одну и ту же команду используется следующий формат &lt;code&gt;/command@BotName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Бот может отправлять отформатированные с помощью html или markdown сообщения.&lt;/li&gt;
&lt;li&gt;Бот может запросить местоположение или номер телефона.&lt;/li&gt;
&lt;li&gt;Ботов можно добавлять в группы и, например, администрировать их.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;&lt;strong&gt;Что в итоге?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Мы обзорно рассмотрели основы того как можно сделать ботов, для чего это и что они могут делать. Применение ботов ограничивается только вашей фантазией.
Вы создаете бота и запускаете сопровождающий код, который обрабатывает сообщения. Ничего сложного. Увидимся в следующих статьях!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Программист? Сделай блог</title>
      <link>https://i-osipov.ru/post/do_the_blog/</link>
      <pubDate>Thu, 20 Jul 2017 00:19:26 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/do_the_blog/</guid>
      <description>&lt;p&gt;&lt;em&gt;Время чтения: 20 минут&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Всем привет!&lt;br /&gt;
Как и обещал, переношу свой пост из телеграм канала &lt;strong&gt;Джун уронил прод&lt;/strong&gt; &lt;a href=&#34;https://t.me/djuup&#34;&gt;@djuup&lt;/a&gt;.&lt;br /&gt;
Статья &lt;strong&gt;Программист? Сделай блог&lt;/strong&gt; выходила на канале в двух частях, здесь вы можете прочитать обе в одном целостном посте.
Приятного чтения!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;О чем этот пост&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Наполнение этого поста расскажет, как быстро и просто запустить собственный блог аналогичный этому, а если вы программист и шарите, то сделать это абсолютно бесплатно и красиво. Стоимость сделать такой блог колышется от 0 до 99 рублей в год и всё зависит от того захотите ли вы свой красивый домен. Я захотел.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Читайте дальше, если вы понимаете зачем вам блог и уже горите идеями, так ярко, что даже у черных дыр не хватило бы массы утянуть за собой столько света.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Здесь вы не найдете филосовствований о целевой аудитории и интересном контенте, а только техническая сторона, по делу, что и как сделать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Поехали&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Что такое блог в глазах программиста? Это какая-то информация в виде постов, которую нужно выбрасывать по первому требованию, так давайте выбрасывать его с энтузиазмом. Конечно, вы можете взять WordPress и в красивом интерфейсе накидать всё что хотите. Управлять контентом из админки и так далее, но готовы ли вы отдавать за возможность подключить кастомный домен по $3 в месяц, да еще и оплата ежегодная, т.е. вы сразу выкините $ 36 (2160 руб. при курсе 60 руб за $1). Это путь моей жены, но не мой.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/do_the_blog/gagarin.jpg&#34; alt=&#34;Gagarin&#34; title=&#34;Gagarin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;К чёрту динамику&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Я убежден, что всё что нужно для суперского блога это html + css и немножко js. Какие PHP? Какая БД? Что за чушь! Момент, когда вы публикуете новый пост вполне детерминирован и на самом деле, всё что вам нужно, это сохранить страничку с вашим годным контентом, а затем отдать её при запросе определенного URL&amp;rsquo;a. Как это сделать? На помощь приходят генераторы статических страниц, такие как Hugo или Jekyll. В этом посте остановимся на hugo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/do_the_blog/hugo.png&#34; alt=&#34;Hugo&#34; title=&#34;Hugo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;Где этот мерзавец?&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Для начала ставим себе Git, например, &lt;a href=&#34;https://git-scm.com/&#34;&gt;отсюда&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;Хочу блог. Красивый чтоб&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Примерно так и работает hugo. Наша цель на этом этапе сгенерировать себе блог для этого, по шагам:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;Качаем Hugo&lt;/a&gt; в любую удобную директорию&lt;/li&gt;
&lt;li&gt;Добавляем к Path в переменных окружения bin папку в этой директории, например, C://hugo/bin. Теперь мы можем генерить где угодно и что угодно&lt;/li&gt;
&lt;li&gt;Открываем cmd или bash (что сподручнее) переходим в директорию, где появится папка с блогом. Находясь в этой директории прописываем:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;hugo new site your-blog-name
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Готово, блог сгенерён, но вы же хотите, чтобы красиво? По этому, переходим в папку с блогом, выбираем тему &lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;здесь&lt;/a&gt; (пожалуй, самый сложный этап - это выбрать тему) и действуем в соответствии с указаниями в теме. Скорее всего они будут следующими: перейдите в папку themes и склонируйте туда гит репозиторий темы, возьмем, например, эту &lt;a href=&#34;https://github.com/beli3ver/hemingway2&#34;&gt;тему&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Склонировали? Возвращаемся в папку с блогом и открываем текстовым редактором файл &lt;strong&gt;config.toml&lt;/strong&gt;. В нём устанавливаем тему, например, так&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;theme = &amp;quot;hemingway2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Почти готово. Пишем в cmd/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;hugo
hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Изи катка. Открываем &lt;em&gt;&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt;&lt;/em&gt; вот и наш блог.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Блог без постов как Нева без мостов&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Чтобы докинуть постов не обязательно выключать сервер. Просто открываете еще одну консоль/терминал и пишете&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new post/my-new-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Каждый пост - это Markdown файлик с дополнительными метаднными, этот файлик вы найдете в &lt;strong&gt;content/post&lt;/strong&gt;. Чтобы опубликовать пост нужно указать в метаданных внутри файла: &lt;strong&gt;draft = false&lt;/strong&gt;. Метаданные отделяются плюсами.&lt;/p&gt;

&lt;p&gt;Каждый новый пост - это новый файлик, благодаря которому обновляется статический контент.&lt;/p&gt;

&lt;p&gt;Нужно понимать, что предварительно сгенерированная статика это довольно быстро и абсолютно безопасно, т.к. у вас нет админки, которую можно взломать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;НА ПРОД!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Всё бы хорошо, только что с этим всем делать?&lt;/p&gt;

&lt;p&gt;После выполнения пустой команды &lt;strong&gt;hugo&lt;/strong&gt; каждый раз перегенерируется папка &lt;strong&gt;public&lt;/strong&gt;. Она-то нам и нужна. В этой папке лежит готовая статика блога. Но нужно куда-то это опубликовать. Здесь на помощь приходят github pages. Регистрируемся на github.com и создаем репозиторий, например, &lt;strong&gt;blog&lt;/strong&gt;. При создании репозитория github напишет как правильно отправить туда код. Что же нужно сделать в нашем случае? Перейти в папку &lt;strong&gt;public&lt;/strong&gt; и выполнить в ней:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git add *
git commit -m &#39;init&#39;
git remote add origin https://github.com/&amp;lt;user-login&amp;gt;/&amp;lt;repo-name&amp;gt;.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Не забудьте поправить URL&amp;rsquo;ы. При любых изменениях в блоге вам нужно будет перекоммитить статику в гитхаб. Теперь открываем настройки репозитория (Settings) и смотрим что там есть. Находим раздел GitHub Pages. Указываем, что статика будет браться из master ветки и сохраняем.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Вот и всё&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GitHub на месте скажет ваш URL, это будет что-то вроде &lt;a href=&#34;https://ivan-osipov.github.com/blog&#34;&gt;https://ivan-osipov.github.com/blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Как свистульки прикрутить?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hugo - довольно гибкий инструмент и с его помощью можно провернуть много чего интересного не рассмотренного в этой статье. Ответы на большинство вопросов дает &lt;a href=&#34;https://gohugo.io/getting-started/&#34;&gt;документация Hugo&lt;/a&gt;. Отнеситесь внимательно и к документации темы, она поможет вам лучшим способом сконфигурировать и настроить ваш блог.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Прикрепление пользовательского домена&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Чтобы получить домен его придется купить. Наиболее дешевый вариант, который я нашел, это &lt;a href=&#34;https://2domains.ru&#34;&gt;https://2domains.ru&lt;/a&gt;. Там я приобрел домен i-osipov.ru на год всего за 99 рублей, сейчас, как я вижу, стоимость доменов в зоне ru у этого провайдера  149 рублей, при желании вы можете поискать что-то по-дешевле.&lt;/p&gt;

&lt;p&gt;Итак, домен в кармане и что же теперь с ним делать?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cloudflare.com&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Зачем нам этот сайт? Всё просто, фактически это своего рода панель управления прокси к нашему блогу. Настроить там можно многое множество вещей, но об этом в отдельной статье. Выполним следующую последовательность действий:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;регистрируемся на cloudflare.com;&lt;/li&gt;
&lt;li&gt;справа сверху нажмите на кнопку &amp;ldquo;+Add Site&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;в форму вписываем ваш домен и нажимаем Begin Scan. Недолго ждем, тем временем cloudflare загружает всю доступную информацию по нашему домену;
нажимаем Continue;&lt;/li&gt;
&lt;li&gt;cloudflare спросит нас о плане, который мы хотим использовать и здесь можно выбрать Free Website;&lt;/li&gt;
&lt;li&gt;следующим шагом от нас потребуется поменять DNS сервера для ранее купленного домена. Например, для сайта &lt;strong&gt;yandex.com&lt;/strong&gt; cloudflare требует сделать следующие изменения:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/do_the_blog/dns.png&#34; alt=&#34;DNS&#34; title=&#34;DNS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Изменение DNS серверов на 2domain.ru&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Чтобы изменить DNS сервера необходимо зайти в личный кабинет. В меню &lt;strong&gt;Домены -&amp;gt; Мои домены&lt;/strong&gt; выбрать указанный на cloudflate домен. Открыть раздел &amp;ldquo;Управление ДНС-серверами/Делегирование&amp;rdquo; и тут нужно сменить используемые dns сервера для домена. Давайте заменим записи &lt;em&gt;ДНС 1&lt;/em&gt; и &lt;em&gt;ДНС 2&lt;/em&gt; на &lt;strong&gt;elliot.ns.cloudflare.com&lt;/strong&gt; и &lt;strong&gt;jasmine.ns.cloudflare.com&lt;/strong&gt; соответственно. Выглядит это примерно так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/do_the_blog/dns_update.png&#34; alt=&#34;DNS_UPDATE&#34; title=&#34;DNS Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Для понимания, теперь IP будет определяться благодаря этим DNS серверам. DNS сервера принадлежат Coudflare.com.&lt;/p&gt;

&lt;p&gt;Ваш сайт или блог будет активирован в течении 24 часов, также в течении этого времени будет создан сертификат для подержки https. Но пока нам нужно хотя бы связать домен с GitHub Pages. Давайте это сделаем.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Прикрепляем к GitHub Pages свой домен&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сделать это очень просто заходим в репозиторий где лежит статика, открываем Settings. В разделе GitHub Pages под Custom Domain вписываем свой домен и жмем Save. Отлично! Страничку с GitHub можно на сегодня закрыть.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Прописываем матчинг записей DNS на сервера GitHub&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Пример записей, которые вам нужно сделать в CloudFlare ниже. Естественно, каждое использование &lt;em&gt;i-osipov.ru&lt;/em&gt; следует заменить на свой домен.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/do_the_blog/domain.png&#34; alt=&#34;DOMAIN&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как вы видите в двух верхних строках указывается 2 разных IP адреса. Это специальные адреса GitHub, при желании вы можете проверить их &lt;a href=&#34;https://help.github.com/articles/setting-up-an-apex-domain/&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;DNS изменения обновляются около суток, в моем случае несколько часов.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Что мы имеем на этом этапе?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;При входе на &lt;a href=&#34;http://your-domain.com&#34;&gt;http://your-domain.com&lt;/a&gt; ваша статика созданная ранее отдается поситителю. Первая и самая трудная часть плана выполнена. Теперь давайте настроим https. Https основывается на сертификатах, сертификаты бывают разных видов, но нас - любителей бесплатных сертификатов это не должно интересовать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTPS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Если кратко, то https для блога вам нужен только для красоты.&lt;/p&gt;

&lt;p&gt;Что такое HTTPS? Это расширенная версия протокола HTTP, которая шифрует транспортируемые данные между клиентом и сервером (в нашем случае) и если в вашем блоге есть форма обратной связи или любые другие данные пользователя, то сделать https имеет смысл.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Какой профит для блога?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Психология. Так исторически сложилось, что зеленый цвет - цвет доверия и когда пользователь заходит на ваш сайт/блог и видит зеленый замочек, то кредит доверия к вашему ресурсу увеличивается, хотя программистов обычно так не на дурить.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SSL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вернемся к cloudflare. Перейдем в раздел crypto и первой строчкой мы увидим SSL, здесь нужно поставить значение FULL и пояснить: как вы видите, есть 4 возможных варианта: off, flexible, full и full(strict).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;off - ни один пользователь не увидит ваш сайт через https.&lt;/li&gt;
&lt;li&gt;flexible SSL - на вашем сервере нет https, даже с сертификатом, который не подходит для вашего сайта. CloudFlare будет делать https соединение с пользователями, но обмениваться информацией с вашим сервером по http.&lt;/li&gt;
&lt;li&gt;full SSL - ваш сервер поддерживает https (GitHub поддерживает), но установленый сертификат  не соответствует вашему домену (так и есть, ведь сертификат выдан на *.github.com). В этом случае CloudFlare не будет проверять соответствие домена сертификату.&lt;/li&gt;
&lt;li&gt;full SSL (strict) - ваш сервер имеет корректный сертификат (не истекший и подписанный Cloudflare Origin CA или доверенным CA).
Напомню, что наш вариант - full SSL. Обновление сертификата может занять около 24 часов.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Дополнительно в этом меню можно включить постоянное перенаправление http на https.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кешируй, что можешь, пока молодой&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Финальный шаг нашего создания хорошего блога программиста - настроить кеш. Скорее всего, настройки по умолчанию вас удовлетворят, но возможно что-то захочется поменять. Перейдем к разделу Caching. Первое, что вы увидите в этом разделе - это возможность очистить кеш. И в случае с блогом, если посты не частые, то чистку можно делать сразу после поста. На этом экране могут пригодиться как настройки кеширования, так и, например, Development Mode, который позволяет прокидывать изменения в режиме реального времени.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Похоже на финал&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Если вы читаете эти строки, значит вы очень любите читать, либо вы прошли большой, но интересный путь создания и запуска собственного блога. Эту статью я писал, опираясь на собственный опыт при создании &lt;a href=&#34;https://i-osipov.ru&#34;&gt;https://i-osipov.ru&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Статья перенесена из telegram канала &lt;strong&gt;Джун уронил прод&lt;/strong&gt; &lt;a href=&#34;https://t.me/djuup&#34;&gt;@djuup&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Все в телеграм! Джун уронил прод!</title>
      <link>https://i-osipov.ru/post/telegram_here/</link>
      <pubDate>Wed, 19 Jul 2017 00:21:33 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/telegram_here/</guid>
      <description>&lt;p&gt;Привет, друзья!&lt;/p&gt;

&lt;p&gt;Так случилось, что появилась новая площадка для статей и постов в телеграм.
Она называется &lt;strong&gt;Джун уронил прод&lt;/strong&gt; &lt;a href=&#34;https://t.me/djuup&#34;&gt;@djuup&lt;/a&gt; :D Ссылка вот &lt;a href=&#34;https://t.me/djuup&#34;&gt;здесь&lt;/a&gt;. Если вам нравится меня читать,
то добро пожаловать. Я там обитаю постоянно! Недавно писал про свое участие в Russian AI Cup - сражение
искусственного интеллекта, а сейчас начал цикл статей про Kotlin (это новый язык программирования).
Буду рад видеть вас там!&lt;/p&gt;

&lt;p&gt;В будущем, я планирую переносить некоторые статьи в целостном виде сюда, но это будет с задержкой, а
самое свежее только там :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Хочешь заработать? Быстро? Дай сюда - не балуйся. Часть 1</title>
      <link>https://i-osipov.ru/post/investments/</link>
      <pubDate>Thu, 15 Jun 2017 19:10:40 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/investments/</guid>
      <description>

&lt;div class=&#34;text-justify&#34;&gt;
Дождливый вечер четверга, я сижу на диване и пишу свою новую задумку для разработки телеграм-ботов clabo. День отличился 
защитой магистерской работы, а впереди много свободного времени, что значит - самое время написать пост. Пост посвящен 
управлению личными финансами и увеличению их количества.&lt;/div&gt;  

&lt;div class=&#34;text-justify&#34;&gt;
Для чего человеку деньги? Ежедневно большинство людей тратит бодрую половину дня на их добычу, некоторые продолжают и 
спустя 8 рабочих часов. Кто-то приходит домой, по пути заскочив в магазин, затем, на выходных тратит еще немножко и вот, 
месяц спустя, на кануне дня зарплаты, эти люди обнаруживают, что всё в порядке и денег хватило точно на месяц.
При этом ежемесячные необременительные платы за кредит кажутся нормальными.
Очень много таких примеров и, на мой взгляд, вина этому российское общедоступное финансовое образование (которого нет).
&lt;/div&gt;  

&lt;h2 id=&#34;10-90&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;90&lt;/sub&gt;&lt;/h2&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Возможно кто-то слышал про правило 10/90, оно применяется во множестве сфер, но здесь и сейчас оно как нельзя кстати. 
В управлении личными финансами это правило гласит:  
&lt;i&gt;&#34;Независимо от зарплаты, любой человек может отложить 10% своего дохода, не навредив себе&#34;&lt;/i&gt;  
Однако, к сожалению, его используют не так часто, хотя это довольно просто, получив з/п, отложить десятую часть. Просто 
посчитайте 10% от средней з/п в 30 тыс. это 3 тыс. рублей, а теперь умножте их на 12 месяцев и вот у вас скопленные 36 
тыс в год, можно сказать, 13я зарплата. Соответственно, там где зарплаты больше и накопления больше. Удивительно, но 10% 
это не лимит и при желании эта цифра вполне растет до 50%, однако для этого нужна хорошая мотивация.
&lt;/div&gt;  

&lt;h2 id=&#34;мотивация&#34;&gt;Мотивация&lt;/h2&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Что я хочу? Какая цель накоплений? Это самые важные вопросы, которые вы можете себе задать на первом этапе. Новая машина? 
Квартира побольше? Или путешествие по миру? Про что вы можете сказать &#34;я хочу!&#34;? Выберите одну цель и запишите её на лист 
бумаги. Лучше всего распечатать цветное изображение того, что вы действительно хотите. Поверьте, если вы будете видеть 
вашу цель хотябы пару раз в день, то накопления будут не трудом, а счастьем. Каждый раз, заходя в Starbucks или куда ещё 
похиповее, перед вашими глазами будет всплывать изображение цели, а желание выкинуть на кофе пару сотен исчезнет.  
Мы разобрались с тем, что любой человек способен откладывать какую-то сумму, но что если у него нет целей типа квартир и 
машин? Что же, я бы советовал добавить к этому списку финансовую независимость. Обсудим это ниже.
&lt;/div&gt;  

&lt;h2 id=&#34;финансовая-независимость&#34;&gt;Финансовая независимость&lt;/h2&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Что такое эта мифическая финансовая независимость и почему так мало людей её достигают?  
Я не являюсь экспертом в области финансов, но у меня есть своё определение. Для меня финансовая независимость это 
возможность, не прикладывая значительных усилий, иметь всё необходимое и даже больше. Для меня финансово независимый 
человек ходит на работу не от потребности в деньгах, а от исключительно от любви к своему делу. Реально ли это? Я 
убежден, что это может сделать каждый, поэтому, говоря о себе - я иду к этой цели. В книге Роберта Кийосаки &#34;Квадрант 
денежного потока&#34; автор предлагает очень простую концепцию. Разделим квадрат на 4 части и обозначим каждую своей буквой. 
Р - рабочий, П - предприниматель, Б - бизнесмен и И - инвестор. Пример ниже.
&lt;/div&gt;  

&lt;p&gt;&lt;img src=&#34;../../img/posts/investments/quadrant.jpg&#34; alt=&#34;Квадрант&#34; title=&#34;Квадрант&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Так или иначе вы относитесь как минимум к одному из квадратов и мне нравится концепция того, что для уверенного стояния 
&#34;на двух ногах&#34; необходимо занять второй квадрат и тогда вам не страшны никакие колебания рынка. Сейчас я отношусь к 
квадрату Р, т.е. я ежедневно хожу на работу и это мой основной доход, к счастью, моя работа мне действительно нравится, 
но сейчас не об этом. Для того чтобы двигаться к финансовой независимости стоит освоить еще один квадрат. 
Выбирая между частями квадранта я остановился на квадрате И - инвестор.
&lt;/div&gt;  

&lt;h2 id=&#34;и-инвестор&#34;&gt;И - Инвестор&lt;/h2&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Довольно громкое слово Инвестор скрывает в себе то, что человек, даже с минимальными вложениями куда-либо с целью 
получения прибыли, тоже является инвестором. Вспомним про откладываемые 10% в месяц, а почему бы не взять эти деньги 
и не попытаться умножить? Способы бывают разные, их можно ранжировать по уровню риска или по порогу вхождения, 
но в общем их много: вклад в банк, покупка акций/облигаций и прочих производных интструментов на бирже, покупка 
валюты в надежде на рост, покупка или организация бизнеса, покупка различных пифов и ETF&#39;ов и так далее. 
Тот человек, который вам скажет &#34;не рискуй! зачем тебе это?&#34; будет прав, однако эта правда субъективна. 
Одно из самых важных правил: не инвестируйте деньги, которые вам нужны или пригодятся в ближайшее время. 
В тот момент, когда вы продадите условные акции по низкой цене, потому что срочно нужны деньги, вы пожалеете, 
что связались с инвестированием. На данном этапе моей жизни мой опыт инвестирования сводится к бирже акций и облигаций. 
Об этом я расскажу ниже.
&lt;/div&gt;  

&lt;h2 id=&#34;биржа&#34;&gt;Биржа&lt;/h2&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Что такое биржа и как она работает можно узнать на бесплатных курсах &lt;a href=&#34;https://investments101.ru&#34; target=&#34;_blank&#34;&gt;вот здесь&lt;/a&gt;, я сделал 
именно так. Знания рассеивают многие сомнения и предубеждения. Если кратко, то 
биржа - это место где есть товары, есть продавцы, а есть покупатели. Одним словом - рынок. Акции и облигации - это 
товары, а вы можете выступать как продавцом, так и покупателем. Когда вы принимаете решение инвестировать в какую-то 
компанию то первая задача - это открыть брокерский счет, вторая - закинуть деньги, третья - купить акции.
Как я говорил ранее мой опыт сводится к торговле акциями, в основном IT компаний. 
Почему IT? Я понимаю этот сектор и я в нем постоянно кручусь, для меня не составляет труда 
отслеживать новости, т.к. они постоянно на слуху. В тот момент, когда я решил этим заняться для 
меня простым и понятным решением была система Tinkoff Инвестиции. Спустя время я понял, что 
пришла пора оглянуться вокруг, по этому для начала я посмотрел на брокера через которого работает сервис Тинькова. 
Им оказался BCS (БКС).
&lt;/div&gt;  

&lt;p&gt;&lt;img src=&#34;../../img/posts/investments/bcs.jpg&#34; alt=&#34;БКС&#34; title=&#34;БКС&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;text-justify&#34;&gt;
Сразу скажу, что это никакая не реклама и в ходе работы с БКС я открыл для себя несколько неприятных моментов о которых напишу 
ниже. Я выбирал между разными брокерами и когда вы приступите к выбору и примете решение, то обратитесь на сайт биржи, 
проверьте в &lt;a href=&#34;http://www.moex.com/ru/members.aspx?tid=668&amp;sby=5&#34; target=&#34;_blank&#34;&gt;списке участников торгов&lt;/a&gt; своего брокера. 
Когда я выбирал себе брокера, то конечно верить рейтингам после просмотра фильма 
&lt;a href=&#34;https://www.kinopoisk.ru/film/501333&#34; target=&#34;_blank&#34;&gt;&#34;Игра на понижение&#34;&lt;/a&gt; совем не хотелось и 
я обратился к гуглу в поисках чужих мнений о компаниях. Оказалось, что у многих есть большое кличество недовольных 
клиентов и многие из них были недовольны услугами &#34;финансовых экспертов&#34;. Я очень люблю такие 
моменты, когда люди фактически неявно отдают свои деньги другому человеку, полностью доверяя его 
мнению, а потом жалуются что что-то пошло не так. Если вы хотите отдать свои деньги, чтобы их 
умножили - идите в банк, это будет оптимально. Однако, если вы остались читать дальше, а не заняли 
очередь по талончику на открытие вклада, то хочу вас предупредить, что за любое решение принятое 
на бирже несете ответственность &lt;b&gt;только вы&lt;/b&gt; и если вам дают советы, то поступать или нет в 
соответствии с ними - это &lt;b&gt;ваше решение&lt;/b&gt;.
&lt;/div&gt;  

&lt;p&gt;&lt;img src=&#34;../../img/posts/investments/gopro.jpg&#34; alt=&#34;GoPro&#34; title=&#34;GoPro&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;text-justify&#34;&gt;
На днях я открыл один финансовый журнал, его прошлогодний (2016 год) 
выпуск, и это было почти как посмотреть стендап Эдди Мёрфи. В этом журнале были прогнозы по 
некоторым компаниям (например, GoPro) и глядя на текущее (2017 год) состояние дел нельзя не улыбнуться, во многих 
случаях &#34;финансовые эксперты&#34; не просто не угадали, а указали на полностью обратное направление, 
таким образом те, кто, прочитав этот журнал в далеком 2016 году, поверили экспертам в потенциальный рост 100% для gopro
 - очень сильно проиграли. Но вернемся к брокерскому счету, я изучал какие возможности предоставляют BCS и открыл для
себя индивидуальный инвестиционный счет (ИИС). ИИС - это особый вид брокерского счета, он позволяет вернуть 13% от 
отправленых на биржу денег (до 400 тыс. руб) в качестве налогового вычета (всё получится, если вы налоговый резидент РФ 
и имеете хорошую белую зп), 
сообтветственно, максимально 52 тыс. руб., либо избавить владельца от налогов спустя 3 года владения счетом. При всех 
этих бонусах процент, который забирает себе брокер выше чем на обычном брокерском счету, и судя по тарифной сетке 
(&lt;a href=&#34;https://broker.ru/f/reg/tarif.pdf&#34; target=&#34;_blank&#34;&gt;1.29. Тарифный план «БКС – Директ»&lt;/a&gt;) 
аналогичен Тиньков Инвестициям (TI). На сегодняшний день я использую обе системы. И у той и у другой есть свои плюсы и 
минусы. Давайте сравним:
&lt;/div&gt;  
&lt;br/&gt;
&lt;div&gt;
&lt;style type=&#34;text/css&#34;&gt;
.tg  {border-collapse:collapse;border-spacing:0; width: 100%}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-baqh{text-align:center;vertical-align:top}
&lt;/style&gt;
&lt;table class=&#34;tg&#34;&gt;
  &lt;tr&gt;
    &lt;th class=&#34;tg-baqh&#34;&gt;Характеристика&lt;/th&gt;
    &lt;th class=&#34;tg-baqh&#34;&gt;БКС ИИС&lt;/th&gt;
    &lt;th class=&#34;tg-baqh&#34;&gt;Tinkoff&lt;br&gt;Инвестиции&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Порог вхождения от 0 до 5&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;5&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Слежение за налогами&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Брокер - налоговый агент&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Налоги вычитаются&lt;br&gt; из суммы при выводе денег&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Перемещение денег&lt;br&gt;между площадками&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Занимает время&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Моментально. &lt;br&gt;Пользователь не знает об этом&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Минимальный объем &lt;br&gt;валюты при покупке&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;$1000&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;$1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Поддержка&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Круглосуточная&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Круглосуточная&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Комиссия&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;0,3% от суммы сделки, но не менее 99 рублей&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;0,3% от суммы сделки, но не менее 99 рублей&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Общее преимущество&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;13% от инвестиций, но до 400 тыс. (требуется белая з/п)&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Любая операция делается очень просто&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Бесплатное мобильное приложение&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Есть&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Есть&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Пополнение счета&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Банковским переводом около 1 рабочего дня&lt;/td&gt;
    &lt;td class=&#34;tg-baqh&#34;&gt;Перевод с карты Тинькофф Банка около 1 рабочего дня&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
 

&lt;p&gt;&lt;div class=&#34;text-justify&#34;&gt;
 Ни одна из этих систем не подходит для внутридневного трейдинга, однако, если вы хотите быть инвестором, то это не проблема.
 &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;При взаимодействии с БКС есть некоторые особенности, вот с чем я столкнулся:
 &lt;div class=&#34;text-justify&#34;&gt;
 &lt;li&gt;для открытия ИИС нужен офис БКС в твоем городе;&lt;/li&gt;
 &lt;li&gt;тебе дают карту, но любые манипуляции через неё сопровождаются комиссией;&lt;/li&gt;
 &lt;li&gt;как для неопытного участника рынка для меня было шоком, когда меня оповестили о том, что нужно обратить внимание
 на маржу, что означало использование заемных средств, хотя я этого не делал, оказалось что такое сообщение приходит
 при недостаточном количестве денежных средств на счету при списании комиссии;&lt;/li&gt;
 &lt;li&gt;всегда держите в голове, что все проценты про которые вам говорят не учитывают налоги, комиссию брокера и депозитария;&lt;/li&gt;
 &lt;li&gt;если у вас есть и Тинькофф Инвестиции и БКС, то в личном кабинете БКС после открытия счета вас будут просить подписать
 реестры поручений, хотя ничего подписывать не нужно - это ошибка на стороне БКС и они уже знают об этом.&lt;/li&gt;
 &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;h2&gt; Итоги&lt;/h2&gt;
 &lt;div class=&#34;text-justify&#34;&gt;
  &lt;li&gt;определитесь с целью;&lt;/li&gt;
  &lt;li&gt;окладывайте 10% з/п ежемесячно;&lt;/li&gt;
  &lt;li&gt;замотивируйте себя визуально;&lt;/li&gt;
  &lt;li&gt;сделайте шаг к устойчивости, например, станьте инвестором;&lt;/li&gt;
  &lt;li&gt;не инвестируйте &lt;strong&gt;нужные&lt;/strong&gt; деньги;&lt;/li&gt;
  &lt;li&gt;выбирайте брокера в соответствии с целями;&lt;/li&gt;
  &lt;li&gt;пользуйтесь налоговыми льготами.&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;В следующих частях я расскажу про интересных эмитентов на западном рынке, акции которых доступны на бирже Санкт-Петербурга,
  а также поделюсь информационными ресурсами, которые приходят на помощь мне при наблюдении за рынком IT компаний, затем мы
  обсудим другие виды инвестиций.
  &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;редакция от 17.06.2017&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Берешь дешевле? Заплатишь позже</title>
      <link>https://i-osipov.ru/post/hosting-thoughts/</link>
      <pubDate>Sat, 06 May 2017 02:37:00 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/hosting-thoughts/</guid>
      <description>&lt;p&gt;Занимательное дело, решил сходить на рынок, купить пару доменов. Зашёл на reg.ru, вышел и забыл на пол года. Спустя время вернулся с кучей идей и большим желанием прикупить себе парочку, но один хороший человек подсказал мне, что бывает и дешевле. Вспомнил я всё чему меня учили и вышел с этим вопросом в Интернет. Оказалось что можно купить тоже самое и в два раза дешевле. Ну тут моё детское сердце не выдержало, я и купил. Итого: 2 домена по 99 рублей, всего 198 р. Звучит не дорого.&lt;/p&gt;

&lt;p&gt;Передо мной стояла задача: взять простую html страничку и залить её на просторы интернета. Я - человек не избалованный знаниями в области создания сайтов понимаю, что мне нужно всего лишь отдавать статический контент сайта, однако, на далёкой, возможно не сбытной, перспективе за этой статикой будет какой-никакой бекэнд, естественно, на Java.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/hostimg-thoughts/heroku.png&#34; alt=&#34;Heroku&#34; title=&#34;Heroku&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Я спросил у гугла и получил ответ. Heroku - облачная PaaS-платформа. Это значит, что тебе не нужно настраивать сервер и всё всё вокруг него и это замечательно! Я скачал и установил их приложение и через консоль отправил свой прекрасный html файлик на сервера Heroku, ну, а кроме него, еще всё остальное Spring Boot приложение, которое сейчас формальная обертка над статикой, ну пригодится же, точно говорю. Конечно для создание Spring Boot приложения я воспользовался их стандартным генератором, довольно удобно. Сгенерировал -&amp;gt; Распаковал -&amp;gt; Вставил статику -&amp;gt; Готово. У хероку есть несколько способов отправить код на сервер, один из которых - использовать Git репозиторий внутри хероку. Отличный способ, кроме одного момента: аутентификация.&lt;/p&gt;

&lt;p&gt;Как вы, вероятно, знаете у гита есть два способа подтвердить себя: https, ssl. Я обычно предпочитаю простые пути, следовательно, https мне в помощь, однако всё не так просто. При выполнении git push система запрашивает ваши креденшиналы. Уж не знаю, что я делал не так, даже авторизовывался через консоль как сказано на сайте этих ребят - ничего не помогало. Всплывает окно авторизации к которому не подходят стандартные. Как типичный разработчик, прежде чем читать документацию, я решил погуглить и погуглил. А нагуглил я себе документацию, оказалось, что поле логина нужно оставить пустым, а в пароль вставить очень хитрый ключ из личного кабинета Хероку. Видимо я вновь, что-то не так понял, т.к. этот метод мне тоже не помог, смерившись со сложностью такого простого способа я решил запушить наХероку публичный ключик и это решило проблему авторизации быстрее чем за 5 минут.&lt;/p&gt;

&lt;p&gt;Сижу довольный, смотрю в документацию и изучаю как же подтянуть кастомный домен. Оказалось, что хероку дает тебе специальный DNS target, который ты вписываешь как CNAME, когда редактируешь зону DNS у своего поставщика домена. Как бы не так, не дает мой регистратор задать CNAME на корневой домен (@.example.com) и приводит мне цитаты, видимо из любимых книжек:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Нельзя указывать записи CNAME и другие с тем же именем.
Смотрите RFC1912, раздел 2.4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Бабах! www.exampe.com можно, *.example.com можно, а @.example.com нельзя! И что делать? Оказывается, что www.exampe.com работает, а exampe.com нет, но вот что забавно, если хоть раз посетить www.exampe.com, то неработающий exampe.com начинает переадресовывать тебя на старый, добрый www.exampe.com. Единственное решение, которое пришло на данный момент - это задать переадресацию у регистратора. Здорово, конечно, но это еще 120 р. за то, что кто-то где-то написал в спецификации. Деньги здесь, конечно, роли не играют, но сам факт такого решения меня возмущает.&lt;/p&gt;

&lt;p&gt;И тут я подумал посмотреть на другие хостинги, там оказалось всё еще хуже. На Amazon - $ 7 за перенос домена, на Azure - месяц бесплатно, не плохо, но нужно глубже разобраться, на Google Cloud Engine всё отлично, но инфраструктура и навязаная работа с key value store - мне не нравится (по крайней мере год назад было так), да и всё это IaaS, а мне бы файлик залить&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/hostimg-thoughts/heroku-split.png&#34; alt=&#34;Heroku&#34; title=&#34;Heroku&#34; /&gt;&lt;/p&gt;

&lt;p&gt;В итоге, самая простая привязка кастомного домена оказалась у Github Pages. Они дают IP, DNS сервер их легко принимает и всё работает уже через несколько минут. Для хостинга своего одностраничного проекта так и оставил Heroku, а для своего блога на Github Pages сделал привязку домена i-osipov.ru. А это я даже не глубоко копнул в этот мир деплоя веб сайтов и приложений&amp;hellip; На пути Докер. Надо узнать что это такое и как его запускать на Windows 8, слышал что-то про виртуалки, но это уже совсем другая история&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>