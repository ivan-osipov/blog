<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/architecture/index.xml</link>
    <description>Recent content in Architecture on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Backends for Frontends</title>
      <link>https://i-osipov.ru/post/bff/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/bff/</guid>
      <description>

&lt;p&gt;Микросервисный пузырь как будто уже лопнул и все, кто поспешно применял этот взгляд на архитектуру бекенда либо канули в Лету, либо многократно пожалели о своем выборе этого тернистого пути. Пожалуй, это связано в первую очередь с бездумным разбиением кода на кучу маленьких тесно-связанных приложений, создания наносервисов и т.п. Всё это происходит из-за недостаточного количества хороших практик? Конечно нет, скорее из-за отсутствия информированности о простейших шаблонах проектирования таких систем. Здесь пойдет речь о шаблоке &amp;ldquo;бекенды для фронтендов&amp;rdquo;, но для начала давай разберемся, а в чем же проблема&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;проблема&#34;&gt;Проблема&lt;/h1&gt;

&lt;p&gt;Мы делаем софт у которого есть конечные пользователи. В случае разработки бекенда это может быть разношерстный пул клиентов. Это проблема. Клиенты должны с тобой взаимодействовать и для этого ты предоставляешь им API. Здесь довольно очевидные вещи и я не хотел бы останавливаться на них, разбирая термин API и говоря банальные вещи о том, что API должен быть документирован и удобен, не должен ломать совместимость от версии к версии (а лучше, должен версионироваться) и так далее, всё это ясно. А какие бывают клиенты? Вот тебе бытовая классификация потенциальных потребителей твоего апи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;классический веб фронтенд, написанный типично на js и работающий в браузере пользователя;&lt;/li&gt;
&lt;li&gt;мобильные клиенты, обычные приложения, которые стоят на смартфонах пользователей;&lt;/li&gt;
&lt;li&gt;GraphQL сервер между тобой и фронтендом;&lt;/li&gt;
&lt;li&gt;интеграции с различными сервисами, когда ты определяешь api, которое будут дергать какие-то внутренние системы, которые разрабатываешь не ты;&lt;/li&gt;
&lt;li&gt;внешние системы, например, какой-то другой бекенд, который написал кто-то для создания собственного сервиса, который использует тебя для части задач.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже если я что-то забыл - это не страшно, идея понятна, клиенты гетерогенные. При чем, для одних было бы здорово получать информацию по кусочкам, каждый раз дозапрашивая часть, для других нужно минимизировать количество запросов, т.к. это сажает батарейку, а для третьих нужена определенная подготовленная структура данных, потому что логика обработки запросов на той стороне обязана быть минималистичной. Всё это приводит нас к проблеме того, что нашему сервису нужно обеспечивать логику, которая подойдет одновременно всем клиентам.&lt;/p&gt;

&lt;p&gt;Какие есть варианты решения? Остановимся на нескольких клиентах, допустим у нас ожидается мобильное приложение, веб фронтенд, парочка внутренних интеграций.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-1&#34;&gt;Попытка решения 1&lt;/h1&gt;

&lt;p&gt;Давайте ничего не будем делать. Как гласят источники - иногда, ничего не делать - это лучшее решение. Поставим HTTP API, оформим для единообразия его в стиле REST (об этом была прошлая &lt;a href=&#34;../../post/rest-is-not-rpc/&#34;&gt;статья&lt;/a&gt;) и вуаля, всем подходит. Так ли это? На практике окажется, что в этом API сликом много данных для мобильных клиентов и вообще им приходится делать дюжину запросов, чтобы собрать полную картину в этом вашем REST. Внутренние интеграции будут недовольны необходимостью слишком много знать про твое API, да и вообще, не понятно как и где будут появляться специфичные для интеграции запросы. Зато веб фронтенду будет в принципе всё круто.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-2&#34;&gt;Попытка решения 2&lt;/h1&gt;

&lt;p&gt;Подумаем, можем ли мы упростить всё и поставить вместо HTTP API - GraphQL API, а уже за ним ничего не делать и снова оформить в REST стиле и попивать чай, наслаждаясь результатом? С первого взгляда создается ощущение, что да, однако, скорее всего окажется, что внутренние интеграции не захотят подобного рода взаимодействие и вообще им бы пару методов дернуть, только вот методы эти специфичные и нужны только им.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-3&#34;&gt;Попытка решения 3&lt;/h1&gt;

&lt;p&gt;Сделать толстый API Gateway, который реализует всю специфичную логику, дает возможность реализовать на нем все виды взаимодейсткий. В теории, такое решение, конечно, даст результат, однако ценой тесного связывания в одном месте большого количества несвязанной логики, более того, этот гейтвей будет нагружаться всем, чем только можно, что обязательно скажется на производительности решения.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-4&#34;&gt;Попытка решения 4&lt;/h1&gt;

&lt;p&gt;Дадим клиентам доступ напрямую к базе данных! Ладно, это шутка, никогда так не делайте, это как минимум свяжет вас по рукам и ногам.&lt;/p&gt;

&lt;h1 id=&#34;решение&#34;&gt;Решение&lt;/h1&gt;

&lt;p&gt;О том, что этот шаблон в качестве решения проблемы используют на практике многие компании (например, SoundCloud) я узнал из книги Сема Ньюмана &amp;ldquo;Создание микросервисов&amp;rdquo;. &lt;a href=&#34;../../post/building-microservices/&#34;&gt;Вот здесь&lt;/a&gt; я написал на неё обзор, ты можешь почитать. Позволь, я проиллюстрирую пример:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/bff/bff.png&#34; alt=&#34;bff&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как становится очевидно, для каждого типа клиента заводится свой BFF (Backend For Frontend), что помогает спрятать в нём все специфики связанные с потребителем API. Если возникает потребность в дублировании части логики, то следует обратить на это внимание, возможно где-то раньше был пропущен кандидат на попадание в отдельный сервис, как, например, Service AB на рисунке выше. При всём этом, сколько BFF будет в итоге - частное решение, однако, если ты видишь, что логика работы двух мобильных клиентов с одним BFF всё больше отличается, то, вероятно, это знак к разделению Mobile BFF на Android BFF и iOS BFF.&lt;/p&gt;

&lt;p&gt;Конечно, буду рад услышать то, как бы вы справлялись с этой проблемой.&lt;/p&gt;

&lt;p&gt;На почитать:&lt;br /&gt;
Сем Ньюман &amp;ldquo;Создание микросервисов&amp;rdquo;&lt;br /&gt;
&lt;a href=&#34;https://samnewman.io/patterns/architectural/bff/&#34;&gt;Backends for Frontends&lt;/a&gt; samnewman.io&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Книга: Создание микросервисов</title>
      <link>https://i-osipov.ru/post/building-microservices/</link>
      <pubDate>Fri, 07 Sep 2018 23:59:28 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/building-microservices/</guid>
      <description>

&lt;p&gt;Параллельно с прослушиванием аудиокниг я не расстаюсь с классическим форматом. Не всегда удается читать бумажную версию, благо, гаджеты сегодня не отстают. На днях я закончил книгу, которую начал читать еще в январе этого года, но спустя время прервался и вот, в связи с новым местом работы и новыми задачами книга стала для меня снова актуальна - книга &lt;a href=&#34;https://www.ozon.ru/context/detail/id/135199296/&#34; target=&#34;_blank&#34;&gt;Создание микросервисов&lt;/a&gt;  от автора Сэма Ньюмана.&lt;/p&gt;

&lt;h3 id=&#34;об-авторе&#34;&gt;Об авторе&lt;/h3&gt;

&lt;p&gt;Ты не знаешь кто такой автор? Не беда! Знаешь Мартина Фаулера? Да, того мужика, который топит за Рефакторинг, Шаблоны корпоративных приложений и UML (это всё его книжки), ну и конечно за микросервисы в своем блоге. Так вот, Сэм и Мартин работают в одной конторе ThoughtWorks. На сколько я понимаю, эти ребята занимаются консалтингом в построении всяких разных систем и в использовании микросервисных архитектур. Занятная работенка. Между делом ребята пишут книги, вот сегодня и поговорим про одну из них.&lt;/p&gt;

&lt;h3 id=&#34;обзор&#34;&gt;Обзор&lt;/h3&gt;

&lt;p&gt;Сразу скажу, впечатления от книги хорошие. На многие вопросы она дает ответы, но не на все. Такс, давай по порядку.&lt;/p&gt;

&lt;p&gt;Прежде всего я для себя усвоил из книги интересную и, пожалуй, самую главную мысль. Твои и мои системы будут падать, обязательно будут падать. Вот так, без этого в нашем производстве никак. Сэм обращает внимание на одну забавную вещь. В действительности среди наших коллег можно наблюдать Архитекторов, Инженеров и другие громкие названия должностей, при том, что это всё заимствованные слова из других профессий. Архитектор софта и архитектор здания или моста это совершенно несравнимые люди. За архитекторами, которые проектируют очередной мост, стоит огромная история, тонна знаний, которые передаются из века в век, снова и снова. Какой релевантный багаж у наших архитекторов, ну, например, банковских систем? 20-40 лет? В масштабах реальной архитектуры это практически ничто. Мы пытаемся навешать ярлыков, чтобы ощутить ложное чувство защищенности, но от правды никуда не скроешься. Наши системы обязательно будут где-то падать, где-то работать не так как ожидалось и это нормально, для текущего этапа прогресса, это вполне приемлемо. Наша же задача, быть к этому готовыми. В общем, мне нравится эта мысль, особенно на фоне прочтения статей о &lt;a href=&#34;https://en.wikipedia.org/wiki/Crash-only_software&#34; target=&#34;_blank&#34;&gt;crash-only software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Второй, важный пункт, который отмечает автор - это моделирование сервисов на основе ограниченных контекстов. Я не буду углубляться в детали, но об этом можно думать как о моделировании опираясь на бизнес потебности, а не на технологии. Например, автор описывает жуткую луковую архитектуру, где разделение проходит по технологической грани, т.е., например, для работы с общей базой данных создают отдельный сервис. Как верно замечает автор, от луковой архитектуры хочется плакать.&lt;/p&gt;

&lt;p&gt;Здесь правильнее же разбивать сервисы на слабо связанные (минимально зависимые) системы с сильным зацеплением. Это значит, что сервисы должны по минимуму соприкасаться и при этом функции, которые обеспечивают взаимодействие должны покрывать потребности по максимуму. Я сформировал некоторое представление о том, как должна развиваться микросервисная архитектура начиная с нуля и заканчивая продакшен окружением, с чего она должна начинаться и куда двигаться. И, хотя, сначала я хотел описать это здесь, решил, что это большая тема для отдельной статьи.
&lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;Подписывайтесь&lt;/a&gt; чтобы не пропустить.&lt;/p&gt;

&lt;p&gt;Пара важных паттернов, которые вы встретите в книге, это Backends for Frontends и Tolerant Reader. Про последний я уже писал вот &lt;a href=&#34;https://i-osipov.ru/post/apostels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;.  Backends for Frontends это когда вы под кажный тип клиента имеете по сути свой gateway, который контролирует объем данных, необходимый этому виду клиента, например, когда нам нужно получить данные на мобильный клиент их, во-первых, должно быть по минимуму, во-вторых, для экономии батареи устройства использовать минимум запросов. Дроссель - это еще один интересный паттерн, который описывает автор, как полезный подход при миграции с legacy систем.&lt;/p&gt;

&lt;p&gt;Многие вещи довольно очевидны, как мне кажется, но когда ты видишь подтверждение собственных мыслей в виде паттернов, то на душе становится легче.&lt;/p&gt;

&lt;p&gt;Помните, что не стоит спешить плодить нано-сервисы, т.к. ни к чему хорошему это не приведет. Растите сервис, а когда внутри него сформируются собственные домены, то это хороший знак, чтобы разбить сервис на две независимых части, кстати, как это сделать в книжке тоже рассказывается.&lt;/p&gt;

&lt;p&gt;Разделы о развертывании и тестировании хорошо пересекаются с видео, которое я упоминал на своем &lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;телеграм канале&lt;/a&gt;&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/K1l8717tN2c&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Достаточно плотно автор обрисовал масштабирование микросервисов. Представил различные способы, в том числе и упреждающие, для мониринга и локализации проблем в микросервисной архитектуре, например, прокидывание ID запроса по всей цепочке вызовов для удобного дальнейшего поиска по логам.&lt;/p&gt;

&lt;p&gt;Из недостатков, я не увидел практически никакой информации о том какие практики используются для авторизации действий пользователей в системе. JWT токен был упомянут единожды вскользь. Как автор администрировал одновременно множество сервисов также остается загадкой, возможно никак. Хотя у меня есть представление как реализовать всё, что меня интересует, в книге этой информации нет.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Я не претендую на роль лучшего обзорщика книг этого года, но хотел в первую очередь поделиться с вами впечатлениями о книге. Резюмируя вышесказанное: книга хороша, особенно, если вы не знаете как подобраться к задаче проектирования микросервисной архитектуры, в таком случае книга точно для вас. Больше всего, сама книга напоминает обзор возможных действий и вариантов реализации при проектировании микросервисных систем, к счастью, автор упоминает достаточное обилие тулов, которые упрощают жизнь. Уже сформировал себе список инструментов с которыми еще предстоит познакомится. В целом, рекомендую к прочтению, особенно, если ты на стороне бекенда.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>