<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microservices on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/microservices/index.xml</link>
    <description>Recent content in Microservices on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/microservices/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Книга: Создание микросервисов</title>
      <link>https://i-osipov.ru/post/building-microservices/</link>
      <pubDate>Fri, 07 Sep 2018 23:59:28 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/building-microservices/</guid>
      <description>

&lt;p&gt;Параллельно с прослушиванием аудиокниг я не расстаюсь с классическим форматом. Не всегда удается читать бумажную версию, благо, гаджеты сегодня не отстают. На днях я закончил книгу, которую начал читать еще в январе этого года, но спустя время прервался и вот, в связи с новым местом работы и новыми задачами книга стала для меня снова актуальна - книга &lt;a href=&#34;https://www.ozon.ru/context/detail/id/135199296/&#34; target=&#34;_blank&#34;&gt;Создание микросервисов&lt;/a&gt;  от автора Сэма Ньюмана.&lt;/p&gt;

&lt;h3 id=&#34;об-авторе&#34;&gt;Об авторе&lt;/h3&gt;

&lt;p&gt;Ты не знаешь кто такой автор? Не беда! Знаешь Мартина Фаулера? Да, того мужика, который топит за Рефакторинг, Шаблоны корпоративных приложений и UML (это всё его книжки), ну и конечно за микросервисы в своем блоге. Так вот, Сэм и Мартин работают в одной конторе ThoughtWorks. На сколько я понимаю, эти ребята занимаются консалтингом в построении всяких разных систем и в использовании микросервисных архитектур. Занятная работенка. Между делом ребята пишут книги, вот сегодня и поговорим про одну из них.&lt;/p&gt;

&lt;h3 id=&#34;обзор&#34;&gt;Обзор&lt;/h3&gt;

&lt;p&gt;Сразу скажу, впечатления от книги хорошие. На многие вопросы она дает ответы, но не на все. Такс, давай по порядку.&lt;/p&gt;

&lt;p&gt;Прежде всего я для себя усвоил из книги интересную и, пожалуй, самую главную мысль. Твои и мои системы будут падать, обязательно будут падать. Вот так, без этого в нашем производстве никак. Сэм обращает внимание на одну забавную вещь. В действительности среди наших коллег можно наблюдать Архитекторов, Инженеров и другие громкие названия должностей, при том, что это всё заимствованные слова из других профессий. Архитектор софта и архитектор здания или моста это совершенно несравнимые люди. За архитекторами, которые проектируют очередной мост, стоит огромная история, тонна знаний, которые передаются из века в век, снова и снова. Какой релевантный багаж у наших архитекторов, ну, например, банковских систем? 20-40 лет? В масштабах реальной архитектуры это практически ничто. Мы пытаемся навешать ярлыков, чтобы ощутить ложное чувство защищенности, но от правды никуда не скроешься. Наши системы обязательно будут где-то падать, где-то работать не так как ожидалось и это нормально, для текущего этапа прогресса, это вполне приемлемо. Наша же задача, быть к этому готовыми. В общем, мне нравится эта мысль, особенно на фоне прочтения статей о &lt;a href=&#34;https://en.wikipedia.org/wiki/Crash-only_software&#34; target=&#34;_blank&#34;&gt;crash-only software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Второй, важный пункт, который отмечает автор - это моделирование сервисов на основе ограниченных контекстов. Я не буду углубляться в детали, но об этом можно думать как о моделировании опираясь на бизнес потебности, а не на технологии. Например, автор описывает жуткую луковую архитектуру, где разделение проходит по технологической грани, т.е., например, для работы с общей базой данных создают отдельный сервис. Как верно замечает автор, от луковой архитектуры хочется плакать.&lt;/p&gt;

&lt;p&gt;Здесь правильнее же разбивать сервисы на слабо связанные (минимально зависимые) системы с сильным зацеплением. Это значит, что сервисы должны по минимуму соприкасаться и при этом функции, которые обеспечивают взаимодействие должны покрывать потребности по максимуму. Я сформировал некоторое представление о том, как должна развиваться микросервисная архитектура начиная с нуля и заканчивая продакшен окружением, с чего она должна начинаться и куда двигаться. И, хотя, сначала я хотел описать это здесь, решил, что это большая тема для отдельной статьи.
&lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;Подписывайтесь&lt;/a&gt; чтобы не пропустить.&lt;/p&gt;

&lt;p&gt;Пара важных паттернов, которые вы встретите в книге, это Backends for Frontends и Tolerant Reader. Про последний я уже писал вот &lt;a href=&#34;https://i-osipov.ru/post/apostels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;.  Backends for Frontends это когда вы под кажный тип клиента имеете по сути свой gateway, который контролирует объем данных, необходимый этому виду клиента, например, когда нам нужно получить данные на мобильный клиент их, во-первых, должно быть по минимуму, во-вторых, для экономии батареи устройства использовать минимум запросов. Дроссель - это еще один интересный паттерн, который описывает автор, как полезный подход при миграции с legacy систем.&lt;/p&gt;

&lt;p&gt;Многие вещи довольно очевидны, как мне кажется, но когда ты видишь подтверждение собственных мыслей в виде паттернов, то на душе становится легче.&lt;/p&gt;

&lt;p&gt;Помните, что не стоит спешить плодить нано-сервисы, т.к. ни к чему хорошему это не приведет. Растите сервис, а когда внутри него сформируются собственные домены, то это хороший знак, чтобы разбить сервис на две независимых части, кстати, как это сделать в книжке тоже рассказывается.&lt;/p&gt;

&lt;p&gt;Разделы о развертывании и тестировании хорошо пересекаются с видео, которое я упоминал на своем &lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;телеграм канале&lt;/a&gt;&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/K1l8717tN2c&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Достаточно плотно автор обрисовал масштабирование микросервисов. Представил различные способы, в том числе и упреждающие, для мониринга и локализации проблем в микросервисной архитектуре, например, прокидывание ID запроса по всей цепочке вызовов для удобного дальнейшего поиска по логам.&lt;/p&gt;

&lt;p&gt;Из недостатков, я не увидел практически никакой информации о том какие практики используются для авторизации действий пользователей в системе. JWT токен был упомянут единожды вскользь. Как автор администрировал одновременно множество сервисов также остается загадкой, возможно никак. Хотя у меня есть представление как реализовать всё, что меня интересует, в книге этой информации нет.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Я не претендую на роль лучшего обзорщика книг этого года, но хотел в первую очередь поделиться с вами впечатлениями о книге. Резюмируя вышесказанное: книга хороша, особенно, если вы не знаете как подобраться к задаче проектирования микросервисной архитектуры, в таком случае книга точно для вас. Больше всего, сама книга напоминает обзор возможных действий и вариантов реализации при проектировании микросервисных систем, к счастью, автор упоминает достаточное обилие тулов, которые упрощают жизнь. Уже сформировал себе список инструментов с которыми еще предстоит познакомится. В целом, рекомендую к прочтению, особенно, если ты на стороне бекенда.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>