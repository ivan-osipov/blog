<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/development/index.xml</link>
    <description>Recent content in Development on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Telegram API. Как написать бота?</title>
      <link>https://i-osipov.ru/post/how_to_create_telegram_bot/</link>
      <pubDate>Sun, 23 Jul 2017 23:10:24 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/how_to_create_telegram_bot/</guid>
      <description>&lt;p&gt;Всем привет!&lt;/p&gt;

&lt;p&gt;Сегодня мы побеседуем о том как делаются Telegram боты.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кто ты по жизни?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Telegram боты бывают двух видов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Боты основанные на Webhoock&lt;/li&gt;
&lt;li&gt;Боты основанные на Long Polling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый вариант бота требует от вас поднять сервер и установить &amp;ldquo;вебхуки&amp;rdquo; для асинхронного оповещения вас о новых изменениях. На вашем сервере должен быть соответствующий роутинг.&lt;/p&gt;

&lt;p&gt;Второй вариант бота - это имитация асинхронности. Ваш бот с определенным периодом будет запрашивать последние изменения с сервера телеграм на основании механизма long polling. Т.е. бот делает запрос и подвисает, а отвисает либо по таймауту, либо по получению новыйх обновлений. Об этом виде ботов сегодня и пойдет речь.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long polling в разрезе работы с сетью&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Когда вы работаете с Telegram Api вы нагружаете сервера Telegram. Все запросы вы отправляете по одному URL, но в один момент времени может работать только один обработчик для Telegram бота.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Интересно, что в API предусмотрена умная обработка ошибок, среди прочего, в ответе телеграм сервера, который вы за DDOS&amp;rsquo;или, может сообщить вам сколько нужно подождать, чтобы вы могли взаимодействовать с Telegram снова&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Как сказано выше у вас фактически однопоточная обработка запросов к телеграм. По этому, кажется, здравым принять одну из следующих реализаций ботов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;реализовать поток, который будет отправлять запросы и складировать ответы в общую очередь из которой потоки-обработчики будут их разбирать;&lt;/li&gt;
&lt;li&gt;поставить прокси-сервер, который будет затягивать последние изменения и шарить их между нодами (другими серверами) бота. В этом случае можно подменяя прокси-сервер менять реализации взаимодействия с telegram api не меняя реализацию для нод. Это решение мне нравится несколько больше, его масштабируемость зависит от потребностей в функциональности бота, т.к. если можно обрабатывать параллельно несколько чатов независимо друг от друга, то масштабируемость на пределе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оставим использование прокси-сервера для будущих статей, а пока давайте рассмотрим как вы можете реализовать своего бота.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Красная или синяя таблетка?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;На сколько вы любите писать велосипеды? В зависимости от этого у вас есть 2 пути реализации Telegram бота:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;писать всё самому с нуля;&lt;/li&gt;
&lt;li&gt;воспользоваться существующей библиотекой.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если вы используете динамически типизируемые языки, которые поддерживают нативную работу с JSON, то первый вариант, не так уж и плох, однако, уже существует большое количество библиотек для разработки ботов их публичный перечень вы можете увидеть &lt;a href=&#34;https://core.telegram.org/bots/samples&#34;&gt;здесь&lt;/a&gt;. Вы найдете много вариантов для PHP, Java, Python, Node.js и так далее. Я сейчас реализую собственную библиотеку на языке Kotlin - &lt;a href=&#34;https://clabo.i-osipov.ru/&#34;&gt;Clabo&lt;/a&gt;. Эта библиотека поможет вам на основании расширяемого DSL описать работу своего бота, например, всё что надо для запуска бота, который говорит &amp;ldquo;Привет!&amp;rdquo; по команде /start это небольшой кусочек кода по &lt;a href=&#34;https://gist.github.com/ivan-osipov/266204f3560a6c5e64d381df5c73bf22&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BotFather&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В телеграме есть специальный бот, который позволяет создавать других ботов и настраивать их. Некоторые действия вы, как пользователь, не можете сделать из интерфейса, например, сменить имя бота или задать набор команд, для этого нужен &lt;a href=&#34;http://t.me/botfather&#34;&gt;BotFather&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Теперь у вас есть представление, как реализовать бота, но что с ним можно сделать? Об этом я расскажу ниже.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;И зачем всё это?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Боты очень способные, они обладают следующими возможностями:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;ul&gt;
&lt;li&gt;Встраиваемый мод (Inline mode). Вы можете встроить бота прямо в строку с вводом, хорошие примеры таких ботов это GifBot и YouTubeBot. Вы вписываете имя бота, например, @youtube и он предлагает вам результаты поиска видео или вы можете авторизоваться и результаты будут специфичны для вас.&lt;/li&gt;
&lt;li&gt;Клавиатуры. Есть два вида клавиатур: &amp;ldquo;Клавиатура для быстрого ответа&amp;rdquo; и &amp;ldquo;Встроенная клавиатура&amp;rdquo;. Первый вариант позволяет пользователю не писать сообщение, а просто отправить его выбрав один из вариантов. Встроенная клавиатура размещается прямо под сообщением и ассоциирована именно с ним.&lt;/li&gt;
&lt;li&gt;Команды. Всё что вы пишете после &amp;ldquo;/&amp;rdquo; в телеграм называется командами, чтобы избежать коллизий, когда два бота в одном чате имеют одну и ту же команду используется следующий формат &lt;code&gt;/command@BotName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Бот может отправлять отформатированные с помощью html или markdown сообщения.&lt;/li&gt;
&lt;li&gt;Бот может запросить местоположение или номер телефона.&lt;/li&gt;
&lt;li&gt;Ботов можно добавлять в группы и, например, администрировать их.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;&lt;strong&gt;Что в итоге?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Мы обзорно рассмотрели основы того как можно сделать ботов, для чего это и что они могут делать. Применение ботов ограничивается только вашей фантазией.
Вы создаете бота и запускаете сопровождающий код, который обрабатывает сообщения. Ничего сложного. Увидимся в следующих статьях!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Начинаю новый эксперимент: подкастинг</title>
      <link>https://i-osipov.ru/post/i-have-a-first-podcast/</link>
      <pubDate>Mon, 30 Jan 2017 01:41:31 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/i-have-a-first-podcast/</guid>
      <description>&lt;p&gt;Решил испытать себя в деле подкастинга. Прослушать и скачать пилотный выпуск можете ниже:&lt;/p&gt;

&lt;p&gt;&lt;audio controls=&#34;controls&#34;&gt;
  &lt;source type=&#34;audio/mp3&#34; src=&#34;http://mobymob.podfm.ru/fjlp/1/file/podfm_mobymob_fjlp_1.mp3&#34;&gt;&lt;/source&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mobymob.podfm.ru/fjlp/1/file/podfm_mobymob_fjlp_1.mp3&#34;&gt;Загрузить&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Содержание пилотного выпуска&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;00:35&lt;/strong&gt; — Об авторе&lt;br /&gt;
&lt;strong&gt;00:58&lt;/strong&gt; — Мотивация подкаста&lt;br /&gt;
&lt;strong&gt;02:00&lt;/strong&gt; — Обобщенные темы подкаста&lt;br /&gt;
&lt;strong&gt;02:26&lt;/strong&gt; — Формат подкаста&lt;br /&gt;
&lt;strong&gt;03:00&lt;/strong&gt; — Каково быть студентом на IT специальности в ВУЗе&lt;br /&gt;
&lt;strong&gt;13:00&lt;/strong&gt; — О современной потребности в дипломе&lt;br /&gt;
&lt;strong&gt;24:32&lt;/strong&gt; — Планирование жизни&lt;br /&gt;
&lt;strong&gt;28:50&lt;/strong&gt; — О собственном развитии&lt;br /&gt;
&lt;strong&gt;30:44&lt;/strong&gt; — Поддержка окружения, конкуренция&lt;br /&gt;
&lt;strong&gt;35:06&lt;/strong&gt; — Откуда взять свободное время?&lt;br /&gt;
&lt;strong&gt;38:22&lt;/strong&gt; — Поиски лучшей жизни&lt;br /&gt;
&lt;strong&gt;41:40&lt;/strong&gt; — Инвестирование&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>