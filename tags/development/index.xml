<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/development/index.xml</link>
    <description>Recent content in Development on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. Осмысленность в сухую нумерацию пакетов вносит Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Telegram API. Как написать бота?</title>
      <link>https://i-osipov.ru/post/how_to_create_telegram_bot/</link>
      <pubDate>Sun, 23 Jul 2017 23:10:24 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/how_to_create_telegram_bot/</guid>
      <description>&lt;p&gt;Всем привет!&lt;/p&gt;

&lt;p&gt;Сегодня мы побеседуем о том как делаются Telegram боты.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кто ты по жизни?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Telegram боты бывают двух видов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Боты основанные на Webhoock&lt;/li&gt;
&lt;li&gt;Боты основанные на Long Polling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый вариант бота требует от вас поднять сервер и установить &amp;ldquo;вебхуки&amp;rdquo; для асинхронного оповещения вас о новых изменениях. На вашем сервере должен быть соответствующий роутинг.&lt;/p&gt;

&lt;p&gt;Второй вариант бота - это имитация асинхронности. Ваш бот с определенным периодом будет запрашивать последние изменения с сервера телеграм на основании механизма long polling. Т.е. бот делает запрос и подвисает, а отвисает либо по таймауту, либо по получению новыйх обновлений. Об этом виде ботов сегодня и пойдет речь.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long polling в разрезе работы с сетью&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Когда вы работаете с Telegram Api вы нагружаете сервера Telegram. Все запросы вы отправляете по одному URL, но в один момент времени может работать только один обработчик для Telegram бота.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Интересно, что в API предусмотрена умная обработка ошибок, среди прочего, в ответе телеграм сервера, который вы за DDOS&amp;rsquo;или, может сообщить вам сколько нужно подождать, чтобы вы могли взаимодействовать с Telegram снова&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Как сказано выше у вас фактически однопоточная обработка запросов к телеграм. По этому, кажется, здравым принять одну из следующих реализаций ботов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;реализовать поток, который будет отправлять запросы и складировать ответы в общую очередь из которой потоки-обработчики будут их разбирать;&lt;/li&gt;
&lt;li&gt;поставить прокси-сервер, который будет затягивать последние изменения и шарить их между нодами (другими серверами) бота. В этом случае можно подменяя прокси-сервер менять реализации взаимодействия с telegram api не меняя реализацию для нод. Это решение мне нравится несколько больше, его масштабируемость зависит от потребностей в функциональности бота, т.к. если можно обрабатывать параллельно несколько чатов независимо друг от друга, то масштабируемость на пределе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оставим использование прокси-сервера для будущих статей, а пока давайте рассмотрим как вы можете реализовать своего бота.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Красная или синяя таблетка?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;На сколько вы любите писать велосипеды? В зависимости от этого у вас есть 2 пути реализации Telegram бота:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;писать всё самому с нуля;&lt;/li&gt;
&lt;li&gt;воспользоваться существующей библиотекой.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если вы используете динамически типизируемые языки, которые поддерживают нативную работу с JSON, то первый вариант, не так уж и плох, однако, уже существует большое количество библиотек для разработки ботов их публичный перечень вы можете увидеть &lt;a href=&#34;https://core.telegram.org/bots/samples&#34;&gt;здесь&lt;/a&gt;. Вы найдете много вариантов для PHP, Java, Python, Node.js и так далее. Я сейчас реализую собственную библиотеку на языке Kotlin - &lt;a href=&#34;https://clabo.i-osipov.ru/&#34;&gt;Clabo&lt;/a&gt;. Эта библиотека поможет вам на основании расширяемого DSL описать работу своего бота, например, всё что надо для запуска бота, который говорит &amp;ldquo;Привет!&amp;rdquo; по команде /start это небольшой кусочек кода по &lt;a href=&#34;https://gist.github.com/ivan-osipov/266204f3560a6c5e64d381df5c73bf22&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BotFather&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В телеграме есть специальный бот, который позволяет создавать других ботов и настраивать их. Некоторые действия вы, как пользователь, не можете сделать из интерфейса, например, сменить имя бота или задать набор команд, для этого нужен &lt;a href=&#34;http://t.me/botfather&#34;&gt;BotFather&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Теперь у вас есть представление, как реализовать бота, но что с ним можно сделать? Об этом я расскажу ниже.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;И зачем всё это?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Боты очень способные, они обладают следующими возможностями:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;ul&gt;
&lt;li&gt;Встраиваемый мод (Inline mode). Вы можете встроить бота прямо в строку с вводом, хорошие примеры таких ботов это GifBot и YouTubeBot. Вы вписываете имя бота, например, @youtube и он предлагает вам результаты поиска видео или вы можете авторизоваться и результаты будут специфичны для вас.&lt;/li&gt;
&lt;li&gt;Клавиатуры. Есть два вида клавиатур: &amp;ldquo;Клавиатура для быстрого ответа&amp;rdquo; и &amp;ldquo;Встроенная клавиатура&amp;rdquo;. Первый вариант позволяет пользователю не писать сообщение, а просто отправить его выбрав один из вариантов. Встроенная клавиатура размещается прямо под сообщением и ассоциирована именно с ним.&lt;/li&gt;
&lt;li&gt;Команды. Всё что вы пишете после &amp;ldquo;/&amp;rdquo; в телеграм называется командами, чтобы избежать коллизий, когда два бота в одном чате имеют одну и ту же команду используется следующий формат &lt;code&gt;/command@BotName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Бот может отправлять отформатированные с помощью html или markdown сообщения.&lt;/li&gt;
&lt;li&gt;Бот может запросить местоположение или номер телефона.&lt;/li&gt;
&lt;li&gt;Ботов можно добавлять в группы и, например, администрировать их.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;&lt;strong&gt;Что в итоге?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Мы обзорно рассмотрели основы того как можно сделать ботов, для чего это и что они могут делать. Применение ботов ограничивается только вашей фантазией.
Вы создаете бота и запускаете сопровождающий код, который обрабатывает сообщения. Ничего сложного. Увидимся в следующих статьях!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Начинаю новый эксперимент: подкастинг</title>
      <link>https://i-osipov.ru/post/i-have-a-first-podcast/</link>
      <pubDate>Mon, 30 Jan 2017 01:41:31 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/i-have-a-first-podcast/</guid>
      <description>&lt;p&gt;Решил испытать себя в деле подкастинга. Прослушать и скачать пилотный выпуск можете ниже:&lt;/p&gt;

&lt;p&gt;&lt;audio controls=&#34;controls&#34;&gt;
  &lt;source type=&#34;audio/mp3&#34; src=&#34;http://mobymob.podfm.ru/fjlp/1/file/podfm_mobymob_fjlp_1.mp3&#34;&gt;&lt;/source&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mobymob.podfm.ru/fjlp/1/file/podfm_mobymob_fjlp_1.mp3&#34;&gt;Загрузить&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Содержание пилотного выпуска&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;00:35&lt;/strong&gt; — Об авторе&lt;br /&gt;
&lt;strong&gt;00:58&lt;/strong&gt; — Мотивация подкаста&lt;br /&gt;
&lt;strong&gt;02:00&lt;/strong&gt; — Обобщенные темы подкаста&lt;br /&gt;
&lt;strong&gt;02:26&lt;/strong&gt; — Формат подкаста&lt;br /&gt;
&lt;strong&gt;03:00&lt;/strong&gt; — Каково быть студентом на IT специальности в ВУЗе&lt;br /&gt;
&lt;strong&gt;13:00&lt;/strong&gt; — О современной потребности в дипломе&lt;br /&gt;
&lt;strong&gt;24:32&lt;/strong&gt; — Планирование жизни&lt;br /&gt;
&lt;strong&gt;28:50&lt;/strong&gt; — О собственном развитии&lt;br /&gt;
&lt;strong&gt;30:44&lt;/strong&gt; — Поддержка окружения, конкуренция&lt;br /&gt;
&lt;strong&gt;35:06&lt;/strong&gt; — Откуда взять свободное время?&lt;br /&gt;
&lt;strong&gt;38:22&lt;/strong&gt; — Поиски лучшей жизни&lt;br /&gt;
&lt;strong&gt;41:40&lt;/strong&gt; — Инвестирование&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>