<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backends For Frontends on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/backends-for-frontends/index.xml</link>
    <description>Recent content in Backends For Frontends on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/backends-for-frontends/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Backends for Frontends</title>
      <link>https://i-osipov.ru/post/bff/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/bff/</guid>
      <description>

&lt;p&gt;Микросервисный пузырь как будто уже лопнул и все, кто поспешно применял этот взгляд на архитектуру бекенда либо канули в Лету, либо многократно пожалели о своем выборе этого тернистого пути. Пожалуй, это связано в первую очередь с бездумным разбиением кода на кучу маленьких тесно-связанных приложений, создания наносервисов и т.п. Всё это происходит из-за недостаточного количества хороших практик? Конечно нет, скорее из-за отсутствия информированности о простейших шаблонах проектирования таких систем. Здесь пойдет речь о шаблоке &amp;ldquo;бекенды для фронтендов&amp;rdquo;, но для начала давай разберемся, а в чем же проблема&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;проблема&#34;&gt;Проблема&lt;/h1&gt;

&lt;p&gt;Мы делаем софт у которого есть конечные пользователи. В случае разработки бекенда это может быть разношерстный пул клиентов. Это проблема. Клиенты должны с тобой взаимодействовать и для этого ты предоставляешь им API. Здесь довольно очевидные вещи и я не хотел бы останавливаться на них, разбирая термин API и говоря банальные вещи о том, что API должен быть документирован и удобен, не должен ломать совместимость от версии к версии (а лучше, должен версионироваться) и так далее, всё это ясно. А какие бывают клиенты? Вот тебе бытовая классификация потенциальных потребителей твоего апи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;классический веб фронтенд, написанный типично на js и работающий в браузере пользователя;&lt;/li&gt;
&lt;li&gt;мобильные клиенты, обычные приложения, которые стоят на смартфонах пользователей;&lt;/li&gt;
&lt;li&gt;GraphQL сервер между тобой и фронтендом;&lt;/li&gt;
&lt;li&gt;интеграции с различными сервисами, когда ты определяешь api, которое будут дергать какие-то внутренние системы, которые разрабатываешь не ты;&lt;/li&gt;
&lt;li&gt;внешние системы, например, какой-то другой бекенд, который написал кто-то для создания собственного сервиса, который использует тебя для части задач.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже если я что-то забыл - это не страшно, идея понятна, клиенты гетерогенные. При чем, для одних было бы здорово получать информацию по кусочкам, каждый раз дозапрашивая часть, для других нужно минимизировать количество запросов, т.к. это сажает батарейку, а для третьих нужена определенная подготовленная структура данных, потому что логика обработки запросов на той стороне обязана быть минималистичной. Всё это приводит нас к проблеме того, что нашему сервису нужно обеспечивать логику, которая подойдет одновременно всем клиентам.&lt;/p&gt;

&lt;p&gt;Какие есть варианты решения? Остановимся на нескольких клиентах, допустим у нас ожидается мобильное приложение, веб фронтенд, парочка внутренних интеграций.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-1&#34;&gt;Попытка решения 1&lt;/h1&gt;

&lt;p&gt;Давайте ничего не будем делать. Как гласят источники - иногда, ничего не делать - это лучшее решение. Поставим HTTP API, оформим для единообразия его в стиле REST (об этом была прошлая &lt;a href=&#34;../../post/rest-is-not-rpc/&#34;&gt;статья&lt;/a&gt;) и вуаля, всем подходит. Так ли это? На практике окажется, что в этом API сликом много данных для мобильных клиентов и вообще им приходится делать дюжину запросов, чтобы собрать полную картину в этом вашем REST. Внутренние интеграции будут недовольны необходимостью слишком много знать про твое API, да и вообще, не понятно как и где будут появляться специфичные для интеграции запросы. Зато веб фронтенду будет в принципе всё круто.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-2&#34;&gt;Попытка решения 2&lt;/h1&gt;

&lt;p&gt;Подумаем, можем ли мы упростить всё и поставить вместо HTTP API - GraphQL API, а уже за ним ничего не делать и снова оформить в REST стиле и попивать чай, наслаждаясь результатом? С первого взгляда создается ощущение, что да, однако, скорее всего окажется, что внутренние интеграции не захотят подобного рода взаимодействие и вообще им бы пару методов дернуть, только вот методы эти специфичные и нужны только им.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-3&#34;&gt;Попытка решения 3&lt;/h1&gt;

&lt;p&gt;Сделать толстый API Gateway, который реализует всю специфичную логику, дает возможность реализовать на нем все виды взаимодейсткий. В теории, такое решение, конечно, даст результат, однако ценой тесного связывания в одном месте большого количества несвязанной логики, более того, этот гейтвей будет нагружаться всем, чем только можно, что обязательно скажется на производительности решения.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-4&#34;&gt;Попытка решения 4&lt;/h1&gt;

&lt;p&gt;Дадим клиентам доступ напрямую к базе данных! Ладно, это шутка, никогда так не делайте, это как минимум свяжет вас по рукам и ногам.&lt;/p&gt;

&lt;h1 id=&#34;решение&#34;&gt;Решение&lt;/h1&gt;

&lt;p&gt;О том, что этот шаблон в качестве решения проблемы используют на практике многие компании (например, SoundCloud) я узнал из книги Сема Ньюмана &amp;ldquo;Создание микросервисов&amp;rdquo;. &lt;a href=&#34;../../post/building-microservices/&#34;&gt;Вот здесь&lt;/a&gt; я написал на неё обзор, ты можешь почитать. Позволь, я проиллюстрирую пример:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/bff/bff.png&#34; alt=&#34;bff&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как становится очевидно, для каждого типа клиента заводится свой BFF (Backend For Frontend), что помогает спрятать в нём все специфики связанные с потребителем API. Если возникает потребность в дублировании части логики, то следует обратить на это внимание, возможно где-то раньше был пропущен кандидат на попадание в отдельный сервис, как, например, Service AB на рисунке выше. При всём этом, сколько BFF будет в итоге - частное решение, однако, если ты видишь, что логика работы двух мобильных клиентов с одним BFF всё больше отличается, то, вероятно, это знак к разделению Mobile BFF на Android BFF и iOS BFF.&lt;/p&gt;

&lt;p&gt;Конечно, буду рад услышать то, как бы вы справлялись с этой проблемой.&lt;/p&gt;

&lt;p&gt;На почитать:&lt;br /&gt;
Сем Ньюман &amp;ldquo;Создание микросервисов&amp;rdquo;&lt;br /&gt;
&lt;a href=&#34;https://samnewman.io/patterns/architectural/bff/&#34;&gt;Backends for Frontends&lt;/a&gt; samnewman.io&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>