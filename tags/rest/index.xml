<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rest on Ivan Osipov</title>
    <link>https://i-osipov.ru/tags/rest/index.xml</link>
    <description>Recent content in Rest on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/tags/rest/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>REST is not RPC</title>
      <link>https://i-osipov.ru/post/rest-is-not-rpc/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/rest-is-not-rpc/</guid>
      <description>&lt;p&gt;Тебе не приелось слово REST? Нет, я не говорю об отдыхе, я говорю про тот самый архитектурный стиль.
Пожалуй, слишком часто я слышу о том, что у тех REST API, у этих REST API, а потом, оказывается что всё не так просто.
Здесь пойдет речь о том какой смысл в этой аббревиатуре и что в неё вкладывают все вокруг, мы вспомним идеи и посмотрим как их реализуют.&lt;/p&gt;

&lt;p&gt;Индустрия парализована. Парализована банально не правильным пониманием концепции и эхолалией. Одна хорошая идея в неправильной трактовке может принести много вреда. Всё было довольно просто, хотелось оформить всё единообразно, а получилось&amp;hellip; безобразно! Удивительно, как крайне компетентные, уважаемые люди и те попадают под власть красивых сокращений.&lt;/p&gt;

&lt;p&gt;Часто ли тебе говорили, &amp;ldquo;посмотри на REST API сервиса Х&amp;rdquo; или &amp;ldquo;у нас реализовано REST API&amp;rdquo;, ты приходил и видел, что на самом деле никакого REST API нет и в помине, обычный HTTP API, хаотичным образом разбросанные HTTP глаголы в купе с уродливыми URL. Со мной такое случалось последние несколько лет и если раньше я не особо обращал внимание на это, то спустя время ошибочная трактовка REST начала бросаться в глаза. Позволь объяснить, что я понимаю под &amp;ldquo;правильным&amp;rdquo; пониманием REST. С одной стороны, можно трактовать REST по Филдингу. Тогда, мы обязаны обеспечить следующие условия:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Клиент-серверная модель взаимодействия;&lt;/li&gt;
&lt;li&gt;Stateless;&lt;/li&gt;
&lt;li&gt;Кеширование;&lt;/li&gt;
&lt;li&gt;Единообразие интерфейса;&lt;/li&gt;
&lt;li&gt;Слоистая архитектура со стороны сервера;&lt;/li&gt;
&lt;li&gt;Код по требованию, расширяющий функциональность клиента.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Хм, многовато сложности, давай упростим и предположим, что когда говорят о REST API, то в идеале имеют ввиду соблюдение условия &amp;ldquo;4 Единообразие интерфейса&amp;rdquo;. Кстати, окинь взглядом этот список еще раз и подумай, как близко твоя система, которую ты в данный момент разрабатываешь. Я могу честно отметить, что ни в одной системе мне не приходилось реализовывать пункт 6, хотя возможно под него подойдет загрузка JS из CDN,  тогда всё в порядке.&lt;/p&gt;

&lt;p&gt;Можно выделить несколько важных пунктов о единообразии интерфейса, т.е. о создании REST API:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Явно выделенные ресурсы (например, пользователь). Метод HTTP API, который называется &amp;ldquo;/createUser&amp;rdquo; очевидно нельзя называть частью REST API - это отличный пример реализации RPC поверх HTTP. Думая о пользователях, как о ресурсах мы получаем uri, который заканчивается на &amp;ldquo;/users&amp;rdquo;. Обрати внимание, &amp;ldquo;users&amp;rdquo; это множественное число. Из собственной практики могу заключить, что такой вариант воспринимается лучше, это выглядит более естественным при запросе множества пользователей. К сожалению, не во всех проектах мне удается этому следовать, но помни, главное - единообразие. Если в большей части системы для получения множества ресурсов уже используется единственное число, лучше так и оставить - меньше будет ошибок у пользователей твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP глаголы это не просто глаголы. Во первых, REST это не обязательно про HTTP. Вот так, теперь живи с этим. Суть HTTP глаголов в REST - помочь тебе манипулировать ресурсами через их представления. Кроме очевидной логики в названиях HTTP глаголов POST, PUT. DELETE, GET, есть один важный момент который мы часто упускаем. Имя его - &lt;strong&gt;идемпотентность&lt;/strong&gt;. Тебя когда-нибудь спрашивали на собеседовании &amp;ldquo;почему для update используют глагол PUT&amp;rdquo;? Обычно, я в таких ситуациях отвечал &amp;ldquo;ну, логично же&amp;rdquo; и с этим никто не спорил, хотя есть и другое объяснение. Основное различие между PUT и POST это идемпотентность. Это обозначает, что PUT, как идемпотентный метод, можно запустить многократно с одинаковым результатом, а вот POST нельзя. Предположим, что у вас есть реализация &amp;ldquo;POST /users&amp;rdquo; и &amp;ldquo;PUT /users&amp;rdquo;, естественно, в теле запроса находится user. Если запустить первый метод 20 раз, то будет создано 20 пользователей (при условии отсутствия уникальных индексов), а если запустить 20 раз второй запрос, то результирующее состояние будет тем же, что и при первом вызове. Идемпотентность это важное свойство, которое следует соблюдать для избежания несогласованой трактовки работы твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Гипермедиа. Пункт, который на моей практике не так часто соблюдают, возможно из-за отсутствия единого стандарта, но скорее из-за лени и нежелания это поддерживать. Сама по себе концепция проста, действия определяются на сервере, т.е. ссылки которые могут повлиять на состояние системы. Кроме простых точек входа в систему могут быть и более сложные действия, которые необходимо определять. Однако, складывается впечатление, что это несколько вырожденный пункт, который сегодня перекрывается возможностями автоматически генерируемой документации.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Content-Type &amp;amp; Accept заголовки помогают понять как же именно обрабатывать запрос, что находится в его теле и какой формат ожидается в ответ. Когда у вас один веб клиент, этот пункт кажется излишним, но на практике, это хорошее ребро жесткости для API, которое позволяет получать именно то, что ожидается в ответ.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Итак, мы разобрались, что RESTful системы делает вовсе не каждый. Достаточно завести базу в которой ты будешь хранить состояние сессии и всё, по условию Stateless ты уже не проходишь. Окей, но что нам стоит построить хотя бы RESTful API? Дисциплина помогает писать в REST стиле конечные точки: правильные url, корректное использование глаголов и даже заголовки приведены в порядок. Осталось гипермедиа&amp;hellip; Один шаг и у нас по настоящему RESTful API. Что-то внутри мне подсказывает, что это непреодолимый в общем случае шаг, что это достаточно много трудозатрат ради минимального выхлопа, при том, что закрыть проблему, которую закрывает hypermedia можно и с помощью swagger, не так гибко, но всё же.&lt;/p&gt;

&lt;p&gt;В сухом остатке, по моему субъективному опыту мало кто пишет настоящий REST API, однако, мы можем довольно просто приблизиться к нему. Но зачем обманывать себя? Почему недостаточно сказать &amp;ldquo;посмотри на сервис Х у них HTTP API&amp;rdquo; или &amp;ldquo;у нас HTTP API&amp;rdquo;? Видимо, люди надеятся спрятать за словом, которое должно характеризовать надежные, производительные и масштабируемые системы, то, что они делают. Получается, даже приведение интерфейса к единообразному виду делает далеко не каждый, зато мы спешим повесить лейбл &amp;ldquo;RESTful&amp;rdquo; на свой RPC.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>