<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ivan Osipov</title>
    <link>https://i-osipov.ru/index.xml</link>
    <description>Recent content on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Fri, 26 Oct 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://i-osipov.ru/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Сделай OAuth2 - забудь о логинах и паролях</title>
      <link>https://i-osipov.ru/post/do-oauth2-forget-login-password/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/do-oauth2-forget-login-password/</guid>
      <description>&lt;p&gt;Шёл 2018 год, а люди продолжали вводить логины и пароли, снова логины и пароли, опять логины и пароли. Тебе не кажется это странным? Почему огромное количество пользователей всё еще просит своих пользователей залогиниться? Давай разберемся в этом вопросе.&lt;/p&gt;

&lt;p&gt;Мы живем в век инноваций и автоматизируем каждый чих человеческой деятельности, но что касается интернета, то тут я теряюсь в догадках. Почему очередной интернет магазин книг просит у меня логин и пароль? Почему я должен &amp;ldquo;по умолчанию&amp;rdquo; пройти регистрацию? Почему мне не дают в качестве пути по умолчанию OAuth2 от, например, Google? Всё это сбивает с толку, кажется, что очередной сайт хочет сохранить мой пароль (а самые продвинутые хотят сохранить только хеш от него), чтобы при первой хакерской атаке всё утекло в интернеты.&lt;/p&gt;

&lt;p&gt;Пароли это, пожалуй, одна из самых уязвимых частей секретной жизни человека в интернете. Как часто вы используете один и тот же пароль для разных ресурсов? Хотя бы раз вы повторялись? Как часто ваши пароли похожи на столько, что узнав один, путем недолгого перебора можно получить другой? Самые продвинутые из нас используют сервисы типа LastPass, которые хранят ваши рандомные пароли для разных ресурсов, но кажется, что таких людей не много, да и сам факт потребности в подобных сервисах заставляет задуматься.&lt;/p&gt;

&lt;p&gt;Сколько сложностей связано с регистрацией? Обычно, нужно получить email, в котором надо нажать на ссылку. А если почта на смартфоне, то порой нужно начала нажать на кнопку в телефоне, затем логиниться с ноутбука, в общем всякие реализации бывают. Да и пять сотен раз я уже подтверждал всем вокруг, что это мой email.&lt;/p&gt;

&lt;p&gt;А эти логины? Вы пробовали подобрать хороший логин для твиттера? Если только у вас редкая комбинация имени и фамилии или супер-уникальный никнейм, то всё пройдет без проблем, но это же исключения! Идея логина в том, чтобы составить пару паролю, дать дефолтное имя и позволить пользователю представить себя, но как мне представить себя, если я не помню свой логин, потому что мой стандартный был занят кем-то, а тот, что я придумал специально для этого сервиса, я уже забыл? Как мне понять при повторном логине, что именно на этом сервисе я задействовал все свои силы на подбор уникального логина?&lt;/p&gt;

&lt;p&gt;Похоже, что почта в качестве идентификатора пользователя это хорошо, но как я озвучил выше, почту нужно подтверждать, а еще их можно зарегистрировать несколько и получить много разных аккаунтов, в результате по ошибке путаться, каким из них пользоваться. Или, что если вам нужно что-то большее, например, гарантия, что это не просто &amp;ldquo;уникальный интернет пользователь&amp;rdquo;, но и в реальном мире уникальный человек? Очевидно, сегодня технически этого трудно достигнуть, инструменты есть, но эти случаи особые и к ним этот текст не имеет отношения. Квазиуникальность через номер телефона должна быть достаточна в большинстве случаев. Представляете как усложнится жизнь пользователя, если вы его и номер телефона спросите?&lt;/p&gt;

&lt;p&gt;В общем, вопросов много, давайте поищем ответ.&lt;/p&gt;

&lt;p&gt;Во всех мыслимых и немыслимых случаях я не вижу необходимости в логине, это какая-то опциональная штука от которой можно смело отказываться, например, в телеграме вы можете иметь аккаунт, но вам не обязательно иметь логин для него, например, вы можете отказаться от логина и вас по нему нельзя будет найти.&lt;/p&gt;

&lt;p&gt;Сначала, я хотел перечислить несколько интересных схем аутентификации, но потом решил, что до них можно и самим легко дойти, да и это хорошее практическое упражнение на развитие фантазии.&lt;/p&gt;

&lt;p&gt;OAuth2 решает наши проблемы. Я не буду вдаваться здесь в детали, но высокоуровнево это выглядит так: пользователь хочет войти, затем его редиректит на identity provider (например, на гугл), где он скорее всего уже залогинен, но если нет, то вводит там свои логин и пароль и подтверждает, что этому приложению можно дать доступ к данным этого пользователя. После этого его редиректит назад с кодом, который отправляется клиентом на бекенд, а бекенд обменивает код на токен и с помощью токена запрашивает данные по пользователю. Алгоритм довольно простой в реализации, со своими нюансами, но о них в другой статье, и самое главное, что в 99% случаев аутентификация сводится к нажатию на одну-две кнопки. Более того, в зависимости от identity provider ты можешь получить много разных полезных данных для твоего конкретного случая и твоего конкретного приложения, например, Google в списке информации о пользователе при указании определенного scope ты можешь получить номер телефона пользователя и сформировать таким образом квазиуникальных пользователей, или же получить полный список email этого пользователя, чтобы он мог заходить под любым из них.&lt;/p&gt;

&lt;p&gt;Identity provider хранит информацию защищёно и не даст пользователю просто так упустить свой аккаунт в чужие руки, часто поддерживается двух факторная аутентификация.&lt;/p&gt;

&lt;p&gt;А что с корпоративными системами? В случае Google, если вы работаете с G Suite, то это совсем идеальное решение, если же вы не завязаны на какой облачный офис, то вы всегда можете поднять один корпоративный OAuth сервер и ходить на него из ваших приложений для аутентификации. В любом случае, это куда удобнее, чем вводить по миллиону раз учетные данные. Хорошо, что современные браузеры уже автоматизировали процесс хранения учетных данных и использования последних, когда вам это необходимо, потому что человечество по неведомой причине не спешит отказаться от логина и пароля.&lt;/p&gt;

&lt;p&gt;Получается, если есть инструмент - OAuth2, который в пару кликов способен сделать счастливыми и пользователя, и бизнес, то почему бы им не заменить устаревший, неудобный, менее безопасный способ использования логинов и паролей?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Backends for Frontends</title>
      <link>https://i-osipov.ru/post/bff/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/bff/</guid>
      <description>

&lt;p&gt;Микросервисный пузырь как будто уже лопнул и все, кто поспешно применял этот взгляд на архитектуру бекенда либо канули в Лету, либо многократно пожалели о своем выборе этого тернистого пути. Пожалуй, это связано в первую очередь с бездумным разбиением кода на кучу маленьких тесно-связанных приложений, создания наносервисов и т.п. Всё это происходит из-за недостаточного количества хороших практик? Конечно нет, скорее из-за отсутствия информированности о простейших шаблонах проектирования таких систем. Здесь пойдет речь о шаблоке &amp;ldquo;бекенды для фронтендов&amp;rdquo;, но для начала давай разберемся, а в чем же проблема&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;проблема&#34;&gt;Проблема&lt;/h1&gt;

&lt;p&gt;Мы делаем софт у которого есть конечные пользователи. В случае разработки бекенда это может быть разношерстный пул клиентов. Это проблема. Клиенты должны с тобой взаимодействовать и для этого ты предоставляешь им API. Здесь довольно очевидные вещи и я не хотел бы останавливаться на них, разбирая термин API и говоря банальные вещи о том, что API должен быть документирован и удобен, не должен ломать совместимость от версии к версии (а лучше, должен версионироваться) и так далее, всё это ясно. А какие бывают клиенты? Вот тебе бытовая классификация потенциальных потребителей твоего апи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;классический веб фронтенд, написанный типично на js и работающий в браузере пользователя;&lt;/li&gt;
&lt;li&gt;мобильные клиенты, обычные приложения, которые стоят на смартфонах пользователей;&lt;/li&gt;
&lt;li&gt;GraphQL сервер между тобой и фронтендом;&lt;/li&gt;
&lt;li&gt;интеграции с различными сервисами, когда ты определяешь api, которое будут дергать какие-то внутренние системы, которые разрабатываешь не ты;&lt;/li&gt;
&lt;li&gt;внешние системы, например, какой-то другой бекенд, который написал кто-то для создания собственного сервиса, который использует тебя для части задач.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже если я что-то забыл - это не страшно, идея понятна, клиенты гетерогенные. При чем, для одних было бы здорово получать информацию по кусочкам, каждый раз дозапрашивая часть, для других нужно минимизировать количество запросов, т.к. это сажает батарейку, а для третьих нужена определенная подготовленная структура данных, потому что логика обработки запросов на той стороне обязана быть минималистичной. Всё это приводит нас к проблеме того, что нашему сервису нужно обеспечивать логику, которая подойдет одновременно всем клиентам.&lt;/p&gt;

&lt;p&gt;Какие есть варианты решения? Остановимся на нескольких клиентах, допустим у нас ожидается мобильное приложение, веб фронтенд, парочка внутренних интеграций.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-1&#34;&gt;Попытка решения 1&lt;/h1&gt;

&lt;p&gt;Давайте ничего не будем делать. Как гласят источники - иногда, ничего не делать - это лучшее решение. Поставим HTTP API, оформим для единообразия его в стиле REST (об этом была прошлая &lt;a href=&#34;../../post/rest-is-not-rpc/&#34;&gt;статья&lt;/a&gt;) и вуаля, всем подходит. Так ли это? На практике окажется, что в этом API сликом много данных для мобильных клиентов и вообще им приходится делать дюжину запросов, чтобы собрать полную картину в этом вашем REST. Внутренние интеграции будут недовольны необходимостью слишком много знать про твое API, да и вообще, не понятно как и где будут появляться специфичные для интеграции запросы. Зато веб фронтенду будет в принципе всё круто.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-2&#34;&gt;Попытка решения 2&lt;/h1&gt;

&lt;p&gt;Подумаем, можем ли мы упростить всё и поставить вместо HTTP API - GraphQL API, а уже за ним ничего не делать и снова оформить в REST стиле и попивать чай, наслаждаясь результатом? С первого взгляда создается ощущение, что да, однако, скорее всего окажется, что внутренние интеграции не захотят подобного рода взаимодействие и вообще им бы пару методов дернуть, только вот методы эти специфичные и нужны только им.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-3&#34;&gt;Попытка решения 3&lt;/h1&gt;

&lt;p&gt;Сделать толстый API Gateway, который реализует всю специфичную логику, дает возможность реализовать на нем все виды взаимодейсткий. В теории, такое решение, конечно, даст результат, однако ценой тесного связывания в одном месте большого количества несвязанной логики, более того, этот гейтвей будет нагружаться всем, чем только можно, что обязательно скажется на производительности решения.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-4&#34;&gt;Попытка решения 4&lt;/h1&gt;

&lt;p&gt;Дадим клиентам доступ напрямую к базе данных! Ладно, это шутка, никогда так не делайте, это как минимум свяжет вас по рукам и ногам.&lt;/p&gt;

&lt;h1 id=&#34;решение&#34;&gt;Решение&lt;/h1&gt;

&lt;p&gt;О том, что этот шаблон в качестве решения проблемы используют на практике многие компании (например, SoundCloud) я узнал из книги Сема Ньюмана &amp;ldquo;Создание микросервисов&amp;rdquo;. &lt;a href=&#34;../../post/building-microservices/&#34;&gt;Вот здесь&lt;/a&gt; я написал на неё обзор, ты можешь почитать. Позволь, я проиллюстрирую пример:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/bff/bff.png&#34; alt=&#34;bff&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как становится очевидно, для каждого типа клиента заводится свой BFF (Backend For Frontend), что помогает спрятать в нём все специфики связанные с потребителем API. Если возникает потребность в дублировании части логики, то следует обратить на это внимание, возможно где-то раньше был пропущен кандидат на попадание в отдельный сервис, как, например, Service AB на рисунке выше. При всём этом, сколько BFF будет в итоге - частное решение, однако, если ты видишь, что логика работы двух мобильных клиентов с одним BFF всё больше отличается, то, вероятно, это знак к разделению Mobile BFF на Android BFF и iOS BFF.&lt;/p&gt;

&lt;p&gt;Конечно, буду рад услышать то, как бы вы справлялись с этой проблемой.&lt;/p&gt;

&lt;p&gt;На почитать:&lt;br /&gt;
Сем Ньюман &amp;ldquo;Создание микросервисов&amp;rdquo;&lt;br /&gt;
&lt;a href=&#34;https://samnewman.io/patterns/architectural/bff/&#34;&gt;Backends for Frontends&lt;/a&gt; samnewman.io&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REST is not RPC</title>
      <link>https://i-osipov.ru/post/rest-is-not-rpc/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/rest-is-not-rpc/</guid>
      <description>&lt;p&gt;Тебе не приелось слово REST? Нет, я не говорю об отдыхе, я говорю про тот самый архитектурный стиль.
Пожалуй, слишком часто я слышу о том, что у тех REST API, у этих REST API, а потом, оказывается что всё не так просто.
Здесь пойдет речь о том какой смысл в этой аббревиатуре и что в неё вкладывают все вокруг, мы вспомним идеи и посмотрим как их реализуют.&lt;/p&gt;

&lt;p&gt;Индустрия парализована. Парализована банально не правильным пониманием концепции и эхолалией. Одна хорошая идея в неправильной трактовке может принести много вреда. Всё было довольно просто, хотелось оформить всё единообразно, а получилось&amp;hellip; безобразно! Удивительно, как крайне компетентные, уважаемые люди и те попадают под власть красивых сокращений.&lt;/p&gt;

&lt;p&gt;Часто ли тебе говорили, &amp;ldquo;посмотри на REST API сервиса Х&amp;rdquo; или &amp;ldquo;у нас реализовано REST API&amp;rdquo;, ты приходил и видел, что на самом деле никакого REST API нет и в помине, обычный HTTP API, хаотичным образом разбросанные HTTP глаголы в купе с уродливыми URL. Со мной такое случалось последние несколько лет и если раньше я не особо обращал внимание на это, то спустя время ошибочная трактовка REST начала бросаться в глаза. Позволь объяснить, что я понимаю под &amp;ldquo;правильным&amp;rdquo; пониманием REST. С одной стороны, можно трактовать REST по Филдингу. Тогда, мы обязаны обеспечить следующие условия:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Клиент-серверная модель взаимодействия;&lt;/li&gt;
&lt;li&gt;Stateless;&lt;/li&gt;
&lt;li&gt;Кеширование;&lt;/li&gt;
&lt;li&gt;Единообразие интерфейса;&lt;/li&gt;
&lt;li&gt;Слоистая архитектура со стороны сервера;&lt;/li&gt;
&lt;li&gt;Код по требованию, расширяющий функциональность клиента.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Хм, многовато сложности, давай упростим и предположим, что когда говорят о REST API, то в идеале имеют ввиду соблюдение условия &amp;ldquo;4 Единообразие интерфейса&amp;rdquo;. Кстати, окинь взглядом этот список еще раз и подумай, как близко твоя система, которую ты в данный момент разрабатываешь. Я могу честно отметить, что ни в одной системе мне не приходилось реализовывать пункт 6, хотя возможно под него подойдет загрузка JS из CDN,  тогда всё в порядке.&lt;/p&gt;

&lt;p&gt;Можно выделить несколько важных пунктов о единообразии интерфейса, т.е. о создании REST API:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Явно выделенные ресурсы (например, пользователь). Метод HTTP API, который называется &amp;ldquo;/createUser&amp;rdquo; очевидно нельзя называть частью REST API - это отличный пример реализации RPC поверх HTTP. Думая о пользователях, как о ресурсах мы получаем uri, который заканчивается на &amp;ldquo;/users&amp;rdquo;. Обрати внимание, &amp;ldquo;users&amp;rdquo; это множественное число. Из собственной практики могу заключить, что такой вариант воспринимается лучше, это выглядит более естественным при запросе множества пользователей. К сожалению, не во всех проектах мне удается этому следовать, но помни, главное - единообразие. Если в большей части системы для получения множества ресурсов уже используется единственное число, лучше так и оставить - меньше будет ошибок у пользователей твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP глаголы это не просто глаголы. Во первых, REST это не обязательно про HTTP. Вот так, теперь живи с этим. Суть HTTP глаголов в REST - помочь тебе манипулировать ресурсами через их представления. Кроме очевидной логики в названиях HTTP глаголов POST, PUT. DELETE, GET, есть один важный момент который мы часто упускаем. Имя его - &lt;strong&gt;идемпотентность&lt;/strong&gt;. Тебя когда-нибудь спрашивали на собеседовании &amp;ldquo;почему для update используют глагол PUT&amp;rdquo;? Обычно, я в таких ситуациях отвечал &amp;ldquo;ну, логично же&amp;rdquo; и с этим никто не спорил, хотя есть и другое объяснение. Основное различие между PUT и POST это идемпотентность. Это обозначает, что PUT, как идемпотентный метод, можно запустить многократно с одинаковым результатом, а вот POST нельзя. Предположим, что у вас есть реализация &amp;ldquo;POST /users&amp;rdquo; и &amp;ldquo;PUT /users&amp;rdquo;, естественно, в теле запроса находится user. Если запустить первый метод 20 раз, то будет создано 20 пользователей (при условии отсутствия уникальных индексов), а если запустить 20 раз второй запрос, то результирующее состояние будет тем же, что и при первом вызове. Идемпотентность это важное свойство, которое следует соблюдать для избежания несогласованой трактовки работы твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Гипермедиа. Пункт, который на моей практике не так часто соблюдают, возможно из-за отсутствия единого стандарта, но скорее из-за лени и нежелания это поддерживать. Сама по себе концепция проста, действия определяются на сервере, т.е. ссылки которые могут повлиять на состояние системы. Кроме простых точек входа в систему могут быть и более сложные действия, которые необходимо определять. Однако, складывается впечатление, что это несколько вырожденный пункт, который сегодня перекрывается возможностями автоматически генерируемой документации.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Content-Type &amp;amp; Accept заголовки помогают понять как же именно обрабатывать запрос, что находится в его теле и какой формат ожидается в ответ. Когда у вас один веб клиент, этот пункт кажется излишним, но на практике, это хорошее ребро жесткости для API, которое позволяет получать именно то, что ожидается в ответ.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Итак, мы разобрались, что RESTful системы делает вовсе не каждый. Достаточно завести базу в которой ты будешь хранить состояние сессии и всё, по условию Stateless ты уже не проходишь. Окей, но что нам стоит построить хотя бы RESTful API? Дисциплина помогает писать в REST стиле конечные точки: правильные url, корректное использование глаголов и даже заголовки приведены в порядок. Осталось гипермедиа&amp;hellip; Один шаг и у нас по настоящему RESTful API. Что-то внутри мне подсказывает, что это непреодолимый в общем случае шаг, что это достаточно много трудозатрат ради минимального выхлопа, при том, что закрыть проблему, которую закрывает hypermedia можно и с помощью swagger, не так гибко, но всё же.&lt;/p&gt;

&lt;p&gt;В сухом остатке, по моему субъективному опыту мало кто пишет настоящий REST API, однако, мы можем довольно просто приблизиться к нему. Но зачем обманывать себя? Почему недостаточно сказать &amp;ldquo;посмотри на сервис Х у них HTTP API&amp;rdquo; или &amp;ldquo;у нас HTTP API&amp;rdquo;? Видимо, люди надеятся спрятать за словом, которое должно характеризовать надежные, производительные и масштабируемые системы, то, что они делают. Получается, даже приведение интерфейса к единообразному виду делает далеко не каждый, зато мы спешим повесить лейбл &amp;ldquo;RESTful&amp;rdquo; на свой RPC.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Книга: Создание микросервисов</title>
      <link>https://i-osipov.ru/post/building-microservices/</link>
      <pubDate>Fri, 07 Sep 2018 23:59:28 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/building-microservices/</guid>
      <description>

&lt;p&gt;Параллельно с прослушиванием аудиокниг я не расстаюсь с классическим форматом. Не всегда удается читать бумажную версию, благо, гаджеты сегодня не отстают. На днях я закончил книгу, которую начал читать еще в январе этого года, но спустя время прервался и вот, в связи с новым местом работы и новыми задачами книга стала для меня снова актуальна - книга &lt;a href=&#34;https://www.ozon.ru/context/detail/id/135199296/&#34; target=&#34;_blank&#34;&gt;Создание микросервисов&lt;/a&gt;  от автора Сэма Ньюмана.&lt;/p&gt;

&lt;h3 id=&#34;об-авторе&#34;&gt;Об авторе&lt;/h3&gt;

&lt;p&gt;Ты не знаешь кто такой автор? Не беда! Знаешь Мартина Фаулера? Да, того мужика, который топит за Рефакторинг, Шаблоны корпоративных приложений и UML (это всё его книжки), ну и конечно за микросервисы в своем блоге. Так вот, Сэм и Мартин работают в одной конторе ThoughtWorks. На сколько я понимаю, эти ребята занимаются консалтингом в построении всяких разных систем и в использовании микросервисных архитектур. Занятная работенка. Между делом ребята пишут книги, вот сегодня и поговорим про одну из них.&lt;/p&gt;

&lt;h3 id=&#34;обзор&#34;&gt;Обзор&lt;/h3&gt;

&lt;p&gt;Сразу скажу, впечатления от книги хорошие. На многие вопросы она дает ответы, но не на все. Такс, давай по порядку.&lt;/p&gt;

&lt;p&gt;Прежде всего я для себя усвоил из книги интересную и, пожалуй, самую главную мысль. Твои и мои системы будут падать, обязательно будут падать. Вот так, без этого в нашем производстве никак. Сэм обращает внимание на одну забавную вещь. В действительности среди наших коллег можно наблюдать Архитекторов, Инженеров и другие громкие названия должностей, при том, что это всё заимствованные слова из других профессий. Архитектор софта и архитектор здания или моста это совершенно несравнимые люди. За архитекторами, которые проектируют очередной мост, стоит огромная история, тонна знаний, которые передаются из века в век, снова и снова. Какой релевантный багаж у наших архитекторов, ну, например, банковских систем? 20-40 лет? В масштабах реальной архитектуры это практически ничто. Мы пытаемся навешать ярлыков, чтобы ощутить ложное чувство защищенности, но от правды никуда не скроешься. Наши системы обязательно будут где-то падать, где-то работать не так как ожидалось и это нормально, для текущего этапа прогресса, это вполне приемлемо. Наша же задача, быть к этому готовыми. В общем, мне нравится эта мысль, особенно на фоне прочтения статей о &lt;a href=&#34;https://en.wikipedia.org/wiki/Crash-only_software&#34; target=&#34;_blank&#34;&gt;crash-only software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Второй, важный пункт, который отмечает автор - это моделирование сервисов на основе ограниченных контекстов. Я не буду углубляться в детали, но об этом можно думать как о моделировании опираясь на бизнес потебности, а не на технологии. Например, автор описывает жуткую луковую архитектуру, где разделение проходит по технологической грани, т.е., например, для работы с общей базой данных создают отдельный сервис. Как верно замечает автор, от луковой архитектуры хочется плакать.&lt;/p&gt;

&lt;p&gt;Здесь правильнее же разбивать сервисы на слабо связанные (минимально зависимые) системы с сильным зацеплением. Это значит, что сервисы должны по минимуму соприкасаться и при этом функции, которые обеспечивают взаимодействие должны покрывать потребности по максимуму. Я сформировал некоторое представление о том, как должна развиваться микросервисная архитектура начиная с нуля и заканчивая продакшен окружением, с чего она должна начинаться и куда двигаться. И, хотя, сначала я хотел описать это здесь, решил, что это большая тема для отдельной статьи.
&lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;Подписывайтесь&lt;/a&gt; чтобы не пропустить.&lt;/p&gt;

&lt;p&gt;Пара важных паттернов, которые вы встретите в книге, это Backends for Frontends и Tolerant Reader. Про последний я уже писал вот &lt;a href=&#34;https://i-osipov.ru/post/apostels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;.  Backends for Frontends это когда вы под кажный тип клиента имеете по сути свой gateway, который контролирует объем данных, необходимый этому виду клиента, например, когда нам нужно получить данные на мобильный клиент их, во-первых, должно быть по минимуму, во-вторых, для экономии батареи устройства использовать минимум запросов. Дроссель - это еще один интересный паттерн, который описывает автор, как полезный подход при миграции с legacy систем.&lt;/p&gt;

&lt;p&gt;Многие вещи довольно очевидны, как мне кажется, но когда ты видишь подтверждение собственных мыслей в виде паттернов, то на душе становится легче.&lt;/p&gt;

&lt;p&gt;Помните, что не стоит спешить плодить нано-сервисы, т.к. ни к чему хорошему это не приведет. Растите сервис, а когда внутри него сформируются собственные домены, то это хороший знак, чтобы разбить сервис на две независимых части, кстати, как это сделать в книжке тоже рассказывается.&lt;/p&gt;

&lt;p&gt;Разделы о развертывании и тестировании хорошо пересекаются с видео, которое я упоминал на своем &lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;телеграм канале&lt;/a&gt;&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/K1l8717tN2c&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Достаточно плотно автор обрисовал масштабирование микросервисов. Представил различные способы, в том числе и упреждающие, для мониринга и локализации проблем в микросервисной архитектуре, например, прокидывание ID запроса по всей цепочке вызовов для удобного дальнейшего поиска по логам.&lt;/p&gt;

&lt;p&gt;Из недостатков, я не увидел практически никакой информации о том какие практики используются для авторизации действий пользователей в системе. JWT токен был упомянут единожды вскользь. Как автор администрировал одновременно множество сервисов также остается загадкой, возможно никак. Хотя у меня есть представление как реализовать всё, что меня интересует, в книге этой информации нет.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Я не претендую на роль лучшего обзорщика книг этого года, но хотел в первую очередь поделиться с вами впечатлениями о книге. Резюмируя вышесказанное: книга хороша, особенно, если вы не знаете как подобраться к задаче проектирования микросервисной архитектуры, в таком случае книга точно для вас. Больше всего, сама книга напоминает обзор возможных действий и вариантов реализации при проектировании микросервисных систем, к счастью, автор упоминает достаточное обилие тулов, которые упрощают жизнь. Уже сформировал себе список инструментов с которыми еще предстоит познакомится. В целом, рекомендую к прочтению, особенно, если ты на стороне бекенда.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to: переехать из Самары в Спб за 10 дней</title>
      <link>https://i-osipov.ru/post/my-relocation/</link>
      <pubDate>Sat, 25 Aug 2018 14:00:00 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/my-relocation/</guid>
      <description>

&lt;p&gt;Уфф, последний месяц как год жизни. Я не говорил, что мы с женой переехали из Самары в Санкт-Петербург? Нет? Ну, значит об этом я сегодня тебе и расскажу. Ты когда-нибудь искал чего-то большего в IT? Мы, программисты, работаем, постоянно учимся, развиваемся, но иногда хочется чего-то большего, хочется сделать серьёзный шаг вперед, сделать что-то такое, чего не делал раньше. В прошлом это подстегнуло меня отправиться выступать на JPoint, а сегодня поселиться в одном из районов г. Санкт-Петербург. Люблю такие моменты, что-то тебе кажется нереальным, сложным, невозможным, а ты берешь и раскладываешь это в набор шагов, последовательно выполняешь их и всё удается. Вся эта история приобрела определенный оттенок неопределенности, из-за нашего ожидания ребенка.&lt;/p&gt;

&lt;p&gt;Думаю, будет правильным разбить мой рассказ на несколько частей:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Предыстория&lt;/li&gt;
&lt;li&gt;В DataScience и обратно&lt;/li&gt;
&lt;li&gt;Поиск работы&lt;/li&gt;
&lt;li&gt;Переезд&lt;/li&gt;
&lt;li&gt;Поиск квартиры&lt;/li&gt;
&lt;li&gt;Адаптация на новом месте&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;предыстория&#34;&gt;Предыстория&lt;/h2&gt;

&lt;p&gt;Я начну с предыстории, но так как тебе не обязательно всё это читать, то ты можешь смело двигаться дальше. Мы с женой задумались о переезде пару лет назад, пока я был в поиске работы. Зачем? Этот вопрос мы задавали себе много раз&amp;hellip; Очень много раз! Проверка границ собственных возможностей, новый опыт, новые знакомства, новые приключения, ну и это просто прикольно, так делают далеко не все. Тогда, идею с переездом мы спустили на тормозах, приморозили, я получил &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; офферов в Самаре и решил остановиться на одном из вариантов, который, честно признаться, для меня тогда был в приоритете.&lt;/p&gt;

&lt;p&gt;Следующие 2 года в Самаре я работал в компании Haulmont, по моему скромному мнению, для такого человека как я это лучшее место в городе, если ты из Самары, то обязательно спросишь почему. Из крупных игроков у нас есть epam, сбертех, netcracker, но похоже я не хочу работать в крупных компаниях. Haulmont меньше, уютнее чтоли. Они показали мне хороший пример разработки веб приложений, шаблонов реализаций стандартных фич в платформе Cuba на которой строятся практически все решения компании. Я работал в бизнес юните Bespoke, там я занимался системами планирования большую часть своего времени и делал это для внешних заказчиков. Типичная backend разработка тоже не обошла меня стороной, но я чертовски полюбил эти планировщики и алгоритмы, которые крутятся за кулисами.&lt;/p&gt;

&lt;p&gt;Чуть меньше года мы снимали квартиру в 5 минутах пешком от офиса. Ох, это было прекрасное время, я никогда не чувствовал такого спокойствия по пути домой. Никаких маршруток, автобусов, ты просто прогуливаешься до соседнего дома. Единственный минус, у меня не было никакого времени на прослушивание аудио книг, которые я последнее время предпочитаю классическим. Мы снимали квартиру у пары, которая также в ожидании ребенка умчалась в Израиль, чтобы глава семейства изучал Java (забавное совпадение). Это была отличная демонстрация для нас того, что при желании никаких преград не существует, ну а я рассказываю эту историю, для тех у кого таких примеров не было.&lt;/p&gt;

&lt;h2 id=&#34;в-datascience-и-обратно&#34;&gt;В DataScience и обратно&lt;/h2&gt;

&lt;p&gt;Признаюсь открыто, я как и многие разработчики мечтал работать в JetBrains. Еще 2-3 года назад я задумался об этом. Ребята делают классный тулинг, я просто обязан был попасть к ним! Но тогда у меня было недостаточно лет стажа для этой компании. Забавно, что тогда, если я правильно помню они еще искали middle разработчиков и я думал о том, что &amp;ldquo;вырасту&amp;rdquo; и отправлюсь покорять северную столицу. Ха! Прошло 3 года, а их потребности выросли. Благо, и я не стоял на месте. К моменту начала поиска работы я заинтересовался DataScience, прошел солидную часть платных курсов на курсере и всерьез задумался, не сменить ли мне направление. На hh.ru я заметил вакансию на новый продукт, как раз в области DataScience и понял, что это мой шанс. Закинул резюме и начал общаться с HR, по каким-то причинам этот процесс затянулся на месяц. Надеюсь, что это частный случай, который коснулся только меня. Сначала мы пообщались с менеджером продукта, это довольно известный в тусовке DataScientist (я не спрашивал разрешения у людей для раскрытия их имен, по этому пусть все имена останутся тайной). Всё прошло хорошо и после очень долгого ожидания, мне назначили техническое интервью. Это был одновременно и счастливый и несчастный момент моей жизни. Счастливый, потому что я наконец-то попал на интервью в компании в которой давно мечтал работать. Почему несчастный? В ходе интервью я понял, что совершенно ничего не знаю о разработке тулинга, по крайней мере на том уровне, на котором это нужно. Это же поставило внутри меня под сомнение желание там работать, которое дремало где-то три года и пробудилось, чтобы исчезнуть. Вот так просто, наши дорожки разошлись, возможно не на всегда, но я благодарен ребятам, за то что помогли ценой своего времени в этом разобраться. Одновременно с этим во мне начал угасать интерес к DataScience до уровня &amp;ldquo;просто интересно&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;В Питере был запасной вариант - Яндекс. О них очень кратко, Яндекс мне показал пример таких собеседований, в которых я не хочу участвовать никогда, таким образом помог мне сформировать критерии отсева потенциальных работодателей, которые хотят пообщаться. Критерии очень простые, если компания пытается оценить тебя по балам прежде чем с тобой поговорят - к черту такие компании, в таком процессе собеседований нет души, если компания дает тебе задачки из серии спортивного программирования и хочет от тебя решения на время - к черту такие компании. В общем, спасибо Яндексу.&lt;/p&gt;

&lt;h2 id=&#34;поиск-работы&#34;&gt;Поиск работы&lt;/h2&gt;

&lt;p&gt;К моменту, когда я закончил общение с компаниями упомянутыми выше пришла пора моего отпуска. Я помню, был вечер, мы с женой сидели на кухне, пили чай и обсуждали потенциальный переезд, который не сложился, думали о том, что надо подождать рождения ребенка и переезжать только в следующем году. В тот момент, что-то внутри щелкнуло и я решил хотя бы взглянуть на остальные вакансии в Спб. Были посредственные, но были и реально интересные (к счастью всё сложилось с одной из компаний в начале моего топ списка). Тогда я решил для себя, что наберу пул вакансий и устрою интенсивную неделю созвонов. Это было не просто, но и не так сложно как бывает у других. Я конечно не ощущал себя в call центре, но по 3 созвона в день с разными незнакомыми людьми прививают некоторые навыки общения, при этом они разбавляются выполнением тестовых заданий. Мне понравились собеседования на английском, они дают очередное подтверждение, что 2 года изучения языка не прошли зря. Ты спросишь: &amp;ldquo;а какие вопросы задавали на собеседованиях?&amp;rdquo;. Конечно, везде по разному, но мне понравился процесс, например, в nexign. Сначала тебя опрашивают по основам в формате блица - быстрый вопрос, быстрый ответ, а наследующем собеседовании уже детально. Далеко не везде, у вас будут спрашивать задротские вопросы типа методы класса Object, но к сожалению, такие компании есть. Люди просто следуют протоколу, возможно у них нет выбора. На собеседованиях часто можно вскрыть пробелы в понимании каких-то деталей реализации, к счастью эти пробелы очень легко закрыть. Почти из каждого собеседования я выносил для себя список того о чем почитать, какие знания нужно добрать, это хорошо и интенсивно прокачивает. Например, теперь я знаю, что ext3 отличается от ext2 наличием журналирования, не знаю зачем мне это знание, но вдруг пригодится.&lt;/p&gt;

&lt;p&gt;На каждом из собеседований мне приходилось объяснять, что мы ждем ребенка и у меня ограничены сроки на принятие решения и переезд. К моему удивлению hr часто были готовы изменить процесс интервью для моей ситуации, это было приятно видеть, хотя и где-то я настоял на том, что хочу пройти их первичное тестирование (мне важно было понять будет ли компания тупо смотреть на баллы или в случае ошибок захочет их обсудить). В общем, следуя критериям, которые были сформированы раньше, я для себя отсеял ряд компаний и нашел ту самую, куда устроился и вот уже 3 недели работаю.&lt;/p&gt;

&lt;h2 id=&#34;переезд&#34;&gt;Переезд&lt;/h2&gt;

&lt;p&gt;Тебя наверно интересуют детали и шаги действий, так и быть. Ты получил оффер, принял его и если компания не организует ничего, а только оплачивает, то ты в такой же ситуации как и мы. Прежде всего запомни - списки - это твои лучшие друзья. Переезд в другой город затея не сложная, если всё грамотно организовать. Я буду описывать ситуацию, когда ты съезжаешь из съемной квартиры в съемную в другом городе. Будь готов к тому, что всё будет происходить очень быстро, но не забывай иногда останавливаться и оглянуться. В этот момент ты осознаешь всю простоту ситуации, то что никакой магии нет, это обычная реальность и происходит именно с тобой, находится под твоим контролем и следует твоему плану.&lt;/p&gt;

&lt;p&gt;Итак, как я сказал, оффер принят, что дальше? Составь список кому сообщить о переезде. На первом месте, по моему личному мнению должен быть твой текущий работодатель, т.к. именно от него многое зависит. В моем случае, я находился в трёхнедельном отпуске и всё было довольно просто, фактически я не вышел из отпуска. Инициируй выезд из квартиры, скажи о намерениях арендодателю и наконец можешь рассказывать родственникам и друзьям. В любом случае обязательно спланируй следующую неделю, нам хватило 10 дней на переезд, от момента принятия оффера до приземления в аэропорту Пулково. Плюс три дня на въезд в новую квартиру. Если план готов, то можно покупать билеты в одну сторону.&lt;/p&gt;

&lt;p&gt;Скорее всего у тебя есть некоторый объем вещей, который ты хочешь перевезти с собой. Для них понадобятся коробки и мешки. Здесь нужно оценить объем и отправиться, например в leroymerlin, там есть строительные мешки для мусора (подойдут для транспортировки мягких вещей) и коробки средние и маленькие, это для вещей, которые не хочется запылить в ходе переезда. Учти, что у компаний перевозчиков довольно пыльная работа и если ты как-то специально не защитишь свои коробки и мешки сам, то они обязательно покроются слоем транспортировочной пыли (особый вид пыли, который неизвестно откуда берется). Некоторые вещи могут не проходить по габаритам коробок, на этот случай транспортные компании предлагают жесткие упаковки, т.е. по сути часть твоего груза отделят деревянным каркасом от всего остального. Мы обратились в компанию ПЭК и получили честный результат, то, что имело жесткую упаковку приехало целым и невредимым, а вот те, коробки, которые не защищали были разбомблены, но функцию свою всё еще выполняли. Зато их было не жалко утилизировать. Не скупись на скотч и обязательно качественно проклей коробки (в интернете есть гайды). Суммарно в нашем случае транспортировка вещей из квартиры в Самаре (с выносом) в квартиру к Санкт-Петербурге (с доставкой в квартиру) обошлась нам меньше чем в 8к рублей, очевидно, что в твоем случае цифра будет иная, но люди любят цифры, даже если они ни о чем объективно не скажут. Из Самары в Питер вещи едут около недели или быстрее, про твой конкретный случай ты можешь уточнять на сайтах перевозчиков.&lt;/p&gt;

&lt;p&gt;Транспортируемые вещи можно разделить на пять категорий:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Вещи первой необходимости и документы (это то, что ты возьмешь в ручную кладь)&lt;/li&gt;
&lt;li&gt;Вещи на первое время жизни в другом городе (это чемоданы, как будто в отпуск)&lt;/li&gt;
&lt;li&gt;Оставшиеся вещи, которые приедут (то барахло с которым ты почему-то не смог расстаться)&lt;/li&gt;
&lt;li&gt;Вещи которые остаются (то барахло с которым ты смог расстаться, но не захотел выкидывать)&lt;/li&gt;
&lt;li&gt;Вещи которые выбрасываются (очевидно)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Для каждого пункта, кроме последнего должен быть свой список.
Планируй время так, чтобы успеть убедиться, что всё что нужное сложено в коробки, т.к. они уедут вперед тебя. Сложив коробки, нужно убедиться, что вещи для чемоданов и ручной клади умещаются.&lt;/p&gt;

&lt;p&gt;Куда отправлять вещи, если квартиры еще нет? В случае с ПЭК я отправил всё в терминал, а когда мне сообщили о их прибытии, я заказал доставку на адрес квартиры, которую только что снял. Об этом позже.&lt;/p&gt;

&lt;p&gt;Открепи ОМС, обычно это можно сделать в поликлинике, там сидят представители страховой.&lt;/p&gt;

&lt;p&gt;Сам переезд не что иное, как сдача прежней квартиры, ожидание самолета и перелет. Не обязательно иметь уже арендованную квартиру на месте, покупать кота в мешке никто не хочет, по этому придется побегать в первые дни.&lt;/p&gt;

&lt;p&gt;Заранее продумай как ты будешь перемещаться. В Спб есть карта &amp;ldquo;Подорожник&amp;rdquo; - это хороший вариант для общественного транспорта. Можно купить 40 поездок в метро на 30 дней, но кажется, что выгоднее купить пустую карту в терминале , а затем закинуть на неё денег, как я понял, там есть несколько вариантов её работы.&lt;/p&gt;

&lt;h2 id=&#34;поиск-квартиры&#34;&gt;Поиск квартиры&lt;/h2&gt;

&lt;p&gt;Есть категория людей, которые говорят, что авито - это сплошной развод. Так вот, игнорируй этот спам. Мы сняли квартиру через авито. Вообще на этом рынке есть целый набор сервисов:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Авито&lt;/li&gt;
&lt;li&gt;Циан&lt;/li&gt;
&lt;li&gt;Локалс&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Если ты готов платить деньги за подбор квартиры, то любой вариант устроит. Мы хотели поискать квартиру сами и если что-то пойдет не так, то всегда можно обратиться к риелтору. К счастью, через авито + мессенджеры мы оперативно могли спрашивать информацию у арендодателей. Подготовь список вопросов, которые для тебя важны в новом жилье и задавай его. Наш самолет приземлился рано утром, первые несколько дней мы гостили у родственников, но уже на второй день прибывания в СПБ договорились об аренде. Цена аренды везде разная, её можно посмотреть и в сервисах, которые я перечислил выше. В приложении авито можно сохранить поиск, а когда вы зайдете очередной раз в приложение, то увидите, что появилось новое объявление по вашему запросу. Авто оповещений вроде нет.&lt;/p&gt;

&lt;p&gt;Регистрация - это больно. При переезде для некоторых формальных вещей, например, постановки на учет в военкомат нужна временная регистрация. К сожалению, большинство наших сограждан не отличают временную регистрацию от постоянной, а постоянную называют пропиской. Подобные вопросы решаются индивидуально. К счастью, для прикрепления ОМС регистрация не требуется и для поликлиник тоже. Вообще, пока вы не купите автомобиль, не захотите получить визу или срочно встать на учет в военкомат она вам будет не к спеху, но по закону без неё можно жить в городе не более 90 дней. Строго говоря, для получения временной регистрации достаточно договора аренды.&lt;/p&gt;

&lt;p&gt;Как и везде с тебя обязательно попросят залог за квартиру в размере стоимости одного месяца аренды, т.е. если аренда стоит 30к, то нужно заготовить 60к для того, чтобы просто въехать. Часто можно договориться о рассрочке залога на несколько месяцев, например, ты первые 3 месяца платишь по 40к, таким образом спустя время формируется залог. Предварительно попроси договор аренды, это нужно для того, чтобы была возможность сделать правки в нём заранее. Убедись, что в нём прописано то, что при незапланированном выселении, тебя должны предупредить за месяц, так ты подстрахуешься и всем будет спокойнее. Убедись, что в договоре отмечено, что арендатор не может посещать квартиру чаще раза в месяц или того срока, который тебя устроит. Помни, что ты арендуешь собственность, на время аренды - квартира твоя и хотя со стороны арендатора ожидаемы визиты для его спокойствия - это твоё жильё, за которое ты заплатил деньги. Желательно, отметить в договоре кто с тобой будет снимать это жильё, например, жена.&lt;/p&gt;

&lt;h2 id=&#34;адаптация-на-новом-месте&#34;&gt;Адаптация на новом месте&lt;/h2&gt;

&lt;p&gt;Вот ты уже и переехал, даже нашел квартиру и снял её. Скорее всего на этом всё не закончится. Весьма вероятно, что на прежнем месте ты оставил часть повседневной утвари, которая нужна. &amp;ldquo;Это всё можно купить и там&amp;rdquo; - говорил ты, формируя пакеты с вещами, которые остаются. Вот, этот момент и настал. Здесь в зависимости от того, что тебе досталось от арендодателя формируется новый список - список покупок. Скорее всего это будет приличный объем расходов, так что заготовь деньги заранее. Обрати внимание на заказы онлайн, у крупных магазинов при заказе от определенной суммы можно получить бесплатную доставку, это очень удобно, особенно если нет машины.&lt;/p&gt;

&lt;p&gt;Покупай местную симку, операторы связи не дают возможности сохранить номер при переезде из региона в регион. Пройдись по салонам связи, их много около метро, собери буклеты с тарифными планами, а вечером дома спокойно выбери.&lt;/p&gt;

&lt;p&gt;После въезда в квартиру в ближайшие пару дней сходи в поликлинику к которой относишься, в случае Питера есть сайт &lt;a href=&#34;https://spboms.ru&#34;&gt;https://spboms.ru&lt;/a&gt;, где можно уточнить эту информацию. Тебе нужно будет прикрепить ОМС к местной страховой, обычно представителей можно найти прямо на территории поликлиники (или поищи &amp;ldquo;ОМС&amp;rdquo; в 2gis), затем тебе сформируют карточку и всё готово. Еще в Самаре я проделал некоторую предварительную работу, чтобы получить потерянную карточку из поликлиники, но она оказалась не нужна для создания новой на месте.&lt;/p&gt;

&lt;p&gt;К моменту, когда ты снял квартиру, закупился всем, чего не хватало, прикрепился к поликлинике, вещи скорее всего уже добрались до терминала перевозчика и их доставку можно заказывать у всё того же перевозчика.&lt;/p&gt;

&lt;h2 id=&#34;заключение&#34;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Вот так. Теперь ты знаешь всё. Если показалось, что это довольно просто и очевидно, то так оно и есть. Основной посыл этого поста показать, что очередная вещь, которая может показаться сложной, далёкой и нереальной, проста в исполнении, если всё разложить по полочкам. Хочу отметить, что я не ярый сторонник переездов из регионов, просто это интересный опыт, который я захотел испытать.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Проектные пожары - время расти</title>
      <link>https://i-osipov.ru/post/time-to-growth/</link>
      <pubDate>Sat, 23 Jun 2018 09:34:54 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/time-to-growth/</guid>
      <description>

&lt;p&gt;Порой на наших проектах происходят ситуации, когда именно от тебя всё зависит, множество срочных к исправлению проблем. Ты тот единственный человек, который сейчас может помочь, тебе не на кого оставить проблему и других более опытных технических специалистов, которые разбираются в проекте, больше нет. Я называю такие моменты &amp;ldquo;пожар&amp;rdquo;. Давай взглянем на эту ситуацию и подумаем, что же мы из неё можем извлечь и почему страх безоснователен.&lt;/p&gt;

&lt;h2 id=&#34;почему-это-произошло&#34;&gt;Почему это произошло?&lt;/h2&gt;

&lt;p&gt;Для начала разберемся в причинах. Почему на проектах происходят пожары, которые нужно тушить, срочно, именно тебе? Интуитивно кажется, что источник этой проблемы - менеджмент, однако, это далеко не всегда так. Представим, что вас двое-трое разработчиков на проекте и те, другие, собрались в отпуск или в командировку по параллельному проекту. Остался только ты. С точки зрения менеджера - всё в порядке, всегда есть разработчик, который может исправить критическую проблему заказчика. С другой стороны, обычно, если система довольно крупная, то ты знаешь только свою часть и еще немножко, а в тот момент, когда начинают сыпаться ошибки из модуля, которым ты раньше не занимался, то появляется некоторого рода страх, о котором мы немного поговорим.&lt;/p&gt;

&lt;h2 id=&#34;безосновательная-природа-страха&#34;&gt;Безосновательная природа страха&lt;/h2&gt;

&lt;p&gt;Начинать что-то новое всегда больно, а исправлять чужой код в непокрытой тестами части системы всегда страшно.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Конечно, здесь исходная проблема в отсутствии обильного авто тестирования, однако, если ты работал в аутсорсинге, то ты меня поймешь, нам далеко не всегда дают достаточно времени на покрытие системы тестами, здесь есть тонкая грань между миром разработки и миром бизнеса.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Почему возникает страх? В первую очередь от отсутствия знания того или иного модуля, того или иного кода. Вспомни, когда к тебе прилетал тикет в котором написано, например, следующее: &lt;em&gt;Метод Х модуля А бросает IllegalStateException&amp;hellip;&lt;/em&gt;. Какие чувства вызывают подобные тикеты, если ты создатель этого метода и вообще обладаешь абсолютно полными знаниями о модуле А? По моим ощущениям, такие проблемы вызывают скорее легкое раздражение: &lt;em&gt;Как же так, я что-то упустил&amp;hellip;&lt;/em&gt;, чем страх. А что с ситуацией где всё тот же самый тикет, но ты впервые в глаза видишь &lt;em&gt;модуль А&lt;/em&gt;? Возникает страх или своего рода волнение, из подсознательного выскакивает мысль: &lt;em&gt;А смогу ли я это исправить?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;С опытом приходит понимание, что можно исправить всё, страх пропадает, но как же так происходит? Дело в том, что причин для страха на самом деле нет и постепенно осознаем. В чем исходная причина страха? В незнании! Мы понятия не имеем с чем имеем дело. Хотя как только мы устраним незнание, станем владельцами функции, разберемся в её работе, то страх и волнение сами по себе уйдут. Здесь нам поможет иерархический нисходящий подход.&lt;/p&gt;

&lt;h2 id=&#34;иерархический-нисходящий-подход&#34;&gt;Иерархический нисходящий подход&lt;/h2&gt;

&lt;p&gt;Сначала, узнайте, что это за модуль, в котором возникла проблема, обозначьте его основные ответственности. Затем, разберитесь кто инициировал вызов, какая глобальная задача модуля выполняется, и постепенно опускайтесь вглубь до самой функции, которая бросает ошибку. Довольно очевидно, не так ли? Однако, на мой взгляд, только этот подход может дать эффективные плоды в изучении чужого кода. После того, как мы идеологически разобрались с частью в которой падают ошибки наступает время для её решения. Я сформировал для себя эвристическое правило, которое назвал &amp;ldquo;Полуторачасовой Proof of Concept&amp;rdquo;, о нём я расскажу в отдельной статье, чтобы не пропустить, &lt;a href=&#34;https://i-osipov.ru/subscribe/&#34; target=&#34;_blank&#34;&gt;подписывайтесь на рассылку&lt;/a&gt; или присоединяйтесь к &lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;Telegram каналу&lt;/a&gt;. Борьба со страхом неизвестных ошибок, исправление их - это первый шаг по лестнице вверх в направлении собственного роста. Как бы нам извлечь максимум пользы из текущего состояния дел? Именно об этом мы и поговорим дальше.&lt;/p&gt;

&lt;h2 id=&#34;time-to-growth&#34;&gt;Time to growth&lt;/h2&gt;

&lt;p&gt;Когда горят пожары на проекте, когда всё зависит от тебя, твое время сильно ограничено и нужно выдавать N тысяч фиксов в минуту, тут то и активизируются все навыки к освоению чего-то нового. Лучший прогресс процесса обучения заметен в той области, где вы уже немного разобрались, но пока недостаточно, дельта прироста максимальна. Это можно описать широко известной кривой обучения, которая представлена на картинке ниже.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/time-to-growth/learning-curve.jpeg&#34; alt=&#34;Learning Curve&#34; title=&#34;Кривая обучения&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Я приведу пример из практики. На одном из проектов во время его выхода на UAT (User Acceptance Testing) я остался единственным разработчиком, приложение активно тестировалось и на этом этапе нужно было справиться с серией интересных задач. Я давно хотел поработать с инфраструктурой амазона, мне повезло, наше приложение развернули у них, но не успели сделать нормальное Continuous Delivery, по этому все обновления нужно было делать вручную. Вход на сервер был доступен только через bastion server, это такой прокси в инфраструктуре амазона, который является единой точкой входа в вашу подсеть. Доступ только по ssh. Должно быть довольно очевидно из картинки ниже.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/time-to-growth/bastion.png&#34; alt=&#34;Bastion&#34; title=&#34;Bastion&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Представь, какое &amp;ldquo;удовольствие&amp;rdquo; ты получаешь, когда делаешь последовательное открытие ssh соединений, сначала до bastion сервера, потом до веб сервера, при этом нужно использовать правильные pem ключи и ничего не забыть. Это изматывает, хочется найти более простые пути. Тут-то и произошёл очередной скачек, когда я узнал про .ssh/config - файл конфигурации для OpenSSH в котором ты можешь описать довольно сложные соединения, указать bastion как прокси и всё это свернуть под один HostName. В итоге, открытие ssh соединение до web server&amp;rsquo;a превращается в одну команду &lt;code&gt;ssh web_server_alias&lt;/code&gt;. Особенно круто, что ты можешь, например, копировать файлы с помощью &lt;code&gt;scp&lt;/code&gt; на удалённый сервер всё так же просто, более того автодополнение в терминале поможет тебе найти правильную папку на удаленном сервере, при том, что ты явным образом никакого ssh не открывал. Конечно, раньше мне иногда приходилось пользоваться ssh, но сам факт того, что это можно сделать на столько просто - открыл для меня следующий уровень владения этим инструментом и производными от него.&lt;/p&gt;

&lt;p&gt;Другой пример, это логирование, когда приложения попадают к пользователю очень часто что-то идет не так. Например, background worker, поток, который запускается с частотой раз в 10 секунд начинает забрасывать лог тоннами эксепшенов из одного специализированного модуля, благодаря чему размер лог файла очень быстро стремится в бесконечность при этом забивая этим шумомом ни в чем неповинный общий лог файл (сейчас я говорю об обычном монолите). Первое, что приходит на ум, нужно срочно бежать и фиксить. Здесь главное остановиться на пару секунд и подумать: &amp;ldquo;А могу ли я замедлить разгорающийся пожар?&amp;rdquo;. Вовсе остановить запускающийся процесс - нельзя, а вот замедлить, например, до частоты запуска раз в минуту - можно. Таким образом, пожар превращается в нечто меньшее, лог файл растет в шесть раз медленнее, значит, что достигнуть того огромного размера в который он превратился за один день он сможет только за неделю, не плохо, теперь можно собраться с мыслями и спокойно делать фикс.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Подобные идеи, ассоциируются у меня с книгой Д. Трампа &amp;ldquo;Искусство заключать сделки&amp;rdquo;. Автор рассказывает о том, что когда он строил свою Trump Tower в Нью-Йорке ему никак не удавалось выкупить территорию, достаточную по регламенту для построения небоскреба, хозяева этой территории отказывались её продавать. Тогда автор нашёл обходной путь, он арендовал землю на 99 лет. Мораль - если что-то нужно прямо сейчас, но это недостижимо, ищите дополнительные обходные пути для быстрого временного решения.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Если в обычной жизни вам не часто нужно настраивать лог файл, то здесь появляется острая потребность в этом разобраться. Например, вы хотите отслеживать запросы во внешнее API, они не доходят до этого API или некоторые из них невалидные, их происходит много и смешивать такие логи с общим потоком - не правильно. Мы всегда можем выделить специальный файл для определенного API, настроить для него логгер и аппендер (в терминах logback), настроить процесс ежедневного архивирования таких файлов и вуаля, оно работает. Вся интересная вам информация в одном месте, без лишнего шума. Таким образом, если вы имели минимальное представление как этого достичь, но не знали деталей, то кривая роста делает своё дело.&lt;/p&gt;

&lt;h2 id=&#34;разгребая-угли&#34;&gt;Разгребая угли&lt;/h2&gt;

&lt;p&gt;В какой-то момент пожары заканчиваются, они либо становятся маленькими и локальными, либо оказываются полностью потушенными, что тоже имеет место. Такие ситуации помогают нам приобрести навыки необходимые для выживания, вырасти и почувствовать настоящий вкус профессии программиста. Где-то я прочитал, что музыка способствует поиску множества решений одной проблемы, стимулирует разнообразие вариантов, это может действительно помочь в трудных ситуациях. Пожары закаляют и показывают вам на что вы способны, я не призываю вас их разжигать, но если уже разгорелось, то это отличная возможность для роста.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo and Math</title>
      <link>https://i-osipov.ru/post/hugo-and-math/</link>
      <pubDate>Wed, 25 Apr 2018 09:17:46 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/hugo-and-math/</guid>
      <description>&lt;p&gt;Сейчас я в нахожусь в процессе прохождения курсов по Data Science и, как следствие, некоторые вещи мне хочется законспектировать
в виде блога. Основная проблема в том, что для конспектирования материала хотелось бы иметь возможность
писать математические формулы в LaTeX синтаксисе или около того. Если хорошенько поискать, то в документации
hugo можно наткнуться на вот &lt;a href=&#34;https://gohugo.io/content-management/formats/#mathjax-with-hugo&#34; target=&#34;_blank&#34;&gt;этот&lt;/a&gt;
раздел. Заметка будет полезна тем, кто организовывает свой блог через статик-генератор gohugo и хочет подключить поддержку
формул.&lt;/p&gt;

&lt;p&gt;Библиотека MathJax - js библиотека, которая позволяет отображать математические выражения описанные в LaTeX синтаксисе.
Для того, чтобы подключить поддержку этой библиотеки к вашему блогу, во-первых создадим пока пустой файл &lt;strong&gt;mathjax_support.html&lt;/strong&gt; и положим
его в папку исходников блога layouts/partials сразу же подключим и проинициализируем его в файле header.md перед закрывающим тегом &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; следующим образом:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{{ partial &amp;quot;mathjax_support.html&amp;quot; . }}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Наполним файл следующим образом: укажем где найти библиотеку и как её проинициализировать.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],
    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],
    processEscapes: true,
    processEnvironments: true,
    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],
    TeX: { equationNumbers: { autoNumber: &amp;quot;AMS&amp;quot; },
         extensions: [&amp;quot;AMSmath.js&amp;quot;, &amp;quot;AMSsymbols.js&amp;quot;] }
  }
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Готово. На страничке &lt;a href=&#34;https://gohugo.io/content-management/formats/#mathjax-with-hugo&#34; target=&#34;_blank&#34;&gt;hugo документации&lt;/a&gt;
можно найти решения основных проблем при подключении библиотеки. Лично у меня заработало из коробки.&lt;/p&gt;

&lt;p&gt;В результате, следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$
c^{2} = a^{2} + b^{2}
$$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Превращается в формулу:&lt;/p&gt;

&lt;p&gt;$$
c^{2} = a^{2} + b^{2}
$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin Updates Report 1.2.40</title>
      <link>https://i-osipov.ru/post/kotlin-updates-report-1.2.40/</link>
      <pubDate>Fri, 20 Apr 2018 07:35:10 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-updates-report-1.2.40/</guid>
      <description>

&lt;p&gt;Вчера вечером вышло описание нововведений в Kotlin 1.2.40. Сегодня, по традиции, мы с вами взглянем на
очередной релиз и актуализируем знания по языку.&lt;/p&gt;

&lt;p&gt;Список изменений:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;множественное использование expectedBy зависимостей;&lt;/li&gt;
&lt;li&gt;поддержка crossinline suspend параметров в inline функциях;&lt;/li&gt;
&lt;li&gt;экспериментальная поддержка аннотации @JvmDefault для создания методов интерфейсов из Java 8 с модификатором default;&lt;/li&gt;
&lt;li&gt;добавлены новые инспекции и интеншены в плагин;&lt;/li&gt;
&lt;li&gt;прямое обращение к классам внутри companion object в скоупе наследования теперь deprecated;&lt;/li&gt;
&lt;li&gt;фиксы в компиляторе и IDE плагине, улучшения производительности.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот update совместим с Intellij IDEA от 2017.1 до 2018.1, также как с Android Studio 3.x.&lt;/p&gt;

&lt;h3 id=&#34;улучшения-мультиплатформенных-проектах&#34;&gt;Улучшения мультиплатформенных проектах&lt;/h3&gt;

&lt;p&gt;Платформенные модули теперь позволяют реализовывать платформенно-специфичные декларации для более чем одного мультиплатформенного
модуля. Теперь вы можете использовать &lt;code&gt;expectedBy&lt;/code&gt; в зависимостях несколько раз. Выглядит это, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;kotlin-platform-jvm&#39;
// ...
 
dependencies {
    expectedBy project(&amp;quot;:io-common&amp;quot;)
    expectedBy project(&amp;quot;:data-common&amp;quot;)
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такие зависимости нетранзитивны, разберемся с этим. Пусть есть вот такая цепочка зависимостей: &lt;code&gt;my-common -&amp;gt; lib-common&lt;/code&gt;
Это два common модуля (напомню, что мы разделяем платформенные и common модули), где первый зависит от второго.
При попытке установить зависимость на my-common модуль в платформенном модуле у нас есть один из двух путей:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;либо мы вручную определяем две &lt;code&gt;expectedBy&lt;/code&gt; зависимости;&lt;/li&gt;
&lt;li&gt;или добавляем &lt;code&gt;expectedBy&lt;/code&gt; только на &lt;code&gt;my-common&lt;/code&gt; и компилируем зависимость на существующем платформенном модуле для &lt;code&gt;lib-common&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Напомню, что для мультиплатформенных проектов есть понятие expect/actual модификатора. Эти модификаторы позволяют связывать
&amp;ldquo;ожидания реализации&amp;rdquo; интерфейса и фактические платформенные реализации. Так вот, для expect функций и конструкторов в
Kotlin 1.2.40 появилась поддержка значений по умолчанию, пример ниже:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;expect class StringMatcher {
    fun match(value: String, matchStrictly: Boolean = false): Boolean
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;При этом, default параметры поддерживаются только для expect конструкторов/функций, но не для их actual двойников.&lt;/p&gt;

&lt;h3 id=&#34;поддержка-crossinline-suspend-параметров-функций&#34;&gt;Поддержка crossinline suspend параметров функций&lt;/h3&gt;

&lt;p&gt;Напомню, что crossinline модификатор говорит о том, что лямбда, передаваемая в качестве параметра inline функции, может
быть передана в другой контекст, а, например, если мы передадим лямбду без этого модификатора, то компилятор не знает
как поступать в случае non-local возвратов. Для того, чтобы решить эту проблему добавим модификатор crossinline,
который подскажет компилятору, что нужно запретить non-local return и благодаря этому запрету появится возможность передавать
лямбды в другие контексты.&lt;/p&gt;

&lt;p&gt;До версии Kotlin 1.2.40 в случае совместного использования crossinline и suspend для лямбд, мы получали сообщение:
&lt;code&gt;Inline lambda parameters of suspend function type are not fully supported. Add noinline modifier&lt;/code&gt;. Теперь конструкция ниже компилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun schedule(crossinline runner: suspend () -&amp;gt; Unit)  {
    launch(CommonPool) {
        runner()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jvmdefault&#34;&gt;@JvmDefault&lt;/h3&gt;

&lt;p&gt;Экспериментальная фича, которая при таргете на JVM 1.8 генерирует default методы интерфейса при наличии аннотации @JvmDefault. Фича
выключена по умолчанию, чтобы включить передаем компилятору флаг &lt;code&gt;-Xenable-jvm-default&lt;/code&gt;. Т.к. фича экспериментальная, то она
может быть передизайнена, изменена, ровно как может быть изменено название ключа для компилятора.&lt;/p&gt;

&lt;h3 id=&#34;ограничения-видимости-типов-через-наследование-companion-object&#34;&gt;Ограничения видимости типов через наследование companion object&lt;/h3&gt;

&lt;p&gt;В Kotlin 1.3 планируются потенциально ломающие изменения связанные с видимостью через companion object.
Для того чтобы сглядить этот переход в Kotlin 1.2.40 вводится warning на использование краткого имени (non-qualified)
для доступа к внутренностям companion object&amp;rsquo;а родительского класса.
В примере ниже безо взякого импорта, мы можем получить доступ к классу внутри companion object&amp;rsquo;а нашего супертипа. Именно это
и хотят постепенно запретить. Хорошая новость, Kotlin Plugin на борту содержит туллинг для миграции этого кейса, так что, если
вы писали подобный код, то миграция поможет вам обновиться. Пример кода, ниже:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Bar {
    companion object {
        class FromBarCompanion
    }
}

class Foo : Bar {
    fun foo(): FromBarCompanion = TODO()
    // Warning: access to this type by short name 
    // is deprecated and is going to be removed.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В Kotlin 1.3 запретят такие конструкции в принципе. Мне нравится, что разработчики языка тестируют доступную кодовую базу
на 1.5 млн. строк кода для оценки важности этого изменения. В данном случае влияние изменения ожидается минимальным.&lt;/p&gt;

&lt;h3 id=&#34;intellij-idea-улучшения-плагина&#34;&gt;Intellij IDEA. Улучшения плагина&lt;/h3&gt;

&lt;p&gt;Добавлен интеншен для добавления явного return из лямбды. Гифка скажет всё за меня:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2018/04/return-at-label-anim.gif&#34; alt=&#34;Intention1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Добавлен интеншен для добавления и удаления use-site targets аннотаций. В Kotlin на одну аннотацию
(например, в primary конструкторе) может приходиться несколько Java аннотаций. Для контроля того какая именно аннотация
нужна вводятся Use-Site Target. Их-то мы и контролируем. Для интересующихся,
&lt;a href=&#34;http://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets&#34; target=&#34;_blank&#34;&gt;вот ссылка&lt;/a&gt;
на документацию по этому виду аннотаций.&lt;/p&gt;

&lt;p&gt;Добавлена инспекция на подсветку и удаление необязательных явных ссылок на companion object&amp;rsquo;ы.&lt;/p&gt;

&lt;p&gt;Сделаны улучшения по стабильности и производительности.&lt;/p&gt;

&lt;h3 id=&#34;изменения-в-компиляторе&#34;&gt;Изменения в компиляторе&lt;/h3&gt;

&lt;p&gt;Улучшена производительность и поправлены некоторые известные проблемы.&lt;/p&gt;

&lt;p&gt;Обещают более эффективный генерируемый компилятором код для следующийх ситуаций: доступ к private свойствам companion
object&amp;rsquo;ов, проверка enum&amp;rsquo;ов на равенство, сравнение Long&amp;rsquo;ов.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Релиз понравится тем, кто не может жить без inline лямбд в корутинах, любителям плодить common модули в мультиплатформенных проектах,
тем кто пишет Kotlin &amp;ldquo;рядом&amp;rdquo; с Java. В целом есть приятные маленькие улучшения в плагине и радостно видеть, что ошибки дизайна,
как в случае с видимостью типов из чужих companion object&amp;rsquo;ов, исправляются по намеченому плану: deprecated -&amp;gt; restricted.&lt;/p&gt;

&lt;p&gt;Чтобы быть в курсе последних событий &lt;a href=&#34;https://t.me/from_junior_to_senior&#34; target=&#34;_blank&#34;&gt;присоединяйтесь к Telegram&lt;/a&gt; (@from_junior_to_senior)&lt;/p&gt;

&lt;a href=&#34;http://blog.jetbrains.com/kotlin/2018/04/kotlin-1-2-40-is-out/?utm_source=i-osipov.ru&amp;amp;utm_medium=site&#34; target=&#34;_blank&#34;&gt;Источник&lt;/a&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin Updates Report 1.2.20-1.2.30</title>
      <link>https://i-osipov.ru/post/kotlin-updates-report-1.2.20-1.2.30/</link>
      <pubDate>Sat, 31 Mar 2018 11:14:07 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-updates-report-1.2.20-1.2.30/</guid>
      <description>

&lt;p&gt;За первую четверть этого года успело релизнуться несколько версий Kotlin. Для начала давайте перечислим основные
изменения.&lt;/p&gt;

&lt;h3 id=&#34;изменения-из-1-2-20&#34;&gt;Изменения из 1.2.20:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;добавлена поддержка Gradle build cache;&lt;/li&gt;
&lt;li&gt;улучшена инкрементальная компиляция;&lt;/li&gt;
&lt;li&gt;поддержка IDE для Kotlin style guide;&lt;/li&gt;
&lt;li&gt;хинты в IDE для неявный параметров и контекстов лямбд и значений, которые возвращаются из лямбд;&lt;/li&gt;
&lt;li&gt;поддержан делопмент мод в JavaScript DCE Gradle Task;&lt;/li&gt;
&lt;li&gt;мелкие улучшения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;изменения-из-1-2-30&#34;&gt;Изменения из 1.2.30:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;добавлена новая декларация в стандартную библиотеку, которая иммитирует suspend модификатор для лямбд;&lt;/li&gt;
&lt;li&gt;добавлена поддержка для TestNG в kotlin.test;&lt;/li&gt;
&lt;li&gt;притащили поддержку мультиплатформенных модулей для Android;&lt;/li&gt;
&lt;li&gt;добавлена новая вощможность в kapt для репортинга ошибок обработки аннотаций;&lt;/li&gt;
&lt;li&gt;добавлено много новых инспекций и интеншенов в Intellij IDEA, улучшена их производительность;&lt;/li&gt;
&lt;li&gt;поправлены некоторые баги в плагине и компиляторе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ну, а теперь подробно взглянем только на интересные фичи. Полный обзор смотрите в оригинальных источниках (ссылки в конце).&lt;/p&gt;

&lt;h4 id=&#34;gradle-build-cache-precise-java-tracking&#34;&gt;Gradle Build Cache &amp;amp; Precise Java Tracking&lt;/h4&gt;

&lt;p&gt;При использовании версии Gradle 4.3+ вы можете использовать флаги &lt;code&gt;--build-cache&lt;/code&gt; или &lt;code&gt;org.gradle.caching=true&lt;/code&gt;. В этом случае
плагин будет переиспользовать предыдущие результаты сборки. Например, вы собрали версию приложения под master веткой, затем переключились
на ветку feature_X, собрали снова и вернулись назад на мастер. Если вы воспользуетесь флагом выше, то ваш код не будет пересобран
на мастере, т.к. результаты были закешированы.&lt;/p&gt;

&lt;p&gt;Если ваш Java класс изменился так, что это не аффектит ваш Kotlin код, то, в теории, компилятор, может нерекомпилировать
ваш Kotlin код. Для того, чтобы воспользоваться этой &lt;strong&gt;экспериментальной&lt;/strong&gt; фичей нужно добавить следующую проперти в gradle.properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;kotlin.incremental.usePreciseJavaTracking=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;code-conventions&#34;&gt;Code Conventions&lt;/h4&gt;

&lt;p&gt;Ранее были опубликован &lt;a href=&#34;http://kotlinlang.org/docs/reference/coding-conventions.html&#34; target=&#34;_blank&#34;&gt;официальный style guide&lt;/a&gt;.
Начиная с 1.2.20 форматтер Intellij IDEA поддерживает его.&lt;/p&gt;

&lt;h4 id=&#34;клёвые-хинты&#34;&gt;Клёвые Хинты&lt;/h4&gt;

&lt;p&gt;Среди изменений прилетело одно, ну очень полезное, для разработки и использования Kotlin DSL - это хинты для
контекстов лямбд, их неявных параметров и результатов выполнения этих лямбд. Выглядит всё это следующим образом:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/kotlin-updates-report-1.2.20-1.2.30/hints-example.png&#34; alt=&#34;Hints&#34; title=&#34;Hints&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;интересные-интеншены&#34;&gt;Интересные Интеншены&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Появился интеншен для конвертации функции let &amp;lt;-&amp;gt; run и also &amp;lt;-&amp;gt; apply. По сути, конвертер превращает одну функцию в другую и наоброт.
Пожалуй эта фича хороша по следующей причине. Не секрет, что из-за этой кучки функций постоянно появлялись
сомнения что-же использовать, теперь с этим проще и подобные фичи помогают запоминать и укладывать в голове
назначение этих функций, либо каждый раз конвертировать.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Вставка Kotlin кода в пакет. Не до конца понимаю назначение фичи, но выглядит как такой, быстрый рефакторинг.
По сути, вы делаете Ctrl + X, т.е. вырезаете класс, а затем указываете в какой пакет его положить, жмете Ctrl + V и код
перемещается в сгенерированный файл.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;analyzing-data-flow&#34;&gt;Analyzing Data Flow&lt;/h4&gt;

&lt;p&gt;Анализ потоков данных теперь поддержен для смешаных Java-Kotlin проектов. Круто! Если кто-то не знает, что это, то
в Intellij IDEA есть фича в меню Analyze, которая помогает вам в большом и запутанном легаси проекте понять откуда
приходят данные в то или иное место или куда они уходят. Фича классная, помогает не нажимать бесконечно Ctrl + B, а
увидеть, например, дерево вызовов метода get и понять куда забирают наши данные и как с ними работают.&lt;/p&gt;

&lt;h3 id=&#34;вместо-заключения&#34;&gt;Вместо заключения&lt;/h3&gt;

&lt;p&gt;Приятно видеть, что разработчики принимают множество пул реквестов от сторонних разработчиков.&lt;/p&gt;

&lt;p&gt;На этом, на мой взгляд, интересные нововведения исчерпаны. Ниже ссылки на источники. Успехов!&lt;/p&gt;

&lt;p&gt;Источники:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2018/01/kotlin-1-2-20-is-out/&#34; target=&#34;_blank&#34;&gt;Kotlin 1.2.20 is out&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2018/03/kotlin-1-2-30-is-out/&#34; target=&#34;_blank&#34;&gt;Kotlin 1.2.30 is out&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/help/idea/analyzing-data-flow.html&#34; target=&#34;_blank&#34;&gt;Analyzing Data Flow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin Generics</title>
      <link>https://i-osipov.ru/post/kotlin-generics/</link>
      <pubDate>Sun, 04 Feb 2018 06:17:17 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-generics/</guid>
      <description>

&lt;p&gt;Первый релиз языка Kotlin включает в себя Kotlin Generics. Обобщенные типы, благодаря которым
мы с вами можем писать более гибкие приложения с меньшим дублированием кода и большей типобезопасностью.
Одно из важных преимуществ, которое дает вашему приложению использование Generics - проверка типов на этапе компиляции.
Дизайнеры языка Kotlin ввели новые ключевые слова для работы с дженериками, что по началу может ввести в ступор даже
опытного Java разработчика. Сегодня мы с вами обсудим что такое &amp;ldquo;дженерики&amp;rdquo;, удалим страх перед словами типа &amp;ldquo;контравариантность&amp;rdquo;,
а заодно познакомимся с reified generics и star-projection.&lt;/p&gt;

&lt;h2 id=&#34;generics&#34;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Для тех кто вовсе не знаком с обобщенными типами (generics) и для тех, кто порядком подзабыл, я напомню,
что обобщенные типы это возможность выполнять контроль типов в вашем приложении при том, что точный тип вам не известен.
Приведу пример, у вас есть коллекция Set, которая может быть хранилищем для абсолютно разных объектов, так, в одном
месте приложения вы возпользуетесь &lt;code&gt;Set&amp;lt;User&amp;gt;&lt;/code&gt; для работы с множеством пользователей, а в другой части приложения это
будет &lt;code&gt;Set&amp;lt;Task&amp;gt;&lt;/code&gt; - коллекция, которая хранит выполненные задачи. В обоих случаях коллекция Set выполняет возложенные
на неё обязательства, более того, компилятор может проверить, что метод add принимает объект соответствующего типа, ровно
как мы получим объекты этого типа проходя по коллекции.&lt;/p&gt;

&lt;p&gt;Создание классов с обобщенными Kotlin типами в простейшем виде выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;T - это лишь типичный пример именования неизвестного типа, вместо T вы можете использовать любой идентификатор для
удобства. В примере выше мы описали класс, единственный параметр класса имеет общенный тип. Обратите внимание, что свойство
класса имеет модификатор &lt;code&gt;var&lt;/code&gt; и здесь это не с проста, ниже я объясню почему. Воспользуемся контейнером
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container = Container(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обратите внимание, в сравнении с Java нам нет необходимости явно указывать Generic тип для контейнера, т.к. компилятор
обладает полной информацией для выведения этого типа. Аналогично, начиная с Java 7, мы имеем возможность писать сокращенный
вариант с использованием &lt;a href=&#34;http://www.rootfront.com/article/219061/2011-04-21/v-jdk-7-pojavitsja-diamond-operator&#34; target=&#34;_blank&#34;&gt;Diamond Operator&lt;/a&gt;.
В совокупности с возможностью Kotlin выводить типы и для переменных мы имеем сокращенный синтаксис и при этом гибкий набор инструментов.&lt;/p&gt;

&lt;p&gt;Но что, если мы хотим положить в наш контейнер другой Int? Легко!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;container.contained = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Затем, мы можем прочитать его, также легко.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;println(container.contained)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На каждом этапе, на каждой строке компилятор проверяет, что мы работаем именно с Int, а не с чем бы то ни было другим, благодаря
этому, мы, например, не можем записать в наш контейнер String.&lt;/p&gt;

&lt;h2 id=&#34;инвариантный-ковариантный-контравариантный&#34;&gt;Инвариантный, ковариантный, контравариантный&lt;/h2&gt;

&lt;p&gt;Должен вам признаться, если не работать со сложными вариациями обобщенных типов, то со временем всё забывается и приходится
обновлять знания, вспоминать некоторые термины и иногда это дается с трудом, т.к. множество источников по generics пестрят
красивыми словами &lt;em&gt;инвариантный&lt;/em&gt;, &lt;em&gt;ковариантный&lt;/em&gt;, &lt;em&gt;контравариантный&lt;/em&gt;, однако, эти же источники совершенно невнятно объясняют
терминологию. Сегодня я нацелен исправить это и перешагнуть через тонкую грань непонимания в данном вопросе.&lt;/p&gt;

&lt;h3 id=&#34;инвариантность&#34;&gt;Инвариантность&lt;/h3&gt;

&lt;p&gt;Возвращаясь к примеру с контейнером из предыдущего раздела, мы имеем тип &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt;, где вместо T может оказаться
любой тип с верхней границей Any? (об этом позже, коротко, любой nullable и не-nullable тип). Допустим, что мы
сохранили в контейнер значение с типом Int следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Я определяю тип переменной и дженерик для очевидности, по умолчанию, компилятор вполне справляется с их выводом&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Сможем ли мы обобщить нашу переменную чуть больше. Int наследуется от Number, и допустим мы хотим хранить в переменной
контейнер не только с Int, а в принципе с Number, т.е. в нем может находиться любое число, например, Double.
Интуитивно хочется написать:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, такой код не скомпилируется, т.к. не смотря на то, что Int наследуется от Number, то типы с дженериками
&lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt; и &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; не находятся в одной иерархии, по сути, это абсолютно разные типы, никак не
совместимые. Другим языком, &lt;strong&gt;класс Container неизменен (инвариантен) по типу T&lt;/strong&gt;. Следовательно, независимо от иерархии
наследования самих обобщенных типов, по умолчанию, мы не можем говорить об каком-либо следствии иерархии классов
использующих их.&lt;/p&gt;

&lt;h3 id=&#34;ковариантность&#34;&gt;Ковариантность&lt;/h3&gt;

&lt;p&gt;Вы можете задаться вопросом: &amp;ldquo;А зачем это сделано? Почему не дать иерархию как следствие иерархии обобщенных типов по
умолчанию?&amp;ldquo;. Дело в том, что основная задача обобщенных типов - обеспечить безопасность типизации в вашем коде,
уменьшить количество выбрасываемых исключений во времени выполнения уже на этапе компиляции, ну и конечно сделать всё
это гибко. Обрисовать проблему мне помогут массивы из Java. Так получилось, что в Java массивы появились на много
раньше чем обобщенные типы. Когда вводили массивы дали возможность сказать, что если у вас есть массив целочисленных значений (Integer[]), то вы можете
присвоить это значение в переменную Number[]. Казалось бы, вот мы и получили наследование, но давайте рассмотрим
следующий кусочек кода:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 }; //создаем массив Integer 
Number[] b = a; // делаем еще одну ссылку на массив с типом Number[] и это допустимо
b[1] = 4.4; //сохраняем Double значение в массив Integer
//Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException: java.lang.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто мы можем получить ошибку, которую увидим только на этапе выполнения (в JVM есть специальная проверка, которая
выполняется на записи), следовательно, наследование
как следствие по умолчанию - это плохая идея. Однако, следующий код допустим, не так ли?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 };
Number[] b = a;
System.out.println(b[1]);
//output: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь всё законно, мы сделали те же самые действия, но вместо присвоения значения, мы его прочитали. Получается, что иногда
поведение передачи наследования в соответствии с обобщенным типом может быть безопасно. Например, у нас есть метод, который
будет только распечатывать значения из входного параметра и, в принципе, он может принимать любые числа, хоть
Integer и Double в одном массиве, а затем печатать их. Так мы можем вывести правило:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если наша пременная только предоставляет значения, то мы можем допустить, что в ней может находиться значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;аналогично для классов с обобщенными типами:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если объект нашего класса только предоставляет значения, то мы можем допустить, что в нём хранится значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Что значит &amp;ldquo;ниже по иерархии&amp;rdquo;? В Kotlin, как и в любом другом типизированном языке, существует иерархия типов. Если вы
слабо представляете её, то я могу порекомендовать вам вот &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt;
статью, которая поможет разобраться в системе типов. Ну а сейчас, для краткости, я лишь скажу, что для типа Number типы Int и Double
лежат ниже по иерархии типов (могут быть безопасно приведены к Number), а тип Any лежит выше по иерархии типов (к нему можно
безопасно привести Number).&lt;/p&gt;

&lt;p&gt;Другими словами, нужно как-то объяснить компилятору, что в некоторых ситуациях мы готовы к ковариантности. Тут то мы и подобрались
к этому страшному слову. &lt;strong&gt;Ковариантностью&lt;/strong&gt; называется сохранение иерархии типов в производных типах в том же порядке.&lt;/p&gt;

&lt;p&gt;Мы можем сказать, что &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt; ковариантен своему параметру-типу T. Это будет означать, что если Int - потомок
Number, то &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; будет тоже считаться потомком &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;. Напомню, что выше мы убедились
в том, что ковариантность допустима, только когда мы говорим о получении значения, а по умолчанию обобщенные типы инвариантны,
т.е. мы можем безопасно &lt;strong&gt;получить&lt;/strong&gt; Number, если работаем с &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; или контейнером для любого другого наследника Number.
Существует два способа объяснить компилятору то, что Container ковариантен по параметру-типу T в Kotlin. Давайте их рассмотрим.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-уровне-класса-на-месте-объявления&#34;&gt;Ковариантность на уровне класса (на месте объявления)&lt;/h4&gt;

&lt;p&gt;Когда мы объявляем класс, мы можем изначально говорить о том, что класс ковариантен своему типу-параметру. Работать с ковариантными
типами нам помогает ключевое слово &lt;code&gt;out&lt;/code&gt;. Семантика его крайне проста в понимании. Если класс выступает в качестве Producer&amp;rsquo;a,
т.е. мы планируем значения типа Т &lt;strong&gt;только&lt;/strong&gt; получать, то мы используем ключевое слово &lt;code&gt;out&lt;/code&gt;, т.е. класс поставляет
значения типа &lt;strong&gt;наружу&lt;/strong&gt;. Давайте изменим декларацию нашего класса Container следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Тут же мы получаем ошибку компиляции, но какую?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type parameter T is declared as &#39;out&#39; but occurs in &#39;invariant&#39; position in type T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Какая странная ошибка, где это у нас возникает потребность в инвариантном состоянии? Точно! Ключевое слово &lt;code&gt;var&lt;/code&gt;!
Мы совсем забыли о том, что &lt;code&gt;var&lt;/code&gt; отличается от &lt;code&gt;val&lt;/code&gt; наличием возможности изменить это значение, а как мы помним,
ковариантность возможна только в случае, если вы запретите любые изменения значения. Заменим var на val&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(val contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот и всё. Теперь наш класс Container ковариантен параметру-типу T, это означает, что мы легко можем использовать следующую
конструкцию:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инвариантность как рукой сняло! Но чем мы за это заплатили?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
val container2: Container&amp;lt;Number&amp;gt; = container
container2.contained = 4.0 //не компилируется, т.к. нельзя менять значение, зато мы
// защищены от ошибок как с Java массивами
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы видите теперь тип &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; наследник типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, благодаря чему мы можем свободно присваивать его переменным
типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, но не можем менять значения типа T и это правильно. Представьте, если бы последняя строчка
компилировась. Это значит, что через свойство contained было бы записано Double значение! Получается, что переменная
container с типом &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; содержала бы не Int, а Double, ведь и container, и container2 это две ссылки на один и
тот же объект в памяти. И при попытке получения container.contained мы бы словили &lt;code&gt;ClassCastException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ковариантность на уровне класса - дело хорошее, оно гребёт под себя весь класс и заставляет нас не менять значения, но, что
если нам не нужна ковариантность для всего класса? Пора разобраться с ковариантностью на месте использования.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-месте-использования&#34;&gt;Ковариантность на месте использования&lt;/h4&gt;

&lt;p&gt;Один из мощных механизмов управления иерархиями обобщенных типов это ковариантность на уровне объявления. Вспомним нашу
первую версию инвариантного контейнера:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если наш класс не ковариантен какому-либо параметру T, то мы можем свободно менять его значения как хотим:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val sourceContainer: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
sourceContainer.contained = 4 // компилируется
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А в тот момент, когда нам понадобится завести общую переменную под контейнеры с разными параметрами-типами, мы сможем это сделать, воспользовавшись
ковариантностью на месте использования (проекцией типа).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val covariantContainer: Container&amp;lt;out Number&amp;gt; = sourceContainer
covariantContainer.contained = 4 
/*  не компилируется, работаем с переменной у которой тип ковариантен параметру-типу
    значит нельзя менять значения, т.к. мы не знаем исходный тип, 
    там может быть любой контейнер с параметром-типом наследником Number
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря, ковариантности на уровне объявления мы можем делать многие вещи очень гибко, например, написать следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T: Any&amp;gt; { //что такое T: Any вы узнаете чуть позже
    /* 
        Пусть на момент создания контейнера мы еще не знаем,
        что конкретно он будет содержать, но знаем точно, что 
        что-то с некоторым типом T он должен, следовательно после 
        создания, рано или поздно, мы поменяем значение поля contained,
        а значит оно по определению не может быть val. В такой ситуации,
        мы не можем объявлять ковариантность на уровне класса
     */
    lateinit var contained: T

    override fun toString(): String {
        return &amp;quot;Container(contained=$contained)&amp;quot;
    }

}

/*
    Возвращаемый тип Container&amp;lt;out Number&amp;gt; создает ковариантность
    на месте использования, следовательно, из метода мы возвращаем 
    контейнер, который типизирован чем-то ниже в иерархии наследования
 */
fun createIntContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Int&amp;gt;()
    container.contained = 42
    return container
}

fun createDoubleContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Double&amp;gt;()
    container.contained = 42.0
    return container
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    var covariantContainer = createIntContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
    covariantContainer = createDoubleContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вывод в консоли:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Container(contained=42)
Container(contained=42.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом, мы успешно хранили в одной переменной контейнеры с разным параметром-типом, при том, что сам контейнер
инвариантен по своему параметру-типу Т.&lt;/p&gt;

&lt;p&gt;С ковариантностью разобрались, осталась контравариантность.&lt;/p&gt;

&lt;h3 id=&#34;контравариантность&#34;&gt;Контравариантность&lt;/h3&gt;

&lt;p&gt;Кроме того, чтобы описывать классы как producer&amp;rsquo;ы, иногда, нам может понадобиться
описать классы как consumer&amp;rsquo;ы или &lt;strong&gt;потребители&lt;/strong&gt;. Давайте рассмотрим следующую иерархию типов:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Пользователь
   /           \
Работник  Администратор   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пусть перед нами стоит задача написать логгер тех, кто входит в систему. Каждый пользователь системы имеет логин и именно его
мы будем распечатывать.&lt;/p&gt;

&lt;p&gt;Объявление такой иерархии типов может выглядеть, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;open class User(var login: String)

class Worker(login: String): User(login)

class Admin(login: String): User(login)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим класс Printer, который инкапсулирует в себе логику печати:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;T: User&amp;gt; {
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пока класс инвариантен и в большинстве случаев этого будет достаточно благодаря автоматическому приведению типов. Подумайте,
если бы мы передали в метод print объект типа Admin, то он спокойно был бы принят компилятором и приведен к верней границе
обобщенного типа User, но все приложения разные. Допустим, у нас есть метод &lt;code&gt;printAdmin&lt;/code&gt;, который знает какие предобработки нужно
сделать, а затем вызывает правильный метод у объекта класса &lt;code&gt;Printer&lt;/code&gt;. Напишем метод &lt;code&gt;printAdmin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun printAdmin(printer: Printer&amp;lt;Admin&amp;gt;, admin: Admin) {
    //admin specific
    printer.print(admin)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такой метод в своём использовании сужает вариативность нашего принтера, теперь принтер должен уметь печатать именно администратора.
Принтер для работника здесь не подойдет, а подойдет ли принтер для пользователя в принципе? Почему бы и нет, админ - тоже пользователь,
значит мы должны уметь печатать его тем же принтером, что и других пользователей. Получается, если Админ наследуется от Пользователя, то
принтер пользователя, должен быть наследником принтера админа (только в этом случае мы сможем безопасно привести тип
&lt;code&gt;Printer&amp;lt;User&amp;gt;&lt;/code&gt; к типу &lt;code&gt;Printer&amp;lt;Admin&amp;gt;&lt;/code&gt;). За сим мы наблюдаем разворот иерархии в другую сторону - это и обозначают сложным
словом контравариантность. Схематично контравариантность можно обозначить следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   User         Printer&amp;lt;Admin&amp;gt;       
    ↑     →         ↑
  Admin         Printer&amp;lt;User&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы, уверен, уже запомнили, обобщенные типы сами по себе инвариантны, по этому следующий код не скомпилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, мы можем это изменить. Для этого в нашем арсенале есть ключевое слово &lt;code&gt;in&lt;/code&gt;. Применять мы можем его как на уровне объявления,
так и на уровне использования, аналогично ковариантной аннотации обобщенного типа &lt;code&gt;out&lt;/code&gt;. Выглядит применение на уровне класса
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;in T: User&amp;gt; { //появился in
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Компилятор будет всячески не давать заполучть T из объектов типа контравариантного типу-параметру. После манипуляций выше наш
код ниже компилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И печатает:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User admin is logged in
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;producer-out-consumer-in&#34;&gt;Producer Out, Consumer In&lt;/h2&gt;

&lt;p&gt;В классической книге Effective Java автор Joshua Bloch предлагает аббревиатуру PECS для запоминания правила использования
ключевых слов extends и super в обобщенных типах Java. Аббревиатура гласит, &lt;code&gt;Producer Extends, Consumer Super&lt;/code&gt;, что
означает если класс является Producer&amp;rsquo;ом обобщенного типа, то необходимо использовать ключевое слово extends, а если потребителем, то
super. В Kotlin всё на много проще. Хотя мы можем переизобрести аббревиатуру блоха POCI (Producer Out, Consumer In),
это того не стоит. На самом деле, ключевые слова out и in говорят сами за себя, только думать нужно не в терминах иерархии типов,
а, скорее, думать о том как перемещаются данные. Если ваш класс поставляет обобщенно-типизированные значения наружу,
то вам нужен &lt;code&gt;out&lt;/code&gt;, а если класс потребляет значения обобщенного типа, то нужен &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;верхняя-граница-обобщенного-типа&#34;&gt;Верхняя граница обобщенного типа&lt;/h2&gt;

&lt;p&gt;Как вы уже заметили, несколько раз за статью я использовал конструкции вида &lt;code&gt;&amp;lt;T: SomeClass&amp;gt;&lt;/code&gt;. Прежде всего я хочу вас спросить,
а какой тип находится на вершине иерархии типов в Kotlin? Аналогично Object в Java, к чему можно привести любой тип?
Правильным ответом будет &lt;code&gt;Any?&lt;/code&gt;. Сам по себе класс &lt;code&gt;Any&lt;/code&gt; это аналог &lt;code&gt;Object&lt;/code&gt;, однако, в следствие поддержки Nullable и не
Nullable типов в Kotlin мы получили &lt;code&gt;Any?&lt;/code&gt;. Фактически, &lt;code&gt;Any?&lt;/code&gt; соответствует любому типу и &lt;code&gt;null&lt;/code&gt;, а &lt;code&gt;Any&lt;/code&gt; только любому типу.
Подробнее об иерархии типов я предлагаю прочитать статью, которую вы найдете в последнем разделе &amp;ldquo;Бонус&amp;rdquo;. Обобщенные
типы ограничены сверху максимально широким типом, а именно &lt;code&gt;Any?&lt;/code&gt; из-за чего может возникать некоторое недопонимание в использовании их.
Следовательно, по умолчанию дженерик тип - Nullable, это означает, что свойства с таким типом могут принимать значения
&lt;code&gt;null&lt;/code&gt;, но когда мы будем работать с ними, то компилятор потребует удостовериться, что через свойство доступно не null значение.
Таким образом, когда мы пишем &lt;code&gt;&amp;lt;T: Any&amp;gt;&lt;/code&gt; мы явно говорим, что тип, указываемый в качестве конкретного варианта вместо
обобщенного типа не может содержать &lt;code&gt;null&lt;/code&gt;. Аналогично, мы можем понизить верхнюю границу по иерархии еще ниже и потребовать, например,
указывать в качестве типов только чила: &lt;code&gt;&amp;lt;T: Number&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Верхних границ может быть несколько, в этом случае необходимо указывать их в специальном разделяющем &lt;code&gt;where&lt;/code&gt; условии:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T) 
        where T: Number, 
              T: Comparable&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Аналогично для функции для которой объявлен обобщенный тип.&lt;/p&gt;

&lt;h2 id=&#34;star-projection&#34;&gt;Star-Projection&lt;/h2&gt;

&lt;p&gt;Часто мы сталкиваемся с так называемой &lt;em&gt;проекцией типов&lt;/em&gt;. Простым языком, это ограничение типа на месте использования. Например,
мы не хотим, чтобы в наш контейнер могли по ошибке что-то записать внутри метода, для этого ограничиваем тип:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;out Number&amp;gt;) {
    container.contained = 4 //не компилируется    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря out здесь мы можем только читать из контейнера, но не записывать. В примерах выше мы обсуждали это поведение.&lt;/p&gt;

&lt;p&gt;Однако, иногда возникает ситуация, что у нас нет информации о необходимом нам типе проекции, но мы знаем, что Container, к примеру, имеет
верхнюю границу для ковариантного параметра-типа - Number и нам этого достаточно. Тогда, мы можем воспользоваться star-projection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;*&amp;gt;) { // символ *
    println(container.value) // мы можем печатать значения, т.к. знаем верхнюю границу обобщенного типа
    container.value = 4 // но мы не можем писать значения, т.к. не знаем типа
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для ковариантных параметров * означает &amp;ldquo;могу читать значения с типом верхней границы обобщенного типа&amp;rdquo;.
Для контравариантных параметров * означает &amp;ldquo;не могу ничего безопасно писать&amp;rdquo;
Для инвариантных параметров символ * означает: &amp;ldquo;при чтении аналогично * для ковариантного, при записи аналогично * для контравариантного параметра&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;стирание-типов&#34;&gt;Стирание типов&lt;/h2&gt;

&lt;p&gt;Аналогично с Java в Kotlin происходит стирание информации об обобщенных типах, т.е. обобщенные типы - наши помощники только
на этапе компиляции. На этапе выполнения кода информации уже нет, однако, есть хитрые способы, которые вы можете найти для
частного решения в некоторых случаях.&lt;/p&gt;

&lt;h2 id=&#34;reified-generics-и-inline-function&#34;&gt;Reified Generics и inline function&lt;/h2&gt;

&lt;p&gt;Модификатор inline для функций позволяет встраивать код в место вызова без какого-либо обращения к реальной функции.
Такой модификатор позволяет не создавать слишком много лямбд, которые передаются в методы и является небольшой оптимизацией.
Кроме того, этот модификатор позволяет сохранить информацию об обобщенных типах объявленных в рамках методов даже на этапе выполнения. Рассмотрим
небольшой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T: Number&amp;gt; printClass(value: T) {
    println(T::class)
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    printClass(4)
    printClass(4.0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Результат выполнения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class kotlin.Int
class kotlin.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ключевое слово &lt;code&gt;reified&lt;/code&gt; говорит о том, что нужно иметь доступ к информации о типе T. Таким образом, в некоторых случаях,
даже явно не передавая тип, мы можем работать с ним.&lt;/p&gt;

&lt;h2 id=&#34;резюме&#34;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;Подводя итоги статьи, хочется отметить, что обобщенные типы - довольно сложная часть как Java, так и Kotlin и их понимание
крайне важно для бесстрашного построения гибких классов, готовых к разностороннему применению. Можно долго спорить,
что понятнее Java программисту, который пришел в Kotlin, Java синтаксис обобщенных типов или &lt;code&gt;out&lt;/code&gt; и &lt;code&gt;in&lt;/code&gt;. На мой взгляд,
если у вас есть понимание того для чего вы применяете обобщенные типы, то никакой синтаксис не помешает вам их использовать.&lt;/p&gt;

&lt;h2 id=&#34;бонус&#34;&gt;Бонус&lt;/h2&gt;

&lt;p&gt;Погружаясь в тему обобщенных типов вы можете посмотреть видео с конференции JPoint2016 &amp;ldquo;Неочевидные Дженерики&amp;rdquo; об обобщенных типах из Java
вот &lt;a href=&#34;https://www.youtube.com/watch?v=_0c9Fd9FacU&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Статья об &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;иерархии типов в Kotlin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Альтернативное &lt;a href=&#34;https://kotlinlang.ru/docs/reference/generics.html&#34; target=&#34;_blank&#34;&gt;чтение&lt;/a&gt; на тему дженериков&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Instant View in Action</title>
      <link>https://i-osipov.ru/post/instant-view-in-action/</link>
      <pubDate>Sat, 20 Jan 2018 00:00:00 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/instant-view-in-action/</guid>
      <description>

&lt;p&gt;Telegram идет большими шагами по планете и масштабы постоянно растут. Многие из нас часто читают
статьи на каналах, нажимают кнопку Instant View и вот, статья уже перед нами, но как это получилось?
Instant View работает по первой ссылке, но почему не по каждой? Сегодня мы с вами разберемся как взять
свой сайт и адаптировать Instant View к нему. Действовать мы будем на примере i-osipov.ru.&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;h1 id=&#34;с-чем-мы-имеем-дело&#34;&gt;С чем мы имеем дело&lt;/h1&gt;

&lt;p&gt;Под капотом у i-osipov.ru находится hugo, hugo это генератор статического контента. Для понимания,
когда я пишу пост - у меня есть отдельный проект на диске в котором есть предопределенные директории.
В директориях лежит контент, например, в &lt;em&gt;content/post/*&lt;/em&gt; находятся все посты на сайте, а при
выполнении команды hugo в терминале стоя в корневой папке у меня генерируется статика, html + css + js,
используется преднастроенная тема, в итоге статика выгружается в GitHub репозиторий, публикуется с
помощью GitHub Pages, а i-osipov.ru лишь альтернативное имя, через которое доступен контент.&lt;/p&gt;

&lt;p&gt;Как вы можете догадаться, формат статики определяю не я, определяет hugo. Теперь передо мной стоит
задача разобраться в этом формате и научить Telegram генерировать Instant View для моего сайта.
Прежде всего, источниом информации по этому вопросу для меня является
&lt;a href=&#34;https://instantview.telegram.org/&#34;&gt;instantview.telegram.org&lt;/a&gt;. С этой страницы мы узнаем о том, что
Instant View (&lt;strong&gt;IV&lt;/strong&gt;) - это механизм позволяющий открывать ваши ссылки прямо в телеграм, это отличный user
friendly способ подать ваш контент, ваш сайт может быть не оптимизирован для мобильных устройств
(это нас не так волнует, т.к. у hugo с этим почти всё в порядке), а слово &lt;em&gt;Instant&lt;/em&gt; означает мгновенную
загрузку и кеширование на серверах телеграмма.&lt;/p&gt;

&lt;h1 id=&#34;как-работает-instant-view&#34;&gt;Как работает Instant View&lt;/h1&gt;

&lt;p&gt;Втавка ссылки на внешний контент в текстовое поле влечет за собой цепочку событий: генерируется link preview -
это короткая инфрмация о том какой контент доступен по ссылке, специальный &lt;em&gt;Instant View Bot&lt;/em&gt; проверяет,
есть ли шаблон IV для указанного сайта. После &lt;a href=&#34;https://instantview.telegram.org/#publishing-templates&#34;&gt;публикации шаблона&lt;/a&gt;
он становится доступен всем пользователям Telegram. До процесса глобальной публикации вы можете давать ссылку
читателям без процесса публикации и подтверждения, но об этом в разделе &lt;em&gt;Публикация&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;создание-instant-view&#34;&gt;Создание Instant View&lt;/h1&gt;

&lt;h2 id=&#34;редактор-instant-view&#34;&gt;Редактор Instant View&lt;/h2&gt;

&lt;p&gt;С этого момента начинается процесс разработки, так что если у вас есть к чему прикрутить IV, то самое время взять ноутбук и приготовится.&lt;/p&gt;

&lt;p&gt;Все манипуляции вашими IV происходят на странице &lt;a href=&#34;https://instantview.telegram.org/my&#34;&gt;instantview.telegram.org/my&lt;/a&gt;
При первом входе вас попросят залогиниться через telegram. Далее вы даёте ссылку на любой контент (пост на котором мы будем
отлаживать шаблон) на вашем сайте.
Что именно вы выберете - не так важно, главное, чтобы верстка контента была примерно одинаковой. Я возьму один из последних постов.
Редактор открылся, теперь мы видим следующую картину&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/instant_view_in_action/iv_editor.jpg&#34; alt=&#34;InstantViewEditor&#34; title=&#34;Instant View Editor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Перед нами 3 рабочих пространства. Слева мы видим подгруженную, словно с телефона, версию страницы блога, по центру
расположилось поле для указания правил (это наше рабочее пространство), а справа мы видим результат - то, как примерно
будет выглядеть IV. На скриншоте по центру по умолчанию пусто, но для полноты я вписал туда &lt;code&gt;body: //article&lt;/code&gt;. Такая
простая конфигурация говорит о том, что тело нашего Instant View будет парситься Instant View Bot&amp;rsquo;ом прямо из html тега
под названием &lt;em&gt;article&lt;/em&gt; (выбранного благодаря xpath). Это первое из двух обязательных полей для создания Instant View, дальше мы разберем правила,
которые помогут сформировать качественное встроенное представление внутри Telegram из того контента, который доступен на
странице. При необходимости, вы можете перезагрузить исходную страницу и сохранить ваши описанные правила с помощью
&lt;code&gt;ctrl + S&lt;/code&gt; или &lt;code&gt;cmd + S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;В нижней части страницы располагается результат последней операции и вывод функции @debug на которую мы взглянем в
разделе &lt;em&gt;Дебаггер&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;С помощью символа &lt;code&gt;#&lt;/code&gt; обозначается начало комментария, текст справа этого символа не интерпритируется.&lt;/p&gt;

&lt;h2 id=&#34;панель-разработчика&#34;&gt;Панель разработчика&lt;/h2&gt;

&lt;p&gt;Важнейший инструмент на этапе построения Instant View это Панель разработчика в вашем браузере. К примеру, в Google
Chrome она открывается при нажатии &lt;code&gt;F12&lt;/code&gt; или &lt;code&gt;Ctrl + Shift + I&lt;/code&gt;, либо поищите в меню Дополнительные инструменты -
Инструменты разработчика.&lt;/p&gt;

&lt;h2 id=&#34;фильтрация-контента&#34;&gt;Фильтрация контента&lt;/h2&gt;

&lt;p&gt;Помните, что Instant View предназначен для относительно стачесных статей, центральная страница динамичного сайта -
плохой кандидат для IV. Следовательно и не каждая станица интересующего сайта нам подойдет. Часто, статьи обособляются
html тегом &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; и это знак того, что на странице есть статья. Для того, чтобы по ошибке Instant View Bot не интерпретировал
ссылки на другие страницы сайта как встроенные, нам необходимо добавить условия.&lt;/p&gt;

&lt;h2 id=&#34;условия&#34;&gt;Условия&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#conditions&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Условия начинаются либо с &lt;code&gt;?&lt;/code&gt;, либо с &lt;code&gt;!&lt;/code&gt; по следующему формату:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?condition:  xpath_query   # пример условия
!condition:  regexp        # в правой части условия находится регулярное выражение
?condition                 # условие без параметров
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если условия следуют друг за другом, то они интерпретируются как единый блок, где &lt;code&gt;?&lt;/code&gt;-правила это ИЛИ, а &lt;code&gt;!&lt;/code&gt;-правила
это И. В блоке условий должно быть как минимум одно условие ИЛИ.&lt;/p&gt;

&lt;p&gt;Несколько блоков условий выглядят следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
# здесь мы пишем правила, которые применим когда на странице есть тег article

?exists: //content
# здесь мы пишем правила, которые применим когда на странице есть тег content, а тега article может и не быть

?exists: //content
!exists: //article
# здесь мы пишем правила, которые применим когда на странице и есть тег contentи тег article
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Конечно, кроме условия &lt;code&gt;exists&lt;/code&gt; существуют и другие, ниже их полный список на текущий момент:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?domain: regexp # проверяет соответствует ли домен регулярному выражению

?domain_not: regexp # проверят не запрещен ли домен

?path: regexp # проверяет путь до текущей страницы соответствует регулярному выражению

?path_not: regexp # проверяет, что путь не соответствует регулярному выражению

?exists: xpath_query # проверяет наличие узла на странице

?not_exists: xpath_query # проверяет отсутствие узла на странице

?true
# правила здесь будут применены всегда
?false
# правила здесь не применятся никогда (по сути место для неработающих правил)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для нашего примера я выбрал следующие условия:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
!domain: i-osipov\.ru
!path: /post/.+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Посты находятся всегда под i-osipov.ru/post/* и в каждом посте должен существовать тег &lt;em&gt;article&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;свойства&#34;&gt;Свойства&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#properties&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Свойства содержат в себе значения и имеют следующий формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;property: xpath_query
property: &amp;quot;Some string&amp;quot;
property: null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;По умолчанию свойства не переопределяются, т.е. если не нулевое значение было записано в свойство, то для того, чтобы
его переопределить, нужно испрользовать символ &lt;code&gt;!&lt;/code&gt;, т.е. конструкция &lt;code&gt;property!: //content&lt;/code&gt; сможет обновить свойство,
если правая часть вернет не возвращает пустой результат и не &lt;code&gt;null&lt;/code&gt;. Если же правая часть вернет пустой результат,
то значение не переопределится, для того, чтобы это произошло, необходимо воспользоваться &lt;code&gt;!!&lt;/code&gt;. В результате,
&lt;code&gt;property!!: //content&lt;/code&gt; перезапишет значение свойства вне зависимости от результата.&lt;/p&gt;

&lt;p&gt;Ранее, я упоминал о том, что есть два свойства, которые обязательно нужно определить. Мы уже познакомились со свойством
&lt;code&gt;body: //article&lt;/code&gt;, которое помогает Instant View Bot определить где же находится основной контент статьи. Второе,
обязательное к определению свойство это &lt;code&gt;title&lt;/code&gt;, например, правило &lt;code&gt;title: //article//h1&lt;/code&gt; выберет заголовок первого уровня внутри
блока статьи и объяснит IV Bot&amp;rsquo;у, через свойство &lt;em&gt;title&lt;/em&gt;, где же смотреть название статьи.&lt;/p&gt;

&lt;p&gt;Рассмотрим другие свойства, которые нам доступны из коробки:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Формат описания
название: тип # пояснение
Для создания свойства в конструкциях ниже тип нужно заменить конкретным значением

title: RichText # заголовок страницы
body: RichText # тело страницы
author: String # имя автора
author_url: URL # ссылка на автора
published_date: Unixtime # дата публикации
description: String # краткое описание для превью ссылки
image_url: Url # ссылка на фото для превью ссылки
document_url: Url # ссылка на документ для превью ссылки
channel: String # указатель на авторский канал, например, @channelName
cover: Media # Обложка страницы
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для нашего примера, я обозначу следующие свойства&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body: //article
title: //h1
channel: &amp;quot;@from_junior_to_senior&amp;quot;
description: //h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Наших текущих знаний хватает только на такие простые манипуляции, но даже их достаточно для минимального варианта.
Для полноты картины пока &amp;ldquo;захардкодим&amp;rdquo; остальные интересующие нас значения, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;author: &amp;quot;Ivan Osipov&amp;quot;
author_url: &amp;quot;https://i-osipov.ru&amp;quot;
published_date: &amp;quot;2017-07-23&amp;quot;
image_url: &amp;quot;https://i-osipov.ru/img/posts/how_to_create_telegram_bot/header.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В следующих разделах мы с вами перепишем этот хардкод, но пока так.&lt;/p&gt;

&lt;p&gt;Результат таких манипуляций ниже на скриншоте редактора:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/instant_view_in_action/iv_step1.jpg&#34; alt=&#34;Instant View. Шаг 1&#34; title=&#34;Instant View. Шаг 1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;типы-данных&#34;&gt;Типы данных&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#supported-types&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В главе выше мы затронули типы и прежде всего необходимо пояснить, что страница Instant View содержит разные типы.
Каждый тип ассоциирован с html тегом, например, тип &lt;code&gt;Header&lt;/code&gt; определяет объекты созданные на основе тегов &lt;code&gt;&amp;lt;h1&amp;gt; - &amp;lt;h4&amp;gt;&lt;/code&gt;.
У типов есть допустимые дочерние типы, по сути, это те, кто могут быть вложены внутрь. Благодаря типам, практически
весь контент под тегом &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; может быть распознан без дополнительных усилий. Типы важная, но при этом довольно
простая составляющая Instant View, по этому полный перечень с описанием доступен по
&lt;a href=&#34;https://instantview.telegram.org/docs#supported-types&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;На ваших страницах может быть представлен какой-либо код на опрежеденном языке, телеграм не поддерживает подстветку
синтаксиса, но они планируют сделать это в будущем. По этой причине, для больших блоков кода обособленных в &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;
желательно указывать аттрибут &lt;code&gt;data-language&lt;/code&gt;, как результат, подстветка кода в Instant View появится сама собой со
временем.&lt;/p&gt;

&lt;h2 id=&#34;переменные&#34;&gt;Переменные&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#variables&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Концепция переменных знакома вам из любого языка программирования. Здесь основное предназначение переменных - гибкое
манипулирование ими перед назначением их значений свойствам. Кратко, у нас есть идентификатор, который начинается с &lt;code&gt;$&lt;/code&gt;,
например, &lt;code&gt;$myvariable&lt;/code&gt; и есть значение. Идентификатор может быть только в нижнем регистре. Значение переменной может
быть xpath или строка, в последнем  случае переменная будет содержать
список из одного текстового элемента в котором определен заданный в строке текст. Кроме того, вы можете назначить
переменной &lt;code&gt;null&lt;/code&gt;, что позволяет сбросить значение в ней. Вы можете свободно менять значение переменной, если же вы
хотите назначить переменной значение только в том случае, если раньше никакое значение не было присвоено, то можно
воспользоваться символом &lt;code&gt;?&lt;/code&gt;, написанным после идентификатора, вот так &lt;code&gt;$myvariable?&lt;/code&gt;,
в том месте, где происходит смена значений.&lt;/p&gt;

&lt;p&gt;Резюмируя, мы можем менять значения переменных следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$images:  //img
$images: //img[@src]  # значение переменной $images будет переопределено
$images?: //article//img  # новое значение для переменной $images будет выставлено, если в переменной ничего не записано
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы объяснить вторую строчку и что же такое &lt;code&gt;//img[@src]&lt;/code&gt; давайте поговорим о расширенном XPath.&lt;/p&gt;

&lt;h2 id=&#34;расширенный-xpath&#34;&gt;Расширенный XPath&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#extended-xpath&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Прежде всего нужно сказать, что у нас есть чуть больше чем XPath для формирования выборки узлов html документа. Если вы пока не
знакомы с XPath, то самое время это сделать. Начать можно &lt;a href=&#34;https://ru.wikipedia.org/wiki/XPath&#34;&gt;отсюда&lt;/a&gt;. Кратко,
XPath это язык, который позволяет навигироваться по XML. Нtml и Xml родственные форматы, по этому мы можем навигироваться и
по Html.
Взглянем на дополнительные возможности, которые дает нам расширенный XPath от Telegram.&lt;/p&gt;

&lt;h3 id=&#34;относительный-xpath&#34;&gt;Относительный XPath&lt;/h3&gt;

&lt;p&gt;В разделе &lt;em&gt;Переменные&lt;/em&gt; мы узнали о таком типе правил как объявление переменных, здесь этот концепт нам пригодится.
Стандартный XPath выполняет поиск по всему документу (мы указываем абсолютное выражение для поиска, искать будем от
корня документа), однако, это порождает длинные цепочки описания путей до узлов. В расширенном XPath мы можем объяснить
в каком контексте необходимо выполнять поиск при помощи переменных. Представим, что у нас есть следующее html дерево.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;
    &amp;lt;article&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок 1 уровня&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;Заголовок 2 уровня&amp;lt;/h2&amp;gt;
    &amp;lt;/article&amp;gt;
&amp;lt;/body&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для навигации по такому дереву мы можем использовать стандартный XPath&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//article/h1 # находит &#39;Заголовок 1 уровня&#39;
//article/h2 # находит &#39;Заголовок 2 уровня&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Либо, так как мы изначально знаем о том, что поиск будет выполняться внутри узла &lt;code&gt;article&lt;/code&gt;, то можем воспользоваться
переменной и таким образом задать контекст:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$myArticle: //article
$myArticle/h1 # находит &#39;Заголовок 1 уровня&#39;
$myArticle/h2 # находит &#39;Заголовок 2 уровня&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;один-узел-вместо-нескольких&#34;&gt;Один узел вместо нескольких&lt;/h3&gt;

&lt;p&gt;Иногда, мы знаем, что XPath вернет нам несколько результатов, но мы хотим только первый, второй или любой другой из
них. По умолчанию XPath возвращает список узлов, однако, для того, чтобы сузить область поиска мы можем явно выбрать
один из полученных узлов с помощью выражения &lt;code&gt;(xpath_query)[n]&lt;/code&gt;, здесь &lt;code&gt;n&lt;/code&gt; - это порядковый номер узла в списке,
полученном с помощью &lt;code&gt;xpath_query&lt;/code&gt;. Нумерация начинается с 1, либо на месте &lt;code&gt;n&lt;/code&gt; можно записать &lt;code&gt;last()&lt;/code&gt; и тогда
будет выбран последний элемент. Такой синтаксис поддерживается только для всего выражения целиком. Ниже несколько примеров:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$headers:    //h1                    # все &amp;lt;h1&amp;gt; узлы на странице
$header2:    (//h1)[2]               # второй &amp;lt;h1&amp;gt; узел на странице
$header2:    ($headers)[2]           # аналогично предыдущему
$last_link:  ($header2//a)[last()]   # последняя ссылка (&amp;lt;a&amp;gt;) внутри контекста $header2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;выбор-по-css-классу&#34;&gt;Выбор по css классу&lt;/h3&gt;

&lt;p&gt;Отличный инструмент, который мы получили с расширенным XPath это выражение &lt;code&gt;has-class(&amp;quot;class&amp;quot;)&lt;/code&gt;, которое позволяет выбирать
узлы имеющие определенный класс. Это выражение - сокращение следующего
&lt;code&gt;contains(concat(&amp;quot; &amp;quot;, normalize-space(@class), &amp;quot; &amp;quot;), &amp;quot; class &amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Я покажу практическое применение инструмента на своём же блоге, для которого настраиваю Instant View. Ранее мы присвоили
свойствам title и description следующие значения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title: //h1
description: //h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но это не до конца верно, правильнее ограничить контекст поиска и мы можем это сделать. Все заголовки документа могут
быть доступны только через &lt;code&gt;div&lt;/code&gt; элемент с классом &lt;code&gt;post-heading&lt;/code&gt;, зная это, мы можем воспользоваться &lt;code&gt;has-class&lt;/code&gt; и
получим следующее обновление для нашего шаблона.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$header: //div[has-class(&amp;quot;post-heading&amp;quot;)]
title: $header/h1
description: $header/h2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;элемент-одного-уровня&#34;&gt;Элемент одного уровня&lt;/h3&gt;

&lt;p&gt;XPath дает нам мощные возможности для поиска, но не всегда они легко читаемы, последние два улучшения - это сокрщенные
формы стандарных XPath выражений. В стандартном XPath мы можем донянуться до предшествующего &lt;code&gt;sibling&lt;/code&gt; узла (по русски это
&amp;ldquo;элемент одного уровня&amp;rdquo;) следующим образом: &lt;code&gt;preceding-sibling::*[1]/self&lt;/code&gt;, расширенный XPath дает нам сокращения в виде
&lt;code&gt;prev-sibling&lt;/code&gt;, можно сравнить в применении:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$divsAfter: //div[./preceding-sibling::*[1]/self::img] # Собирает все div элементы предшествующие узлам img

$divsAfter: //div[./prev-sibling::img] # Сокращенная форма того же самого
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для последующих элементов есть аналогичное выражение &lt;code&gt;next-sibling&lt;/code&gt;, которое является сокращением
&lt;code&gt;following-sibling::*[1]/self&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;функции&#34;&gt;Функции&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#functions&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Пожалуй важнейший и очень гибкий вид правил - функции. С их помощью вы сможете удалять ненужные элементы, производить
трансформации одних элементов в другие и так далее. Функции начинаются с символа &lt;code&gt;@&lt;/code&gt; и есть несколько разных форматов
их применения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@function:                 xpath_query   # функция без параметров
@function(param):          xpath_query   # дополнительный параметр указывается в скобках
@function(p1 p2):          xpath_query   # параметры могут быть разделены пробелом
@function(p1, &amp;quot;param #2&amp;quot;): xpath_query   # или запятой и заключены в кавычки при необходимости
@function:                 &amp;quot;Some text&amp;quot;   # вместо xpath можно использовать строки
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;У функции определяется основной аргумент, например, xpath выражение или строка. Основной аргумент записывается справа
от &amp;ldquo;:&amp;ldquo;. В случае строки в качестве аргумента, на самом деле, будет передан список с одним тектовым элементом, который
содержит указанный текст.&lt;/p&gt;

&lt;p&gt;Разберем пример. Внутри тега &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, который содержит контент статьи, находится блок с комментариями, это встроенные
Disqus комментарии. Однако, эти комментарии не поддерживаются в Instant View и нам необходимо их исключить. Для его
мы воспользуемся функцией &lt;code&gt;@remove&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Открыв консоль разработчика в Chrome и выбрав элемент, который я хочу удалить, я обнаружил, что в DOM дереве исходной
страницы есть два элемента. Эта часть дерева выглядит примерно так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;...
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;amp;lt;a href=&amp;quot;http://disqus.com/?ref_noscript&amp;quot;&amp;amp;gt;comments powered by Disqus.&amp;amp;lt;/a&amp;amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&amp;quot;http://disqus.com&amp;quot; class=&amp;quot;dsq-brlink&amp;quot;&amp;gt;comments powered by &amp;lt;span class=&amp;quot;logo-disqus&amp;quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Узел &lt;code&gt;noscript&lt;/code&gt; довольно просто обнаружить и удалить. &lt;code&gt;$body&lt;/code&gt; ниже это отсылка к телу статьи, к свойству
&lt;code&gt;body&lt;/code&gt;, которое мы проинициализировали в самом начале используя XPath &lt;code&gt;//article&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Со ссылкой, следующей за узлом &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt; всё не так очевидно, здесь мне помогла функция &lt;code&gt;@debug&lt;/code&gt;, благодаря этой
функции вы можете понять находит ли XPath желаемый элемент или нет. Применение выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@debug: $body//noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Результат применения вы увидите в самом низу страницы редактора.
Здесь я могу применить расширенный XPath и сказать &amp;ldquo;Удали все узлы &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; перед которыми есть узел того же уровня &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Успех? Нет! Оказывается, из-за того, что сначала мы удалили &lt;em&gt;noscript&lt;/em&gt;, а затем опирались на него при поиске &lt;em&gt;a&lt;/em&gt;, то
интерпритатор в конце не нашел ни одного &lt;em&gt;a&lt;/em&gt; у которого предшественник &lt;em&gt;noscript&lt;/em&gt;. Понять это получилось опять же,
благодаря функции &lt;code&gt;@debug&lt;/code&gt;. В результате, поменяв местами вызовы функции &lt;code&gt;@remove&lt;/code&gt; мы последовательно удалили оба
не нужных элемента.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]   # Сначала удаляем ссылку следующую за noscript
@remove: $body//noscript                    # Затем удаляем сам noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Также функции могут явно или неявно работать со специальными переменными.&lt;/p&gt;

&lt;h3 id=&#34;специальные-переменные&#34;&gt;Специальные переменные&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#special-variables-and&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Когда мы работаем с функцией у которой справа записан xpath, то мы можем на следующей строке получитьрезультат этого
выражения не повторяя его. Этот результат хранится в переменной &lt;code&gt;$$&lt;/code&gt;, т.е. мы можем сделать, например, так&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;description: $header/h2
@debug: $$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После чего внизу редактора увидим, какой же результат мы записали в description. Также каждая функция выполняет некую
трансформацию, обрабатывает входящие элементы и получает какой-то результат. Собственно, сам результат можно получить
из переменной &lt;code&gt;$@&lt;/code&gt;. Итак:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; - содержит результат самого последнего XPath выражения;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; - содержит значение возвращаемое последней запущенной функцией.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;description: $header/h2     # определяет описание страницы
@debug                      # выводит описание, по умолчанию вместо xpath подразумевается $$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;другие-функции&#34;&gt;Другие функции&lt;/h3&gt;

&lt;p&gt;В конце этого руководства я приведу описание каждой из доступных функций, но для специфик применения, предлагаю обратиться к оригинальной
документации по ссылкам. См. приложение А.&lt;/p&gt;

&lt;p&gt;Используя изученные в приложении А функции мы можем, для начала, улучшить последний процесс удаления хвостов от disqus.
Раньше мы удаляли хвосты так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@remove: $body//a[prev-sibling::noscript]   # Сначала удаляем ссылку следующую за noscript
@remove: $body//noscript                    # Затем удаляем сам noscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь мы воспользуемся функцией &lt;code&gt;@combine&lt;/code&gt;, которая склеивает заданные узлы в один &lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt; узел. А затем удалим результат
склейки.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@combine: $body//noscript/next-sibling::a
@remove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Нам осталось разобраться, как правильно обозначить автора, дату публикации и ссылку на картинку для превью.&lt;/p&gt;

&lt;p&gt;Для получения картинки, воспользуемся функцией &lt;code&gt;@background_to_image&lt;/code&gt;, она преобразует стиль в элемент &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;.
Результат функции присвоим переменной &lt;code&gt;$main_image&lt;/code&gt;, значение атрибутта &lt;code&gt;src&lt;/code&gt; присвоим свойству &lt;code&gt;image_url&lt;/code&gt;, а саму картинку
добавим в начало статьи. Всё это делается следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@background_to_image: //header[has-class(&amp;quot;intro-header&amp;quot;)]   # нашли картинку
$main_image: $@                                             # сохранили узел в переменную

@prepend_to($body): $main_image                             # вставили в начало контента
image_url: $main_image/@src                                 # обозначили её как картинку для preview
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инструменты разработчика Chrome подсказывают, что оставшаяся интересующая нас информация находится в той же части
дерева элементов, что и заголовки для статей, по этому воспользуемся, уже определенным ранее &lt;code&gt;$header&lt;/code&gt;. Нам осталось
извлечь из дерева имя автора и дату публикации. Извлечение данных, я сделал следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$extra_meta: $header/span       # уточняем поддерево с метаданными

$author: ($extra_meta/a)[1]     # выбираем первую ссылку в списке
author: $author/text()          # извлекаем её название, в моем случае это автор

@match(&amp;quot;Дата публикации: ([0-9]{4}-[0-9]{2}-[0-9]{2})&amp;quot;, 1): $extra_meta # в поддереве с метаданными ищем дату по регулярному выражению и забираем первую группу
published_date: $@              # присваиваем результат поиска
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;встраиваемые-элементы&#34;&gt;Встраиваемые элементы&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#embedded-elements&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В вашем случае могут быть медиа элементы, которые вы так же хотели бы встроить. Сегодня телеграм поддерживает следующие
сервисы для встраивания в Instant View:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Youtube&lt;/li&gt;
&lt;li&gt;Vimeo&lt;/li&gt;
&lt;li&gt;Tweets &amp;amp; Twitter Videos&lt;/li&gt;
&lt;li&gt;Facebook Posts &amp;amp; Videos&lt;/li&gt;
&lt;li&gt;Instagram&lt;/li&gt;
&lt;li&gt;Giphy&lt;/li&gt;
&lt;li&gt;SoundCloud&lt;/li&gt;
&lt;li&gt;GithubGist&lt;/li&gt;
&lt;li&gt;Aparat&lt;/li&gt;
&lt;li&gt;VK.com Videos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;включения-системные-правила&#34;&gt;Включения (системные правила)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#include&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Включения - это системные правила и вам их нет необходимости использовать для собственных нужд, но знание того что
это пригодится для понимания работы Telegram Instant View.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ core.telegram.org # вставляет блок правил, который используется для core.telegram.org
?not_exists: $body  # если не найдет, то ...
+ telegram.org      # вставляет другой блок
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Я вижу один вариант использования. Это если ваш сайт на одном движке с кем-то, для кого уже есть готовые правила&lt;/p&gt;

&lt;h2 id=&#34;обработка-страниц&#34;&gt;Обработка страниц&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#processing-pages&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Все страницы обрабатываются по следующим правилам:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Url: http://example.com/some_page.html
+ example.com
?true
+ ..after
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если же страница находится на поддомене, то она обрабатывается так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Url: http://some.subdomain.example.com/some_page.html
+ some.subdomain.example.com
?not_exists: $body
+ subdomain.example.com
?not_exists: $body
+ example.com
?true
+ ..after
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Следовательно, сначала Instant View Bot ищет шаблон для полного домена и если он не находит проинициализированного свойства
&lt;em&gt;body&lt;/em&gt;, то понижает уровнь домена и ищет шаблон для него. Блок правил &lt;code&gt;..after&lt;/code&gt; выполняется для всех доменов.&lt;/p&gt;

&lt;h2 id=&#34;instant-view-для-поддоменов&#34;&gt;Instant View для поддоменов&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#working-with-subdomains&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Если страница обрабатывается для поддомена, то необходимо вручную выбрать уровень домена, который необходим в левом
верхнем углу редактора.&lt;/p&gt;

&lt;h2 id=&#34;публикация&#34;&gt;Публикация&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://instantview.telegram.org/#publishing-templates&#34;&gt;Документация&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Для того, чтобы посмотреть результат нажмите на кнопку View In Telegram и если у вас есть десктопное приложение, то в нем
вам предложат отправить кому-нибудь ссылку, которая будет открывать ваш тестовый пример через Instant View.&lt;/p&gt;

&lt;p&gt;Публикация для всех пользователей Telegram происходит только после подтверждения вашего шаблона командой Telegram.
До этого момента вы можете распространять ссылки с истользованием шаблона, даже без подтверждения. Для этого вам нужно
составить ссылку в формате: &lt;code&gt;t.me/iv?url=...&amp;amp;rhash=...&lt;/code&gt;, где url это ссылка на публикацию, а &lt;code&gt;rhash&lt;/code&gt; - идентификатор
шаблона.&lt;/p&gt;

&lt;h2 id=&#34;бонус-instant-view-и-cloudflare&#34;&gt;Бонус. Instant View и Cloudflare&lt;/h2&gt;

&lt;p&gt;В своих прошлых статьях, я рассказывал о том, что в качестве DNS серверов для i-osipov.ru используются DNS сервера
Cloudflare. Кроме того, Cloudflare это прокси защищающий от DDOS и при реализации Instant View я заметил одну небольшую
особенность. Из коробки этот замечательный сервис предоставляет услугу, которая называется &amp;lsquo;Email protection&amp;rsquo;, по сути
в определенном наборе ситуаций, которые можно детектировать как &amp;ldquo;бот, который обходит интернет и собирает email&amp;rsquo;ы для
спама&amp;rdquo;, Cloudflare заменят все email&amp;rsquo;ы обсусцирует email&amp;rsquo;ы на странице. Instant View Bot такой же подозрительный тип,
но всё ради безопасности. Тем ни менее, в статье про то &amp;ldquo;как написать бота для телеграма&amp;rdquo; есть полная форма команды
оправляемая телеграм боту, напомню что выглядит она вот так: &lt;code&gt;/command@BotName&lt;/code&gt;. Проблема в том, что cloudflare распознает
как email всё что справа от слеша и отдает неправильную страничку боту. Как это исправить? Все подробности есть
&lt;a href=&#34;https://support.cloudflare.com/hc/en-us/articles/200170016-What-is-Email-Address-Obfuscation-&#34;&gt;здесь&lt;/a&gt;, если коротко,
то вы должны встроить в код страницы тег &lt;code&gt;&amp;lt;!--email_off--&amp;gt; здесь cloudflare не будет защищать email&#39;ы &amp;lt;!--/email_off--&amp;gt;&lt;/code&gt;.
Да, вы правильно поняли, для того, чтобы показать вам команду для бота и в этой статье, мне пришлось снова встроить
комментарии отключающие cloudflare email protection.&lt;/p&gt;

&lt;h2 id=&#34;шаблон-для-i-osipov-ru&#34;&gt;Шаблон для i-osipov.ru&lt;/h2&gt;

&lt;p&gt;В итоге, мы получили следующий шаблон:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;?exists: //article
!domain: i-osipov\.ru
!path: /post/.+

body: //article

$header: //div[has-class(&amp;quot;post-heading&amp;quot;)]
title: $header/h1
description: $header/h2

channel: &amp;quot;@from_junior_to_senior&amp;quot;

$extra_meta: $header/span

$author: ($extra_meta/a)[1]
author: $author/text()

author_url: &amp;quot;https://i-osipov.ru&amp;quot;

@match(&amp;quot;Дата публикации: ([0-9]{4}-[0-9]{2}-[0-9]{2})&amp;quot;, 1): $extra_meta
published_date: $@

@background_to_image: //header[has-class(&amp;quot;intro-header&amp;quot;)]
$main_image: $@

@prepend_to($body): $main_image
image_url: $main_image/@src

@combine: $body//noscript/next-sibling::a
@remove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На самом деле в шаблон входит еще и обнотка неподдерживаемых таблиц, вместо них можно отображать ссылку на сайт с
полным контентом. Как это сделать вы можете подглядеть в публичком шаблоне для i-osipov.ru или поразмышлять самостоятельно.&lt;/p&gt;

&lt;h2 id=&#34;заключение&#34;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Telegram Instant View это мощный инструмент, который поможет вам интегрировать ваш контент в инфраструктуру Telegram.
Относиться к Instant View можно по разному, но на мой взгляд, если вы можете сделать жизнь вашего читателя еще лучше -
сделайте это. Со своей стороны, я надеюсь, что этот документ поможет вам легко разобраться в создании Instant View и
улучшить UX ваших статей. Для достижения совершенства обратите внимание на
&lt;a href=&#34;https://instantview.telegram.org/checklist&#34;&gt;Чеклист Идеального Instant View&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;приложение-а&#34;&gt;Приложение А&lt;/h1&gt;

&lt;p&gt;Функции для детальной настройки форматирования&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#debug&#34;&gt;@debug&lt;/a&gt; отладка команд, вывод результов в нижней части редактора;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#append&#34;&gt;@append&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;в начало&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#prepend&#34;&gt;@prepend&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;в конец&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#after&#34;&gt;@after&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;после&lt;/strong&gt; каждого найденного по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#before&#34;&gt;@before&lt;/a&gt; вставляет переданные элементы &lt;strong&gt;перед&lt;/strong&gt; каждым найденным по XPath;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#append-to&#34;&gt;@append_to&lt;/a&gt; вставляет целевой узел в конец базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#prepend-to&#34;&gt;@prepend_to&lt;/a&gt; вставляет целевой узел в начало базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#after-el&#34;&gt;@after_el&lt;/a&gt;  вставляет целевой узел после базового;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#before-el&#34;&gt;@before_el&lt;/a&gt; вставляет целевой узел перед базовым;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#replace-tag&#34;&gt;@replace_tag&lt;/a&gt; изменяет имя тега;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#wrap&#34;&gt;@wrap&lt;/a&gt; заворачивает целевой элемент в заданный тег;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#clone&#34;&gt;@clone&lt;/a&gt; создает копию целевого узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#detach&#34;&gt;@detach&lt;/a&gt; отделяет целевой узел от оставшейся части, создает копию родительского узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#pre&#34;&gt;@pre&lt;/a&gt; помечает текст внутри целевого узла как отформатированный;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#set-attr&#34;&gt;@set_attr&lt;/a&gt; устанавливает аттрибут в каждом соответствующем узле;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#set-attrs&#34;&gt;@set_attrs&lt;/a&gt; устанавливает несколько аттрибутов;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#match&#34;&gt;@match&lt;/a&gt; выполняет поиск на основе регулярного выражения, в результате, заменяет содержимое целевого узла;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#replace&#34;&gt;@replace&lt;/a&gt; выполняет замену на основе регулярного выражения;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#urlencode&#34;&gt;@urlencode&lt;/a&gt; кодирует url в соответствии с RFC 3986;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#urldecode&#34;&gt;@urldecode&lt;/a&gt; декодирует url в соответствии с RFC 3986;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#htmlencode&#34;&gt;@htmlencode&lt;/a&gt; кодирует специальные символы в целевом узле в HTML сущности;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#htmldecode&#34;&gt;@htmldecode&lt;/a&gt; декодирует специальные символы в целевом узле в HTML сущности;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#background-to-image&#34;&gt;@background_to_image&lt;/a&gt; трансформирует целевой узел в &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; тэг с &lt;code&gt;src&lt;/code&gt; атрибуттом;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#json-to-xml&#34;&gt;@json_to_xml&lt;/a&gt; трансформирует json контент целевого узла в xml;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#html-to-dom&#34;&gt;@html_to_dom&lt;/a&gt; парсит html узел и вставляет его в документ (в документации есть очевидный пример);&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#combine&#34;&gt;@combine&lt;/a&gt; склеивает каждый следующий с предыдущим узлом, если такой существет;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#datetime&#34;&gt;@datetime&lt;/a&gt; трансформирует дату и время из строки в unix time;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#simplify&#34;&gt;@simplify&lt;/a&gt; системная функция для понимания того, как работает преобразование в Instant View;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#inline&#34;&gt;@inline&lt;/a&gt; встраивает iframe;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://instantview.telegram.org/docs#unsupported&#34;&gt;@unsupported&lt;/a&gt; определяет, какие элементы не поддерживаются, для того чтобы не давать пользователю Instant View с неполным контентом.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;
</description>
    </item>
    
    <item>
      <title>Telegram API. Как написать бота?</title>
      <link>https://i-osipov.ru/post/how_to_create_telegram_bot/</link>
      <pubDate>Sun, 23 Jul 2017 23:10:24 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/how_to_create_telegram_bot/</guid>
      <description>&lt;p&gt;Всем привет!&lt;/p&gt;

&lt;p&gt;Сегодня мы побеседуем о том как делаются Telegram боты.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кто ты по жизни?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Telegram боты бывают двух видов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Боты основанные на Webhoock&lt;/li&gt;
&lt;li&gt;Боты основанные на Long Polling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый вариант бота требует от вас поднять сервер и установить &amp;ldquo;вебхуки&amp;rdquo; для асинхронного оповещения вас о новых изменениях. На вашем сервере должен быть соответствующий роутинг.&lt;/p&gt;

&lt;p&gt;Второй вариант бота - это имитация асинхронности. Ваш бот с определенным периодом будет запрашивать последние изменения с сервера телеграм на основании механизма long polling. Т.е. бот делает запрос и подвисает, а отвисает либо по таймауту, либо по получению новыйх обновлений. Об этом виде ботов сегодня и пойдет речь.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long polling в разрезе работы с сетью&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Когда вы работаете с Telegram Api вы нагружаете сервера Telegram. Все запросы вы отправляете по одному URL, но в один момент времени может работать только один обработчик для Telegram бота.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Интересно, что в API предусмотрена умная обработка ошибок, среди прочего, в ответе телеграм сервера, который вы за DDOS&amp;rsquo;или, может сообщить вам сколько нужно подождать, чтобы вы могли взаимодействовать с Telegram снова&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Как сказано выше у вас фактически однопоточная обработка запросов к телеграм. По этому, кажется, здравым принять одну из следующих реализаций ботов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;реализовать поток, который будет отправлять запросы и складировать ответы в общую очередь из которой потоки-обработчики будут их разбирать;&lt;/li&gt;
&lt;li&gt;поставить прокси-сервер, который будет затягивать последние изменения и шарить их между нодами (другими серверами) бота. В этом случае можно подменяя прокси-сервер менять реализации взаимодействия с telegram api не меняя реализацию для нод. Это решение мне нравится несколько больше, его масштабируемость зависит от потребностей в функциональности бота, т.к. если можно обрабатывать параллельно несколько чатов независимо друг от друга, то масштабируемость на пределе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оставим использование прокси-сервера для будущих статей, а пока давайте рассмотрим как вы можете реализовать своего бота.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Красная или синяя таблетка?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;На сколько вы любите писать велосипеды? В зависимости от этого у вас есть 2 пути реализации Telegram бота:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;писать всё самому с нуля;&lt;/li&gt;
&lt;li&gt;воспользоваться существующей библиотекой.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если вы используете динамически типизируемые языки, которые поддерживают нативную работу с JSON, то первый вариант, не так уж и плох, однако, уже существует большое количество библиотек для разработки ботов их публичный перечень вы можете увидеть &lt;a href=&#34;https://core.telegram.org/bots/samples&#34;&gt;здесь&lt;/a&gt;. Вы найдете много вариантов для PHP, Java, Python, Node.js и так далее. Я сейчас реализую собственную библиотеку на языке Kotlin - &lt;a href=&#34;https://clabo.i-osipov.ru/&#34;&gt;Clabo&lt;/a&gt;. Эта библиотека поможет вам на основании расширяемого DSL описать работу своего бота, например, всё что надо для запуска бота, который говорит &amp;ldquo;Привет!&amp;rdquo; по команде /start это небольшой кусочек кода по &lt;a href=&#34;https://gist.github.com/ivan-osipov/266204f3560a6c5e64d381df5c73bf22&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BotFather&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В телеграме есть специальный бот, который позволяет создавать других ботов и настраивать их. Некоторые действия вы, как пользователь, не можете сделать из интерфейса, например, сменить имя бота или задать набор команд, для этого нужен &lt;a href=&#34;http://t.me/botfather&#34;&gt;BotFather&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Теперь у вас есть представление, как реализовать бота, но что с ним можно сделать? Об этом я расскажу ниже.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;И зачем всё это?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Боты очень способные, они обладают следующими возможностями:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;ul&gt;
&lt;li&gt;Встраиваемый мод (Inline mode). Вы можете встроить бота прямо в строку с вводом, хорошие примеры таких ботов это GifBot и YouTubeBot. Вы вписываете имя бота, например, @youtube и он предлагает вам результаты поиска видео или вы можете авторизоваться и результаты будут специфичны для вас.&lt;/li&gt;
&lt;li&gt;Клавиатуры. Есть два вида клавиатур: &amp;ldquo;Клавиатура для быстрого ответа&amp;rdquo; и &amp;ldquo;Встроенная клавиатура&amp;rdquo;. Первый вариант позволяет пользователю не писать сообщение, а просто отправить его выбрав один из вариантов. Встроенная клавиатура размещается прямо под сообщением и ассоциирована именно с ним.&lt;/li&gt;
&lt;li&gt;Команды. Всё что вы пишете после &amp;ldquo;/&amp;rdquo; в телеграм называется командами, чтобы избежать коллизий, когда два бота в одном чате имеют одну и ту же команду используется следующий формат &lt;code&gt;/command@BotName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Бот может отправлять отформатированные с помощью html или markdown сообщения.&lt;/li&gt;
&lt;li&gt;Бот может запросить местоположение или номер телефона.&lt;/li&gt;
&lt;li&gt;Ботов можно добавлять в группы и, например, администрировать их.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;&lt;strong&gt;Что в итоге?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Мы обзорно рассмотрели основы того как можно сделать ботов, для чего это и что они могут делать. Применение ботов ограничивается только вашей фантазией.
Вы создаете бота и запускаете сопровождающий код, который обрабатывает сообщения. Ничего сложного. Увидимся в следующих статьях!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>