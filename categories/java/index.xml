<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Ivan Osipov</title>
    <link>https://i-osipov.ru/categories/java/index.xml</link>
    <description>Recent content in Java on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>