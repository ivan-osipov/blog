<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Ivan Osipov</title>
    <link>https://i-osipov.ru/categories/development/index.xml</link>
    <description>Recent content in Development on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kotlin Generics</title>
      <link>https://i-osipov.ru/post/kotlin-generics/</link>
      <pubDate>Sun, 04 Feb 2018 06:17:17 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/kotlin-generics/</guid>
      <description>

&lt;p&gt;Первый релиз языка Kotlin включает в себя Kotlin Generics. Обобщенные типы, благодаря которым
мы с вами можем писать более гибкие приложения с меньшим дублированием кода и большей типобезопасностью.
Одно из важных преимуществ, которое дает вашему приложению использование Generics - проверка типов на этапе компиляции.
Дизайнеры языка Kotlin ввели новые ключевые слова для работы с дженериками, что по началу может ввести в ступор даже
опытного Java разработчика. Сегодня мы с вами обсудим что такое &amp;ldquo;дженерики&amp;rdquo;, удалим страх перед словами типа &amp;ldquo;контравариантность&amp;rdquo;,
а заодно познакомимся с reified generics и star-projection.&lt;/p&gt;

&lt;h2 id=&#34;generics&#34;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Для тех кто вовсе не знаком с обобщенными типами (generics) и для тех, кто порядком подзабыл, я напомню,
что обобщенные типы это возможность выполнять контроль типов в вашем приложении при том, что точный тип вам не известен.
Приведу пример, у вас есть коллекция Set, которая может быть хранилищем для абсолютно разных объектов, так, в одном
месте приложения вы возпользуетесь &lt;code&gt;Set&amp;lt;User&amp;gt;&lt;/code&gt; для работы с множеством пользователей, а в другой части приложения это
будет &lt;code&gt;Set&amp;lt;Task&amp;gt;&lt;/code&gt; - коллекция, которая хранит выполненные задачи. В обоих случаях коллекция Set выполняет возложенные
на неё обязательства, более того, компилятор может проверить, что метод add принимает объект соответствующего типа, ровно
как мы получим объекты этого типа проходя по коллекции.&lt;/p&gt;

&lt;p&gt;Создание классов с обобщенными Kotlin типами в простейшем виде выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;T - это лишь типичный пример именования неизвестного типа, вместо T вы можете использовать любой идентификатор для
удобства. В примере выше мы описали класс, единственный параметр класса имеет общенный тип. Обратите внимание, что свойство
класса имеет модификатор &lt;code&gt;var&lt;/code&gt; и здесь это не с проста, ниже я объясню почему. Воспользуемся контейнером
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container = Container(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обратите внимание, в сравнении с Java нам нет необходимости явно указывать Generic тип для контейнера, т.к. компилятор
обладает полной информацией для выведения этого типа. Аналогично, начиная с Java 7, мы имеем возможность писать сокращенный
вариант с использованием &lt;a href=&#34;http://www.rootfront.com/article/219061/2011-04-21/v-jdk-7-pojavitsja-diamond-operator&#34; target=&#34;_blank&#34;&gt;Diamond Operator&lt;/a&gt;.
В совокупности с возможностью Kotlin выводить типы и для переменных мы имеем сокращенный синтаксис и при этом гибкий набор инструментов.&lt;/p&gt;

&lt;p&gt;Но что, если мы хотим положить в наш контейнер другой Int? Легко!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;container.contained = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Затем, мы можем прочитать его, также легко.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;println(container.contained)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На каждом этапе, на каждой строке компилятор проверяет, что мы работаем именно с Int, а не с чем бы то ни было другим, благодаря
этому, мы, например, не можем записать в наш контейнер String.&lt;/p&gt;

&lt;h2 id=&#34;инвариантный-ковариантный-контравариантный&#34;&gt;Инвариантный, ковариантный, контравариантный&lt;/h2&gt;

&lt;p&gt;Должен вам признаться, если не работать со сложными вариациями обобщенных типов, то со временем всё забывается и приходится
обновлять знания, вспоминать некоторые термины и иногда это дается с трудом, т.к. множество источников по generics пестрят
красивыми словами &lt;em&gt;инвариантный&lt;/em&gt;, &lt;em&gt;ковариантный&lt;/em&gt;, &lt;em&gt;контравариантный&lt;/em&gt;, однако, эти же источники совершенно невнятно объясняют
терминологию. Сегодня я нацелен исправить это и перешагнуть через тонкую грань непонимания в данном вопросе.&lt;/p&gt;

&lt;h3 id=&#34;инвариантность&#34;&gt;Инвариантность&lt;/h3&gt;

&lt;p&gt;Возвращаясь к примеру с контейнером из предыдущего раздела, мы имеем тип &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt;, где вместо T может оказаться
любой тип с верхней границей Any? (об этом позже, коротко, любой nullable и не-nullable тип). Допустим, что мы
сохранили в контейнер значение с типом Int следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Я определяю тип переменной и дженерик для очевидности, по умолчанию, компилятор вполне справляется с их выводом&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Сможем ли мы обобщить нашу переменную чуть больше. Int наследуется от Number, и допустим мы хотим хранить в переменной
контейнер не только с Int, а в принципе с Number, т.е. в нем может находиться любое число, например, Double.
Интуитивно хочется написать:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, такой код не скомпилируется, т.к. не смотря на то, что Int наследуется от Number, то типы с дженериками
&lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt; и &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; не находятся в одной иерархии, по сути, это абсолютно разные типы, никак не
совместимые. Другим языком, &lt;strong&gt;класс Container неизменен (инвариантен) по типу T&lt;/strong&gt;. Следовательно, независимо от иерархии
наследования самих обобщенных типов, по умолчанию, мы не можем говорить об каком-либо следствии иерархии классов
использующих их.&lt;/p&gt;

&lt;h3 id=&#34;ковариантность&#34;&gt;Ковариантность&lt;/h3&gt;

&lt;p&gt;Вы можете задаться вопросом: &amp;ldquo;А зачем это сделано? Почему не дать иерархию как следствие иерархии обобщенных типов по
умолчанию?&amp;ldquo;. Дело в том, что основная задача обобщенных типов - обеспечить безопасность типизации в вашем коде,
уменьшить количество выбрасываемых исключений во времени выполнения уже на этапе компиляции, ну и конечно сделать всё
это гибко. Обрисовать проблему мне помогут массивы из Java. Так получилось, что в Java массивы появились на много
раньше чем обобщенные типы. Когда вводили массивы дали возможность сказать, что если у вас есть массив целочисленных значений (Integer[]), то вы можете
присвоить это значение в переменную Number[]. Казалось бы, вот мы и получили наследование, но давайте рассмотрим
следующий кусочек кода:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 }; //создаем массив Integer 
Number[] b = a; // делаем еще одну ссылку на массив с типом Number[] и это допустимо
b[1] = 4.4; //сохраняем Double значение в массив Integer
//Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException: java.lang.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто мы можем получить ошибку, которую увидим только на этапе выполнения (в JVM есть специальная проверка, которая
выполняется на записи), следовательно, наследование
как следствие по умолчанию - это плохая идея. Однако, следующий код допустим, не так ли?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] a = { 4, 5 };
Number[] b = a;
System.out.println(b[1]);
//output: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь всё законно, мы сделали те же самые действия, но вместо присвоения значения, мы его прочитали. Получается, что иногда
поведение передачи наследования в соответствии с обобщенным типом может быть безопасно. Например, у нас есть метод, который
будет только распечатывать значения из входного параметра и, в принципе, он может принимать любые числа, хоть
Integer и Double в одном массиве, а затем печатать их. Так мы можем вывести правило:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если наша пременная только предоставляет значения, то мы можем допустить, что в ней может находиться значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;аналогично для классов с обобщенными типами:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;если объект нашего класса только предоставляет значения, то мы можем допустить, что в нём хранится значение ниже
по иерархии обобщенного типа&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Что значит &amp;ldquo;ниже по иерархии&amp;rdquo;? В Kotlin, как и в любом другом типизированном языке, существует иерархия типов. Если вы
слабо представляете её, то я могу порекомендовать вам вот &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt;
статью, которая поможет разобраться в системе типов. Ну а сейчас, для краткости, я лишь скажу, что для типа Number типы Int и Double
лежат ниже по иерархии типов (могут быть безопасно приведены к Number), а тип Any лежит выше по иерархии типов (к нему можно
безопасно привести Number).&lt;/p&gt;

&lt;p&gt;Другими словами, нужно как-то объяснить компилятору, что в некоторых ситуациях мы готовы к ковариантности. Тут то мы и подобрались
к этому страшному слову. &lt;strong&gt;Ковариантностью&lt;/strong&gt; называется сохранение иерархии типов в производных типах в том же порядке.&lt;/p&gt;

&lt;p&gt;Мы можем сказать, что &lt;code&gt;Container&amp;lt;T&amp;gt;&lt;/code&gt; ковариантен своему параметру-типу T. Это будет означать, что если Int - потомок
Number, то &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; будет тоже считаться потомком &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;. Напомню, что выше мы убедились
в том, что ковариантность допустима, только когда мы говорим о получении значения, а по умолчанию обобщенные типы инвариантны,
т.е. мы можем безопасно &lt;strong&gt;получить&lt;/strong&gt; Number, если работаем с &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; или контейнером для любого другого наследника Number.
Существует два способа объяснить компилятору то, что Container ковариантен по параметру-типу T в Kotlin. Давайте их рассмотрим.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-уровне-класса-на-месте-объявления&#34;&gt;Ковариантность на уровне класса (на месте объявления)&lt;/h4&gt;

&lt;p&gt;Когда мы объявляем класс, мы можем изначально говорить о том, что класс ковариантен своему типу-параметру. Работать с ковариантными
типами нам помогает ключевое слово &lt;code&gt;out&lt;/code&gt;. Семантика его крайне проста в понимании. Если класс выступает в качестве Producer&amp;rsquo;a,
т.е. мы планируем значения типа Т &lt;strong&gt;только&lt;/strong&gt; получать, то мы используем ключевое слово &lt;code&gt;out&lt;/code&gt;, т.е. класс поставляет
значения типа &lt;strong&gt;наружу&lt;/strong&gt;. Давайте изменим декларацию нашего класса Container следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Тут же мы получаем ошибку компиляции, но какую?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type parameter T is declared as &#39;out&#39; but occurs in &#39;invariant&#39; position in type T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Какая странная ошибка, где это у нас возникает потребность в инвариантном состоянии? Точно! Ключевое слово &lt;code&gt;var&lt;/code&gt;!
Мы совсем забыли о том, что &lt;code&gt;var&lt;/code&gt; отличается от &lt;code&gt;val&lt;/code&gt; наличием возможности изменить это значение, а как мы помним,
ковариантность возможна только в случае, если вы запретите любые изменения значения. Заменим var на val&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;out T&amp;gt;(val contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот и всё. Теперь наш класс Container ковариантен параметру-типу T, это означает, что мы легко можем использовать следующую
конструкцию:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Number&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Инвариантность как рукой сняло! Но чем мы за это заплатили?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val container: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
val container2: Container&amp;lt;Number&amp;gt; = container
container2.contained = 4.0 //не компилируется, т.к. нельзя менять значение, зато мы
// защищены от ошибок как с Java массивами
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы видите теперь тип &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; наследник типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, благодаря чему мы можем свободно присваивать его переменным
типа &lt;code&gt;Container&amp;lt;Number&amp;gt;&lt;/code&gt;, но не можем менять значения типа T и это правильно. Представьте, если бы последняя строчка
компилировась. Это значит, что через свойство contained было бы записано Double значение! Получается, что переменная
container с типом &lt;code&gt;Container&amp;lt;Int&amp;gt;&lt;/code&gt; содержала бы не Int, а Double, ведь и container, и container2 это две ссылки на один и
тот же объект в памяти. И при попытке получения container.contained мы бы словили &lt;code&gt;ClassCastException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ковариантность на уровне класса - дело хорошее, оно гребёт под себя весь класс и заставляет нас не менять значения, но, что
если нам не нужна ковариантность для всего класса? Пора разобраться с ковариантностью на месте использования.&lt;/p&gt;

&lt;h4 id=&#34;ковариантность-на-месте-использования&#34;&gt;Ковариантность на месте использования&lt;/h4&gt;

&lt;p&gt;Один из мощных механизмов управления иерархиями обобщенных типов это ковариантность на уровне объявления. Вспомним нашу
первую версию инвариантного контейнера:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если наш класс не ковариантен какому-либо параметру T, то мы можем свободно менять его значения как хотим:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val sourceContainer: Container&amp;lt;Int&amp;gt; = Container&amp;lt;Int&amp;gt;(25)
sourceContainer.contained = 4 // компилируется
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А в тот момент, когда нам понадобится завести общую переменную под контейнеры с разными параметрами-типами, мы сможем это сделать, воспользовавшись
ковариантностью на месте использования (проекцией типа).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val covariantContainer: Container&amp;lt;out Number&amp;gt; = sourceContainer
covariantContainer.contained = 4 
/*  не компилируется, работаем с переменной у которой тип ковариантен параметру-типу
    значит нельзя менять значения, т.к. мы не знаем исходный тип, 
    там может быть любой контейнер с параметром-типом наследником Number
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря, ковариантности на уровне объявления мы можем делать многие вещи очень гибко, например, написать следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T: Any&amp;gt; { //что такое T: Any вы узнаете чуть позже
    /* 
        Пусть на момент создания контейнера мы еще не знаем,
        что конкретно он будет содержать, но знаем точно, что 
        что-то с некоторым типом T он должен, следовательно после 
        создания, рано или поздно, мы поменяем значение поля contained,
        а значит оно по определению не может быть val. В такой ситуации,
        мы не можем объявлять ковариантность на уровне класса
     */
    lateinit var contained: T

    override fun toString(): String {
        return &amp;quot;Container(contained=$contained)&amp;quot;
    }

}

/*
    Возвращаемый тип Container&amp;lt;out Number&amp;gt; создает ковариантность
    на месте использования, следовательно, из метода мы возвращаем 
    контейнер, который типизирован чем-то ниже в иерархии наследования
 */
fun createIntContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Int&amp;gt;()
    container.contained = 42
    return container
}

fun createDoubleContainer(): Container&amp;lt;out Number&amp;gt; {
    val container = Container&amp;lt;Double&amp;gt;()
    container.contained = 42.0
    return container
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    var covariantContainer = createIntContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
    covariantContainer = createDoubleContainer() //Container&amp;lt;out Number&amp;gt;
    println(covariantContainer)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вывод в консоли:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Container(contained=42)
Container(contained=42.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом, мы успешно хранили в одной переменной контейнеры с разным параметром-типом, при том, что сам контейнер
инвариантен по своему параметру-типу Т.&lt;/p&gt;

&lt;p&gt;С ковариантностью разобрались, осталась контравариантность.&lt;/p&gt;

&lt;h3 id=&#34;контравариантность&#34;&gt;Контравариантность&lt;/h3&gt;

&lt;p&gt;Кроме того, чтобы описывать классы как producer&amp;rsquo;ы, иногда, нам может понадобиться
описать классы как consumer&amp;rsquo;ы или &lt;strong&gt;потребители&lt;/strong&gt;. Давайте рассмотрим следующую иерархию типов:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Пользователь
   /           \
Работник  Администратор   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пусть перед нами стоит задача написать логгер тех, кто входит в систему. Каждый пользователь системы имеет логин и именно его
мы будем распечатывать.&lt;/p&gt;

&lt;p&gt;Объявление такой иерархии типов может выглядеть, например, так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;open class User(var login: String)

class Worker(login: String): User(login)

class Admin(login: String): User(login)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создадим класс Printer, который инкапсулирует в себе логику печати:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;T: User&amp;gt; {
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пока класс инвариантен и в большинстве случаев этого будет достаточно благодаря автоматическому приведению типов. Подумайте,
если бы мы передали в метод print объект типа Admin, то он спокойно был бы принят компилятором и приведен к верней границе
обобщенного типа User, но все приложения разные. Допустим, у нас есть метод &lt;code&gt;printAdmin&lt;/code&gt;, который знает какие предобработки нужно
сделать, а затем вызывает правильный метод у объекта класса &lt;code&gt;Printer&lt;/code&gt;. Напишем метод &lt;code&gt;printAdmin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun printAdmin(printer: Printer&amp;lt;Admin&amp;gt;, admin: Admin) {
    //admin specific
    printer.print(admin)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такой метод в своём использовании сужает вариативность нашего принтера, теперь принтер должен уметь печатать именно администратора.
Принтер для работника здесь не подойдет, а подойдет ли принтер для пользователя в принципе? Почему бы и нет, админ - тоже пользователь,
значит мы должны уметь печатать его тем же принтером, что и других пользователей. Получается, если Админ наследуется от Пользователя, то
принтер пользователя, должен быть наследником принтера админа (только в этом случае мы сможем безопасно привести тип
&lt;code&gt;Printer&amp;lt;User&amp;gt;&lt;/code&gt; к типу &lt;code&gt;Printer&amp;lt;Admin&amp;gt;&lt;/code&gt;). За сим мы наблюдаем разворот иерархии в другую сторону - это и обозначают сложным
словом контравариантность. Схематично контравариантность можно обозначить следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   User         Printer&amp;lt;Admin&amp;gt;       
    ↑     →         ↑
  Admin         Printer&amp;lt;User&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Как вы, уверен, уже запомнили, обобщенные типы сами по себе инвариантны, по этому следующий код не скомпилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Однако, мы можем это изменить. Для этого в нашем арсенале есть ключевое слово &lt;code&gt;in&lt;/code&gt;. Применять мы можем его как на уровне объявления,
так и на уровне использования, аналогично ковариантной аннотации обобщенного типа &lt;code&gt;out&lt;/code&gt;. Выглядит применение на уровне класса
следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Printer&amp;lt;in T: User&amp;gt; { //появился in
    fun print(user: T) {
        println(&amp;quot;User ${user.login} is logged in&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Компилятор будет всячески не давать заполучть T из объектов типа контравариантного типу-параметру. После манипуляций выше наш
код ниже компилируется:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val admin = Admin(&amp;quot;admin&amp;quot;)
printAdmin(Printer&amp;lt;User&amp;gt;(), admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И печатает:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User admin is logged in
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;producer-out-consumer-in&#34;&gt;Producer Out, Consumer In&lt;/h2&gt;

&lt;p&gt;В классической книге Effective Java автор Joshua Bloch предлагает аббревиатуру PECS для запоминания правила использования
ключевых слов extends и super в обобщенных типах Java. Аббревиатура гласит, &lt;code&gt;Producer Extends, Consumer Super&lt;/code&gt;, что
означает если класс является Producer&amp;rsquo;ом обобщенного типа, то необходимо использовать ключевое слово extends, а если потребителем, то
super. В Kotlin всё на много проще. Хотя мы можем переизобрести аббревиатуру блоха POCI (Producer Out, Consumer In),
это того не стоит. На самом деле, ключевые слова out и in говорят сами за себя, только думать нужно не в терминах иерархии типов,
а, скорее, думать о том как перемещаются данные. Если ваш класс поставляет обобщенно-типизированные значения наружу,
то вам нужен &lt;code&gt;out&lt;/code&gt;, а если класс потребляет значения обобщенного типа, то нужен &lt;code&gt;in&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;верхняя-граница-обобщенного-типа&#34;&gt;Верхняя граница обобщенного типа&lt;/h2&gt;

&lt;p&gt;Как вы уже заметили, несколько раз за статью я использовал конструкции вида &lt;code&gt;&amp;lt;T: SomeClass&amp;gt;&lt;/code&gt;. Прежде всего я хочу вас спросить,
а какой тип находится на вершине иерархии типов в Kotlin? Аналогично Object в Java, к чему можно привести любой тип?
Правильным ответом будет &lt;code&gt;Any?&lt;/code&gt;. Сам по себе класс &lt;code&gt;Any&lt;/code&gt; это аналог &lt;code&gt;Object&lt;/code&gt;, однако, в следствие поддержки Nullable и не
Nullable типов в Kotlin мы получили &lt;code&gt;Any?&lt;/code&gt;. Фактически, &lt;code&gt;Any?&lt;/code&gt; соответствует любому типу и &lt;code&gt;null&lt;/code&gt;, а &lt;code&gt;Any&lt;/code&gt; только любому типу.
Подробнее об иерархии типов я предлагаю прочитать статью, которую вы найдете в последнем разделе &amp;ldquo;Бонус&amp;rdquo;. Обобщенные
типы ограничены сверху максимально широким типом, а именно &lt;code&gt;Any?&lt;/code&gt; из-за чего может возникать некоторое недопонимание в использовании их.
Следовательно, по умолчанию дженерик тип - Nullable, это означает, что свойства с таким типом могут принимать значения
&lt;code&gt;null&lt;/code&gt;, но когда мы будем работать с ними, то компилятор потребует удостовериться, что через свойство доступно не null значение.
Таким образом, когда мы пишем &lt;code&gt;&amp;lt;T: Any&amp;gt;&lt;/code&gt; мы явно говорим, что тип, указываемый в качестве конкретного варианта вместо
обобщенного типа не может содержать &lt;code&gt;null&lt;/code&gt;. Аналогично, мы можем понизить верхнюю границу по иерархии еще ниже и потребовать, например,
указывать в качестве типов только чила: &lt;code&gt;&amp;lt;T: Number&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Верхних границ может быть несколько, в этом случае необходимо указывать их в специальном разделяющем &lt;code&gt;where&lt;/code&gt; условии:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Container&amp;lt;T&amp;gt;(var contained: T) 
        where T: Number, 
              T: Comparable&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Аналогично для функции для которой объявлен обобщенный тип.&lt;/p&gt;

&lt;h2 id=&#34;star-projection&#34;&gt;Star-Projection&lt;/h2&gt;

&lt;p&gt;Часто мы сталкиваемся с так называемой &lt;em&gt;проекцией типов&lt;/em&gt;. Простым языком, это ограничение типа на месте использования. Например,
мы не хотим, чтобы в наш контейнер могли по ошибке что-то записать внутри метода, для этого ограничиваем тип:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;out Number&amp;gt;) {
    container.contained = 4 //не компилируется    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Благодаря out здесь мы можем только читать из контейнера, но не записывать. В примерах выше мы обсуждали это поведение.&lt;/p&gt;

&lt;p&gt;Однако, иногда возникает ситуация, что у нас нет информации о необходимом нам типе проекции, но мы знаем, что Container, к примеру, имеет
верхнюю границу для ковариантного параметра-типа - Number и нам этого достаточно. Тогда, мы можем воспользоваться star-projection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun process(container: Container&amp;lt;*&amp;gt;) { // символ *
    println(container.value) // мы можем печатать значения, т.к. знаем верхнюю границу обобщенного типа
    container.value = 4 // но мы не можем писать значения, т.к. не знаем типа
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для ковариантных параметров * означает &amp;ldquo;могу читать значения с типом верхней границы обобщенного типа&amp;rdquo;.
Для контравариантных параметров * означает &amp;ldquo;не могу ничего безопасно писать&amp;rdquo;
Для инвариантных параметров символ * означает: &amp;ldquo;при чтении аналогично * для ковариантного, при записи аналогично * для контравариантного параметра&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;стирание-типов&#34;&gt;Стирание типов&lt;/h2&gt;

&lt;p&gt;Аналогично с Java в Kotlin происходит стирание информации об обобщенных типах, т.е. обобщенные типы - наши помощники только
на этапе компиляции. На этапе выполнения кода информации уже нет, однако, есть хитрые способы, которые вы можете найти для
частного решения в некоторых случаях.&lt;/p&gt;

&lt;h2 id=&#34;reified-generics-и-inline-function&#34;&gt;Reified Generics и inline function&lt;/h2&gt;

&lt;p&gt;Модификатор inline для функций позволяет встраивать код в место вызова без какого-либо обращения к реальной функции.
Такой модификатор позволяет не создавать слишком много лямбд, которые передаются в методы и является небольшой оптимизацией.
Кроме того, этот модификатор позволяет сохранить информацию об обобщенных типах объявленных в рамках методов даже на этапе выполнения. Рассмотрим
небольшой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T: Number&amp;gt; printClass(value: T) {
    println(T::class)
}

fun main(args: Array&amp;lt;String&amp;gt;) {
    printClass(4)
    printClass(4.0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Результат выполнения:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class kotlin.Int
class kotlin.Double
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ключевое слово &lt;code&gt;reified&lt;/code&gt; говорит о том, что нужно иметь доступ к информации о типе T. Таким образом, в некоторых случаях,
даже явно не передавая тип, мы можем работать с ним.&lt;/p&gt;

&lt;h2 id=&#34;резюме&#34;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;Подводя итоги статьи, хочется отметить, что обобщенные типы - довольно сложная часть как Java, так и Kotlin и их понимание
крайне важно для бесстрашного построения гибких классов, готовых к разностороннему применению. Можно долго спорить,
что понятнее Java программисту, который пришел в Kotlin, Java синтаксис обобщенных типов или &lt;code&gt;out&lt;/code&gt; и &lt;code&gt;in&lt;/code&gt;. На мой взгляд,
если у вас есть понимание того для чего вы применяете обобщенные типы, то никакой синтаксис не помешает вам их использовать.&lt;/p&gt;

&lt;h2 id=&#34;бонус&#34;&gt;Бонус&lt;/h2&gt;

&lt;p&gt;Погружаясь в тему обобщенных типов вы можете посмотреть видео с конференции JPoint2016 &amp;ldquo;Неочевидные Дженерики&amp;rdquo; об обобщенных типах из Java
вот &lt;a href=&#34;https://www.youtube.com/watch?v=_0c9Fd9FacU&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Статья об &lt;a href=&#34;http://natpryce.com/articles/000818.html&#34; target=&#34;_blank&#34;&gt;иерархии типов в Kotlin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Альтернативное &lt;a href=&#34;https://kotlinlang.ru/docs/reference/generics.html&#34; target=&#34;_blank&#34;&gt;чтение&lt;/a&gt; на тему дженериков&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protocol Buffers</title>
      <link>https://i-osipov.ru/post/protocol-buffers/</link>
      <pubDate>Sun, 28 Jan 2018 09:26:03 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/protocol-buffers/</guid>
      <description>

&lt;p&gt;Один из набирающих популярность протоколов общения между двумя гетерогенными системами - Protocol Buffers.
Сегодня мы разберемся с тем, что это такое, для чего нужно и как применять.&lt;/p&gt;

&lt;h1 id=&#34;контекст&#34;&gt;Контекст&lt;/h1&gt;

&lt;p&gt;Когда перед нами встает задача общения двух удалённых систем, первое что приходит в голову сегодня это HTTP запросы,
кто-то любит использовать слово REST (REpresentational State Transfer), хотя и на самом деле строит API в виде RPC
(Remote Procedure Call), реализация которого опирается на HTTP вызовы. Наиболее распространенный сегодня HTTP/1.1
был принят в далёком 1999 году. У протокола была и есть одна особенность (язык не поворачивается назвать это недостатком) - он текстовый, это
говорит об одновременно двух следствиях. Процесс общения легко отлаживать, мы сразу видим в человекочитаемом виде
какая информация передается. Однако, информация часто занимает больше места чем нужно. На смену HTTP/1.1 приходит
относительно новый HTTP/2 - бинарный протокол. Сама процедура бинарной передачи
данных как бы намекает: &amp;ldquo;ты использовал json и xml для передачи компактных и читаемых данных, но теперь данные передаются
в бинарном виде, может быть нам нужен другой формат?&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная идея&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - это бинартый протокол сериализации (передачи) структурированных данных. Google предложили его как
эффективную альтернативу xml и правильно сделали. В моём окружении все не легаси проекты уже давно используют
json и счастливы, а здесь следующий шаг, если быть точнее, другой взгляд на передаваемые данные. Данные
хранятся в виде набора байт, но как работать с бинарнарным протоколом сериализации, где взять сериализаторы и десериализаторы,
как они поймут, что именно нужно сделать?&lt;/p&gt;

&lt;h1 id=&#34;язык-общения&#34;&gt;Язык общения&lt;/h1&gt;

&lt;p&gt;Для того, чтобы обе стороны взаимодействия общались на &amp;ldquo;одном языке&amp;rdquo;, необходимо создать специальный .proto файл, который опишет
виды сообщений и будет основой для построения бинарного формата. Пример такого файла вы увидите дальше. Когда файл с
требуемой сруктурой данных готов его необходимо скомпилировать специально для вашего языка программирования. Результат
компиляции это код в терминах необходимого вам языка, который упрощает процесс работы с данными, сериализацию
и десериализацию. В Java это классы и их методы. Сгенерированный класс будет содержать методы доступа ко всем полям, а также методы сериализации и
десириализации в/из массива байт.&lt;/p&gt;

&lt;h1 id=&#34;общие-приемущества&#34;&gt;Общие приемущества&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Сокращение издержек на передачу в сравнении с текстовыми форматами.&lt;/li&gt;
&lt;li&gt;Хорошо дружит с HTTP/2&lt;/li&gt;
&lt;li&gt;При добавлении новых полей на старых клиентах они игнорируются, сохраняя совместимость.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;недостатки&#34;&gt;Недостатки&lt;/h1&gt;

&lt;p&gt;Пожалуй, о недостатках лучше всего скажет тот, кто с ними столкнулся и здесь я посоветую вам прочитать вот
&lt;a href=&#34;https://habrahabr.ru/post/310032&#34; target=&#34;_blank&#34;&gt;эту&lt;/a&gt; статью на хабре, дабы развеять ненужные иллюзии безоблачного неба.&lt;/p&gt;

&lt;p&gt;Будьте внимательны с использованием обязательных полей. Нужно понимать, что если у клиента версия .proto
файла, где поле Х обязательно, а сервер решит удалить его из следующей версии API, то такое изменение будет
обратно-несовместимым. Таким образом, обязательные поля могут принести больше вреда чем пользы. Рекомендуется, следуя паттерну
&lt;a href=&#34;https://i-osipov.ru/post/postels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;TolerantReader&lt;/a&gt;, быть готовым к изменениям модели
для максимально долгого сохранения обратной совместимости.&lt;/p&gt;

&lt;h1 id=&#34;пример&#34;&gt;Пример&lt;/h1&gt;

&lt;p&gt;Хорошая новость. Как минимум для Intellij IDEA есть плагин для .proto файлов. В тот момент, когда вы создадите и откроете
такой файл, вы увидите хинт сверху, который предложит вам установить плагин.
Здесь вы увидите пример .proto файла для второй версии протобафа, хотя сейчас уже появилась третья. Возможно, о ней я буду
писать позже, а любопытный читатель уже сейчас может посмотреть
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34;&gt;Language Guide (proto3)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;шаг-1-определяем-формат-протокола&#34;&gt;Шаг 1. Определяем формат протокола&lt;/h2&gt;

&lt;p&gt;На первом шаге нам нужно описать .proto файл. Разберем сокращенную версию предметной области учебного заведения.
Исходный .proto файл выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &amp;quot;proto2&amp;quot;;

package academy;

option java_package = &amp;quot;ru.i_osipov.academy&amp;quot;;
option java_outer_classname = &amp;quot;AcademyProtos&amp;quot;;

message Student {
    required string name = 1;
    optional int32 id = 2;
    repeated string email = 3;
    optional Gender gender = 4 [default = MALE];

    enum Gender {
    	MALE = 0;
        FEMALE = 1;
    }
}

message Group {
    required string name = 1;
    repeated Student student = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Разберемся с синтаксисом файла. Прежде всего мы указываем какую версию protobuf мы используем, в нашем случае это вторая
версия. Затем указываем package, который необходим здесь для разделения пространств имён. Т.к. мы знаем, что будем пользоваться
java, то указываем две дополнительные настройки: &lt;code&gt;java_package&lt;/code&gt; и &lt;code&gt;java_outer_classname&lt;/code&gt;. Первая, очевидно, говорит в
какой пакет и соответственно иерархию директорий необходимо сложить результат компиляции, а &lt;code&gt;java_outer_classname&lt;/code&gt;
определяет имя файла, который будет в себя заворачивать весь сгенерированный контент. Если это не будет сделано, то
компилятор определит имя в соответствии с CamelCase по названию .proto файла. Эти настройки, как вы понимаете, java-специфичны.&lt;/p&gt;

&lt;p&gt;Далее мы указываем описание наших messages, по сути, message (сообщение) - это структура данных и, судя по документации, без возможности
наследования. Каждое сообщение, состоит из полей. В нашем примере, каждое поле имеет тип, название, уникальный в
контексте сообщения тег и модификатор.
Тег - это уникальный маркер поля, т.е. пока вы не задействовали один и тот же тег для нового поля в
сообщении - ваши поля остаются совместимыми с предыдущей версией. Итак, мы определили тип студента, определили его поля:
строковое имя, целочисленный идентификатор, строковый email и пол.&lt;/p&gt;

&lt;p&gt;Модификаторы дают нам больше представления о том как поле используется, например, модификатор required позволяет описать
обязательное поле в сообщении, если десериализатор не обнаружит этого поля, то весь процесс десериализации закончится с ошибкой.
Это важно учитывать при проектировании API (снова взгляните на второй абзац в разделе &amp;ldquo;Недостатки&amp;rdquo; этой статьи).
Модификатор optional, говорит о том, что поле может быть, а может отсутствовать, своего рода nullable поле. Модификатор repeated
используется для работы с множеством значений для одного поля (аналогично коллекциям в Java).&lt;/p&gt;

&lt;p&gt;Вы можете вкладывать messages друг в друга, использовать перечисления enum, в общем очень похоже на Java. Кроме того,
есть возможность определить значения по умолчанию.&lt;/p&gt;

&lt;h2 id=&#34;шаг-2-компилируем-файл&#34;&gt;*Шаг 2. Компилируем файл&lt;/h2&gt;

&lt;p&gt;* опциональный, для понимания&lt;/p&gt;

&lt;p&gt;Созданный .proto файл нужно скомпилировать и прежде всего нам нужен компилятор. &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/downloads&#34; target=&#34;_blank&#34;&gt;Скачиваем&lt;/a&gt;
&lt;code&gt;protoc&lt;/code&gt; архив. В архиве к нам прилетает компилятор и некоторый набор типов, которые мы можем использовать из коробки.
Когда вы нашли место для файла в вашей файловой системе добавьте его в PATH. В Windows это делается в Параметрах окружения,
а в linux будет достаточно выполнить &lt;code&gt;export PATH=$PATH:your_path&lt;/code&gt;. Теперь нам доступен компилятор из терминала, давайте скомпилируем.&lt;/p&gt;

&lt;p&gt;Перейдем в папку с .proto файлом и выполним команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc --java_out=./ ./academy.proto 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Флаг &lt;code&gt;--java_out&lt;/code&gt; указывает на папку куда будет сгенерирован java код. В этой папке мы получили иерархию, которая
определяет java package, который мы указали в .proto файле. Результат компиляции - .java файл, который пока не
компилируется javac&amp;rsquo;ом, для этого нам необходима дополнительная библиотека для работы с protobuf из java. В целях
избежения ненужных проблем, перенесем наши эксперименты в плоскость обычного проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-3-собираем-проект&#34;&gt;Шаг 3. Собираем проект&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Прежде всего хочу сказать, что не смотря на то, что все примеры на java, работа на других платформах с protobuf аналогична.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поигрались с терминалом и хватит, перейдем к практическому применению. Создадим gradle проект, цель которого будет перегнать
через массив байт группу со студентами. Для автоматизации рутинной деятельности нам поможет инструмент автоматизации
сборки gradle. Для вашего случая инструмент может отличаться, но идея должна быть понятна. Для того, чтобы добавить поддержку
protocol buffers в цикле сборки нашего проекта, дополним типичный build.gradle файл следующими настройками:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;/*  добавляем в проект плагин, который добавляет 
    к процессу сборки проекта генерацию java 
    файлов по .proto файлам
 */
plugins {
    id &amp;quot;com.google.protobuf&amp;quot; version &amp;quot;0.8.3&amp;quot;
}

protobuf {
    /*  мы можем брать протобаф компилятор прямо из 
        репозитория в качестве зависимости, при желании 
        мы можем указать путь до protoc файла
     */
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.5.1-1&#39;
    }
    // указываем нашу директорию в проекте для сгенерированных файлов
    generatedFilesBaseDir = &amp;quot;$projectDir/src&amp;quot;
    // по умолчанию плагин ищет .proto файлы в /src/main/proto
}

dependencies {
    // + зависимость без которой сгенерированный код не скомпилируется
    compile group: &#39;com.google.protobuf&#39;, name: &#39;protobuf-java&#39;, version: &#39;3.5.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Комментарии к коду исчерпывающие, а в конце статьи я оставлю ссылку на репозиторий, в котором вы найдете
запускаемый код.&lt;/p&gt;

&lt;p&gt;В папку проекта &lt;code&gt;src/main/proto&lt;/code&gt; помещаем наш .proto файл из первого шага. Теперь при сборке проекта или при выполнении
gradle команды &lt;code&gt;generateProto&lt;/code&gt; мы получим сгенерированный код по .proto файлу внутри нашего проекта.&lt;/p&gt;

&lt;h2 id=&#34;шаг-4-взаимодействуем-со-сгенерированным-кодом&#34;&gt;Шаг 4. Взаимодействуем со сгенерированным кодом&lt;/h2&gt;

&lt;p&gt;Компилятор создает весь код внутри файла &lt;code&gt;AcademyProtos.java&lt;/code&gt;, это название мы указали в .proto файле. Весь сгенерированный
код доступен в одноименном классе. Messages  превратились в несколько внутренних классов, которые помогают создавать,
сериализовывать и десериализовывать описанную модель. По message Student компилятор создал класс AcademyProtos.Student и
AcademyProtos.Student.Builder. Это типичная реализация паттерна &amp;ldquo;Строитель&amp;rdquo;. Объекты класса Student всегда неизменяемы,
т.е. после создания мы не можем изменить каких-либо значений. Все манипуляции происходят с классом Builder, для этого у него есть
достаточно методов.&lt;br /&gt;
Разберем код. Нам небходимо создать группу, для которой определено обязательное имя и набор студентов в виде repeated
поля. Создание группы выглядит следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group group = AcademyProtos.Group.newBuilder()
    .setName(&amp;quot;Math&amp;quot;)
    .addStudent(...)
    .addStudent(...)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы создать новый объект мы должны вызвать его Builder, заполнить его поля, а затем, в качестве звершающей
изменения операции вызвать метод &lt;code&gt;build()&lt;/code&gt;, который создаст группу. Repeated поля мы можем заполнять как по одному, так и
добавлять целую коллецию.&lt;/p&gt;

&lt;p&gt;Как вы уже поняли, создавать студентов мы можем аналогично:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Student student = AcademyProtos.Student.newBuilder()
    .setId(123456)
    .addEmail(&amp;quot;student@example.com&amp;quot;)
    .addEmail(&amp;quot;student2@example.com&amp;quot;)
    .setGender(AcademyProtos.Student.Gender.FEMALE)
    .setName(&amp;quot;Ivanova&amp;quot;)
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Итак, данные мы создали, получили заполненный объект типа Group, теперь необходимо перегнать его в массив байт.
Сделать это можно следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] serializedGroup = group.toByteArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот так просто! Сериализованная группа теперь - набор байт в protocol buffers формате.&lt;/p&gt;

&lt;p&gt;Затем нам необходимо прочитать сохраненные данные. Воспользуемся статическим методом &lt;code&gt;parseFrom&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AcademyProtos.Group unserialinedGroup = AcademyProtos.Group.parseFrom(serializedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для того, чтобы проверить результат выведем его на экран (компилятор создает человекопонятные методы toString для классов, так
что с отладкой нет проблем).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(unserialinedGroup);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В результате, в консоли мы видим:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: &amp;quot;Math&amp;quot;
student {
  name: &amp;quot;Ivanova&amp;quot;
  id: 123456
  email: &amp;quot;student@example.com&amp;quot;
  email: &amp;quot;student2@example.com&amp;quot;
  gender: FEMALE
}
student {
  name: &amp;quot;Ivanov&amp;quot;
  id: 123457
  email: &amp;quot;student3@example.com&amp;quot;
  email: &amp;quot;student4@example.com&amp;quot;
  gender: MALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;За ширмой, для полноты примера, я добавил еще одного студента к группе.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;Protocol Buffers - отличный инструмент для кросс-платформенной сериализации данных. В некоторых случаях, он позволяет
сохранять обратную совместимость, однако, при безрассудном подходе может и нанести вред. Сегодня мы познакомились с
основами формата, разобрали .proto файл и пример Java кода, который работает с описанными структурами. Protocol Buffers -
это кирпичик, который стоит в основе других технологий для интеграции гетерогенных систем, также существуют и аналоги,
которые мы рассмотрим позже. Как всегда - это не серебряная пуля, но хороший инструмент интеграции.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ivan-osipov/Experiments-and-Researches/tree/master/Integration&#34; target=&#34;_blank&#34;&gt;Код проекта&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/javatutorial&#34; target=&#34;_blank&#34;&gt;Официальный Java Tutorial&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Telegram API. Как написать бота?</title>
      <link>https://i-osipov.ru/post/how_to_create_telegram_bot/</link>
      <pubDate>Sun, 23 Jul 2017 23:10:24 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/how_to_create_telegram_bot/</guid>
      <description>&lt;p&gt;Всем привет!&lt;/p&gt;

&lt;p&gt;Сегодня мы побеседуем о том как делаются Telegram боты.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кто ты по жизни?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Telegram боты бывают двух видов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Боты основанные на Webhoock&lt;/li&gt;
&lt;li&gt;Боты основанные на Long Polling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первый вариант бота требует от вас поднять сервер и установить &amp;ldquo;вебхуки&amp;rdquo; для асинхронного оповещения вас о новых изменениях. На вашем сервере должен быть соответствующий роутинг.&lt;/p&gt;

&lt;p&gt;Второй вариант бота - это имитация асинхронности. Ваш бот с определенным периодом будет запрашивать последние изменения с сервера телеграм на основании механизма long polling. Т.е. бот делает запрос и подвисает, а отвисает либо по таймауту, либо по получению новыйх обновлений. Об этом виде ботов сегодня и пойдет речь.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Long polling в разрезе работы с сетью&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Когда вы работаете с Telegram Api вы нагружаете сервера Telegram. Все запросы вы отправляете по одному URL, но в один момент времени может работать только один обработчик для Telegram бота.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Интересно, что в API предусмотрена умная обработка ошибок, среди прочего, в ответе телеграм сервера, который вы за DDOS&amp;rsquo;или, может сообщить вам сколько нужно подождать, чтобы вы могли взаимодействовать с Telegram снова&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Как сказано выше у вас фактически однопоточная обработка запросов к телеграм. По этому, кажется, здравым принять одну из следующих реализаций ботов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;реализовать поток, который будет отправлять запросы и складировать ответы в общую очередь из которой потоки-обработчики будут их разбирать;&lt;/li&gt;
&lt;li&gt;поставить прокси-сервер, который будет затягивать последние изменения и шарить их между нодами (другими серверами) бота. В этом случае можно подменяя прокси-сервер менять реализации взаимодействия с telegram api не меняя реализацию для нод. Это решение мне нравится несколько больше, его масштабируемость зависит от потребностей в функциональности бота, т.к. если можно обрабатывать параллельно несколько чатов независимо друг от друга, то масштабируемость на пределе.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Оставим использование прокси-сервера для будущих статей, а пока давайте рассмотрим как вы можете реализовать своего бота.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Красная или синяя таблетка?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;На сколько вы любите писать велосипеды? В зависимости от этого у вас есть 2 пути реализации Telegram бота:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;писать всё самому с нуля;&lt;/li&gt;
&lt;li&gt;воспользоваться существующей библиотекой.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если вы используете динамически типизируемые языки, которые поддерживают нативную работу с JSON, то первый вариант, не так уж и плох, однако, уже существует большое количество библиотек для разработки ботов их публичный перечень вы можете увидеть &lt;a href=&#34;https://core.telegram.org/bots/samples&#34;&gt;здесь&lt;/a&gt;. Вы найдете много вариантов для PHP, Java, Python, Node.js и так далее. Я сейчас реализую собственную библиотеку на языке Kotlin - &lt;a href=&#34;https://clabo.i-osipov.ru/&#34;&gt;Clabo&lt;/a&gt;. Эта библиотека поможет вам на основании расширяемого DSL описать работу своего бота, например, всё что надо для запуска бота, который говорит &amp;ldquo;Привет!&amp;rdquo; по команде /start это небольшой кусочек кода по &lt;a href=&#34;https://gist.github.com/ivan-osipov/266204f3560a6c5e64d381df5c73bf22&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BotFather&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В телеграме есть специальный бот, который позволяет создавать других ботов и настраивать их. Некоторые действия вы, как пользователь, не можете сделать из интерфейса, например, сменить имя бота или задать набор команд, для этого нужен &lt;a href=&#34;http://t.me/botfather&#34;&gt;BotFather&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Теперь у вас есть представление, как реализовать бота, но что с ним можно сделать? Об этом я расскажу ниже.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;И зачем всё это?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Боты очень способные, они обладают следующими возможностями:&lt;/p&gt;

&lt;!--email_off--&gt;

&lt;ul&gt;
&lt;li&gt;Встраиваемый мод (Inline mode). Вы можете встроить бота прямо в строку с вводом, хорошие примеры таких ботов это GifBot и YouTubeBot. Вы вписываете имя бота, например, @youtube и он предлагает вам результаты поиска видео или вы можете авторизоваться и результаты будут специфичны для вас.&lt;/li&gt;
&lt;li&gt;Клавиатуры. Есть два вида клавиатур: &amp;ldquo;Клавиатура для быстрого ответа&amp;rdquo; и &amp;ldquo;Встроенная клавиатура&amp;rdquo;. Первый вариант позволяет пользователю не писать сообщение, а просто отправить его выбрав один из вариантов. Встроенная клавиатура размещается прямо под сообщением и ассоциирована именно с ним.&lt;/li&gt;
&lt;li&gt;Команды. Всё что вы пишете после &amp;ldquo;/&amp;rdquo; в телеграм называется командами, чтобы избежать коллизий, когда два бота в одном чате имеют одну и ту же команду используется следующий формат &lt;code&gt;/command@BotName&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Бот может отправлять отформатированные с помощью html или markdown сообщения.&lt;/li&gt;
&lt;li&gt;Бот может запросить местоположение или номер телефона.&lt;/li&gt;
&lt;li&gt;Ботов можно добавлять в группы и, например, администрировать их.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--/email_off--&gt;

&lt;p&gt;&lt;strong&gt;Что в итоге?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Мы обзорно рассмотрели основы того как можно сделать ботов, для чего это и что они могут делать. Применение ботов ограничивается только вашей фантазией.
Вы создаете бота и запускаете сопровождающий код, который обрабатывает сообщения. Ничего сложного. Увидимся в следующих статьях!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Берешь дешевле? Заплатишь позже</title>
      <link>https://i-osipov.ru/post/hosting-thoughts/</link>
      <pubDate>Sat, 06 May 2017 02:37:00 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/hosting-thoughts/</guid>
      <description>&lt;p&gt;Занимательное дело, решил сходить на рынок, купить пару доменов. Зашёл на reg.ru, вышел и забыл на пол года. Спустя время вернулся с кучей идей и большим желанием прикупить себе парочку, но один хороший человек подсказал мне, что бывает и дешевле. Вспомнил я всё чему меня учили и вышел с этим вопросом в Интернет. Оказалось что можно купить тоже самое и в два раза дешевле. Ну тут моё детское сердце не выдержало, я и купил. Итого: 2 домена по 99 рублей, всего 198 р. Звучит не дорого.&lt;/p&gt;

&lt;p&gt;Передо мной стояла задача: взять простую html страничку и залить её на просторы интернета. Я - человек не избалованный знаниями в области создания сайтов понимаю, что мне нужно всего лишь отдавать статический контент сайта, однако, на далёкой, возможно не сбытной, перспективе за этой статикой будет какой-никакой бекэнд, естественно, на Java.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/hostimg-thoughts/heroku.png&#34; alt=&#34;Heroku&#34; title=&#34;Heroku&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Я спросил у гугла и получил ответ. Heroku - облачная PaaS-платформа. Это значит, что тебе не нужно настраивать сервер и всё всё вокруг него и это замечательно! Я скачал и установил их приложение и через консоль отправил свой прекрасный html файлик на сервера Heroku, ну, а кроме него, еще всё остальное Spring Boot приложение, которое сейчас формальная обертка над статикой, ну пригодится же, точно говорю. Конечно для создание Spring Boot приложения я воспользовался их стандартным генератором, довольно удобно. Сгенерировал -&amp;gt; Распаковал -&amp;gt; Вставил статику -&amp;gt; Готово. У хероку есть несколько способов отправить код на сервер, один из которых - использовать Git репозиторий внутри хероку. Отличный способ, кроме одного момента: аутентификация.&lt;/p&gt;

&lt;p&gt;Как вы, вероятно, знаете у гита есть два способа подтвердить себя: https, ssl. Я обычно предпочитаю простые пути, следовательно, https мне в помощь, однако всё не так просто. При выполнении git push система запрашивает ваши креденшиналы. Уж не знаю, что я делал не так, даже авторизовывался через консоль как сказано на сайте этих ребят - ничего не помогало. Всплывает окно авторизации к которому не подходят стандартные. Как типичный разработчик, прежде чем читать документацию, я решил погуглить и погуглил. А нагуглил я себе документацию, оказалось, что поле логина нужно оставить пустым, а в пароль вставить очень хитрый ключ из личного кабинета Хероку. Видимо я вновь, что-то не так понял, т.к. этот метод мне тоже не помог, смерившись со сложностью такого простого способа я решил запушить наХероку публичный ключик и это решило проблему авторизации быстрее чем за 5 минут.&lt;/p&gt;

&lt;p&gt;Сижу довольный, смотрю в документацию и изучаю как же подтянуть кастомный домен. Оказалось, что хероку дает тебе специальный DNS target, который ты вписываешь как CNAME, когда редактируешь зону DNS у своего поставщика домена. Как бы не так, не дает мой регистратор задать CNAME на корневой домен (@.example.com) и приводит мне цитаты, видимо из любимых книжек:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Нельзя указывать записи CNAME и другие с тем же именем.
Смотрите RFC1912, раздел 2.4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Бабах! www.exampe.com можно, *.example.com можно, а @.example.com нельзя! И что делать? Оказывается, что www.exampe.com работает, а exampe.com нет, но вот что забавно, если хоть раз посетить www.exampe.com, то неработающий exampe.com начинает переадресовывать тебя на старый, добрый www.exampe.com. Единственное решение, которое пришло на данный момент - это задать переадресацию у регистратора. Здорово, конечно, но это еще 120 р. за то, что кто-то где-то написал в спецификации. Деньги здесь, конечно, роли не играют, но сам факт такого решения меня возмущает.&lt;/p&gt;

&lt;p&gt;И тут я подумал посмотреть на другие хостинги, там оказалось всё еще хуже. На Amazon - $ 7 за перенос домена, на Azure - месяц бесплатно, не плохо, но нужно глубже разобраться, на Google Cloud Engine всё отлично, но инфраструктура и навязаная работа с key value store - мне не нравится (по крайней мере год назад было так), да и всё это IaaS, а мне бы файлик залить&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/hostimg-thoughts/heroku-split.png&#34; alt=&#34;Heroku&#34; title=&#34;Heroku&#34; /&gt;&lt;/p&gt;

&lt;p&gt;В итоге, самая простая привязка кастомного домена оказалась у Github Pages. Они дают IP, DNS сервер их легко принимает и всё работает уже через несколько минут. Для хостинга своего одностраничного проекта так и оставил Heroku, а для своего блога на Github Pages сделал привязку домена i-osipov.ru. А это я даже не глубоко копнул в этот мир деплоя веб сайтов и приложений&amp;hellip; На пути Докер. Надо узнать что это такое и как его запускать на Windows 8, слышал что-то про виртуалки, но это уже совсем другая история&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>