<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patterns on Ivan Osipov</title>
    <link>https://i-osipov.ru/categories/patterns/index.xml</link>
    <description>Recent content in Patterns on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/categories/patterns/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Microservice Patterns: Backends for Frontends</title>
      <link>https://i-osipov.ru/post/backends-for-frontends/</link>
      <pubDate>Wed, 17 Oct 2018 22:27:17 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/backends-for-frontends/</guid>
      <description>

&lt;p&gt;Микросервисный пузырь как будто уже лопнул и все, кто поспешно применял этот взгляд на архитектуру бекенда либо канули в лету, либо многократно пожалели о своем выборе этого тернистого пути. Пожалуй, это связано в первую очередь с бездумным разбиением кода на кучу маленьких тесно-связанных приложений, создания наносервисов и т.п. Всё это происходит из-за недостаточного количества хороших практик? Конечно нет, скорее из-за отсутствия информированности о простейших шаблонах проектирования таких систем. Об одном из таких шаблонов &amp;ldquo;бекенды для фронтендов&amp;rdquo; здесь и пойдет речь. Для начала давай разберемся а в чем проблема&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;проблема&#34;&gt;Проблема&lt;/h1&gt;

&lt;p&gt;Мы делаем софт у которого есть конечные пользователи. В случае разработки бекенда это может быть разношерстный пул клиентов. Это проблема. Клиенты должны с тобой взаимодействовать и для этого ты предоставляешь им API. Здесь довольно очевидные вещи и я не хотел бы останавливаться на них, разбирая термин API и говоря банальные вещи о том, что API должен быть документирован и удобен, не должен ломать совместимость от версии к версии (а лучше, должен версионироваться) и так далее, всё это ясно. А какие бывают клиенты? Вот тебе бытовая классификация потенциальных потребителей твоего апи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;классический веб фронтенд, написанный типично на js и работающий в браузере пользователя;&lt;/li&gt;
&lt;li&gt;мобильные клиенты, обычные приложения, которые стоят на смартфонах пользователей;&lt;/li&gt;
&lt;li&gt;GraphQL сервер между тобой и фронтендом;&lt;/li&gt;
&lt;li&gt;интеграции с различными сервисами, когда ты определяешь api, которое будут дергать какие-то внутренние системы, которые разрабатываешь не ты;&lt;/li&gt;
&lt;li&gt;внешние системы, например, какой-то другой бекенд, который написал кто-то для создания собственного сервиса, который использует тебя для части задач.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже если я кого-то забыл - это не страшно, идея понятна, клиенты гетерогенные. При чем, для одних было бы здорово получать информацию по кусочкам, каждый раз дозапрашивая часть, для других нужно минимизировать количество запросов, т.к. это сажает батарейку, а для третих нужен определенная структура данных, потому что логика обработки запросов на той стороне обязана быть минималистичной. Всё это приводит нас к проблеме того, что нашему сервису нужно обеспечивать логику, которая подойдет одновременно всем клиентам.&lt;/p&gt;

&lt;p&gt;Какие есть варианты развития апи? Остановимся на нескольких клиентах, допустим у нас ожидается мобильное приложение, веб фронтенд, парочка внутренних интеграций.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-1&#34;&gt;Попытка решения 1&lt;/h1&gt;

&lt;p&gt;Давайте ничего не будем делать. Как гласят источники - иногда, это лучшее решение. Поставим HTTP API, оформим для единообразия его в стиле REST (об этом была прошлая [статья]()) и вуаля, всем подходит. Так ли это? На практике окажется, что в этом API сликом много данных для мобильных клиентов и вообще им приходится делать дюжину запросов, чтобы собрать полную картину в этом вашем REST. Внутренние интеграции будут недовольны необходимостью слишком много знать про твое API, да и вообще, не понятно как и где будут появляться специфичные для интеграции запросы. Зато веб фронтенду будет в принципе всё круто.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-2&#34;&gt;Попытка решения 2&lt;/h1&gt;

&lt;p&gt;Подумаем, можем ли мы упростить всё и поставить вместо HTTP API - GraphQL API, а уже за ним ничего не делать и снова оформить в REST стиле и попивать чай, наслаждаясь результатом? С первого взгляда создается ощущение, что да, однако, скорее всего окажется, что внутренние интеграции не захотят подобного рода взаимодействие и вообще им бы пару методов дернуть, только вот методы эти специфичные и нужны только им.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-3&#34;&gt;Попытка решения 3&lt;/h1&gt;

&lt;p&gt;Сделать толстый API Gateway, который реализует всю специфичную логику, дает возможность реализовать на нем все виды взаимодейсткий. В теории, такое решение, конечно, даст результат, однако ценой тесного связывания в одном месте большого количества не связанной логики, более того, этот гейтвей будет нагружаться всем чем только можно, что обязательно скажется на производительности решения.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-4&#34;&gt;Попытка решения 4&lt;/h1&gt;

&lt;p&gt;Дадим клиентам доступ напрямую к базе данных! Ладно, это шутка, никогда так не делайте, это как минимум свяжет вас по рукам и ногам.&lt;/p&gt;

&lt;h1 id=&#34;решение&#34;&gt;Решение&lt;/h1&gt;

&lt;p&gt;О том, что этот шаблон в качестве решения озвученной выше проблемы используют на практике многие компании я узнал из книги Сема Ньюмана &amp;ldquo;Создание микросервисов&amp;rdquo;. [Вот здесь]() я написал на неё обзор, ты можешь почитать. Позволь я проиллюстрирую пример:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/bff/bff.png&#34; alt=&#34;bff&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Конечно, буду рад услышать ваши решения!&lt;/p&gt;

&lt;p&gt;На почитать:
Сем Ньюман &amp;ldquo;Создание микросервисов&amp;rdquo;
&lt;a href=&#34;https://samnewman.io/patterns/architectural/bff/&#34;&gt;Backends for Frontends&lt;/a&gt; samnewman.io&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>