<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Good Patterns on Ivan Osipov</title>
    <link>https://i-osipov.ru/categories/good-patterns/index.xml</link>
    <description>Recent content in Good Patterns on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/categories/good-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Backends for Frontends</title>
      <link>https://i-osipov.ru/post/bff/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/bff/</guid>
      <description>

&lt;p&gt;Микросервисный пузырь как будто уже лопнул и все, кто поспешно применял этот взгляд на архитектуру бекенда либо канули в Лету, либо многократно пожалели о своем выборе этого тернистого пути. Пожалуй, это связано в первую очередь с бездумным разбиением кода на кучу маленьких тесно-связанных приложений, создания наносервисов и т.п. Всё это происходит из-за недостаточного количества хороших практик? Конечно нет, скорее из-за отсутствия информированности о простейших шаблонах проектирования таких систем. Здесь пойдет речь о шаблоке &amp;ldquo;бекенды для фронтендов&amp;rdquo;, но для начала давай разберемся, а в чем же проблема&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;проблема&#34;&gt;Проблема&lt;/h1&gt;

&lt;p&gt;Мы делаем софт у которого есть конечные пользователи. В случае разработки бекенда это может быть разношерстный пул клиентов. Это проблема. Клиенты должны с тобой взаимодействовать и для этого ты предоставляешь им API. Здесь довольно очевидные вещи и я не хотел бы останавливаться на них, разбирая термин API и говоря банальные вещи о том, что API должен быть документирован и удобен, не должен ломать совместимость от версии к версии (а лучше, должен версионироваться) и так далее, всё это ясно. А какие бывают клиенты? Вот тебе бытовая классификация потенциальных потребителей твоего апи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;классический веб фронтенд, написанный типично на js и работающий в браузере пользователя;&lt;/li&gt;
&lt;li&gt;мобильные клиенты, обычные приложения, которые стоят на смартфонах пользователей;&lt;/li&gt;
&lt;li&gt;GraphQL сервер между тобой и фронтендом;&lt;/li&gt;
&lt;li&gt;интеграции с различными сервисами, когда ты определяешь api, которое будут дергать какие-то внутренние системы, которые разрабатываешь не ты;&lt;/li&gt;
&lt;li&gt;внешние системы, например, какой-то другой бекенд, который написал кто-то для создания собственного сервиса, который использует тебя для части задач.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже если я что-то забыл - это не страшно, идея понятна, клиенты гетерогенные. При чем, для одних было бы здорово получать информацию по кусочкам, каждый раз дозапрашивая часть, для других нужно минимизировать количество запросов, т.к. это сажает батарейку, а для третьих нужена определенная подготовленная структура данных, потому что логика обработки запросов на той стороне обязана быть минималистичной. Всё это приводит нас к проблеме того, что нашему сервису нужно обеспечивать логику, которая подойдет одновременно всем клиентам.&lt;/p&gt;

&lt;p&gt;Какие есть варианты решения? Остановимся на нескольких клиентах, допустим у нас ожидается мобильное приложение, веб фронтенд, парочка внутренних интеграций.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-1&#34;&gt;Попытка решения 1&lt;/h1&gt;

&lt;p&gt;Давайте ничего не будем делать. Как гласят источники - иногда, ничего не делать - это лучшее решение. Поставим HTTP API, оформим для единообразия его в стиле REST (об этом была прошлая &lt;a href=&#34;../../post/rest-is-not-rpc/&#34;&gt;статья&lt;/a&gt;) и вуаля, всем подходит. Так ли это? На практике окажется, что в этом API сликом много данных для мобильных клиентов и вообще им приходится делать дюжину запросов, чтобы собрать полную картину в этом вашем REST. Внутренние интеграции будут недовольны необходимостью слишком много знать про твое API, да и вообще, не понятно как и где будут появляться специфичные для интеграции запросы. Зато веб фронтенду будет в принципе всё круто.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-2&#34;&gt;Попытка решения 2&lt;/h1&gt;

&lt;p&gt;Подумаем, можем ли мы упростить всё и поставить вместо HTTP API - GraphQL API, а уже за ним ничего не делать и снова оформить в REST стиле и попивать чай, наслаждаясь результатом? С первого взгляда создается ощущение, что да, однако, скорее всего окажется, что внутренние интеграции не захотят подобного рода взаимодействие и вообще им бы пару методов дернуть, только вот методы эти специфичные и нужны только им.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-3&#34;&gt;Попытка решения 3&lt;/h1&gt;

&lt;p&gt;Сделать толстый API Gateway, который реализует всю специфичную логику, дает возможность реализовать на нем все виды взаимодейсткий. В теории, такое решение, конечно, даст результат, однако ценой тесного связывания в одном месте большого количества несвязанной логики, более того, этот гейтвей будет нагружаться всем, чем только можно, что обязательно скажется на производительности решения.&lt;/p&gt;

&lt;h1 id=&#34;попытка-решения-4&#34;&gt;Попытка решения 4&lt;/h1&gt;

&lt;p&gt;Дадим клиентам доступ напрямую к базе данных! Ладно, это шутка, никогда так не делайте, это как минимум свяжет вас по рукам и ногам.&lt;/p&gt;

&lt;h1 id=&#34;решение&#34;&gt;Решение&lt;/h1&gt;

&lt;p&gt;О том, что этот шаблон в качестве решения проблемы используют на практике многие компании (например, SoundCloud) я узнал из книги Сема Ньюмана &amp;ldquo;Создание микросервисов&amp;rdquo;. &lt;a href=&#34;../../post/building-microservices/&#34;&gt;Вот здесь&lt;/a&gt; я написал на неё обзор, ты можешь почитать. Позволь, я проиллюстрирую пример:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/posts/bff/bff.png&#34; alt=&#34;bff&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Как становится очевидно, для каждого типа клиента заводится свой BFF (Backend For Frontend), что помогает спрятать в нём все специфики связанные с потребителем API. Если возникает потребность в дублировании части логики, то следует обратить на это внимание, возможно где-то раньше был пропущен кандидат на попадание в отдельный сервис, как, например, Service AB на рисунке выше. При всём этом, сколько BFF будет в итоге - частное решение, однако, если ты видишь, что логика работы двух мобильных клиентов с одним BFF всё больше отличается, то, вероятно, это знак к разделению Mobile BFF на Android BFF и iOS BFF.&lt;/p&gt;

&lt;p&gt;Конечно, буду рад услышать то, как бы вы справлялись с этой проблемой.&lt;/p&gt;

&lt;p&gt;На почитать:&lt;br /&gt;
Сем Ньюман &amp;ldquo;Создание микросервисов&amp;rdquo;&lt;br /&gt;
&lt;a href=&#34;https://samnewman.io/patterns/architectural/bff/&#34;&gt;Backends for Frontends&lt;/a&gt; samnewman.io&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Семантическое версионирование 2.0</title>
      <link>https://i-osipov.ru/post/semanantic-versioning-2_0/</link>
      <pubDate>Tue, 23 Jan 2018 07:33:47 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/semanantic-versioning-2_0/</guid>
      <description>

&lt;p&gt;Восхитительное чувство, когда один раз взглянув на новую версию сторонней библиотеки ты понимаешь, можно ли её смело
обновлять или нужно быть готовым к изменениям в собственном коде. В сухую нумерацию пакетов вносит осмысленность Семантическое Версионирование.
У семантического версионирования есть свой сайт и основные посылы я брал оттуда (ссылка в конце статьи).&lt;/p&gt;

&lt;h1 id=&#34;основная-идея&#34;&gt;Основная Идея&lt;/h1&gt;

&lt;p&gt;Существует основной формат:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MAJOR.MINOR.PATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Формат включает в себя три неотрицательные цифры, которые увеличиваются в соответствии со следующими условиями.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MAJOR&lt;/code&gt; - увеличение версии говорит об обратно несовместимых изменениях API.&lt;br /&gt;
&lt;code&gt;MINOR&lt;/code&gt; - увеличение версии говорит о добавлении новой функциональности при сохранении обратной совместимости.&lt;br /&gt;
&lt;code&gt;PATCH&lt;/code&gt; - увеличение версии говорит об обратно совместимых фиксах.&lt;/p&gt;

&lt;h1 id=&#34;какую-проблему-решаем&#34;&gt;Какую проблему решаем?&lt;/h1&gt;

&lt;p&gt;При большом количестве зависимостей в вашем проекте может встать вопрос о потребности в использовании новых версий разных
библиотек. Если дать полную свободу в версионировании, то процесс превратится в настоящий ад, т.к. становится абсолютно не
очевидно сломает ли всё, например, переход с версии 2.3.4 на версию 2.6.8. Идея не новая, но её формализация позволяет
всем использовать и понимать версии одинаково.&lt;/p&gt;

&lt;h1 id=&#34;как-решаем&#34;&gt;Как решаем?&lt;/h1&gt;

&lt;p&gt;Основная идея была описана выше, а ниже некоторые, на мой взгляд, важные вещи из спецификации SemVer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;если какие-то изменения сделаны после релиза, то они попадут только в новый релиз;&lt;/li&gt;
&lt;li&gt;публичный API для версии 0.х.х не должен рассматриваться как стабильный, это версия для начальной разработки;&lt;/li&gt;
&lt;li&gt;версия 1.0.0 определяет публичный API;&lt;/li&gt;
&lt;li&gt;если часть API помечена &amp;ldquo;устаревшей&amp;rdquo;, то инкрементируем минорную версию, в том числе она может в себя включать фиксы;&lt;/li&gt;
&lt;li&gt;мажорная версия может включать в себя изменения характерные минорной версии и патчу;&lt;/li&gt;
&lt;li&gt;версию можно дополнять указателями на предрелизные выпуски или сборками изменяющими метаданные, но
идентификаторы версий только в ASCII.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;всегда-ли-это-подходит&#34;&gt;Всегда ли это подходит?&lt;/h1&gt;

&lt;p&gt;Нет, не всегда. Если вы разрабатываете программу/веб приложение для конечного пользователя, а не библиотеку или
Http API, то скорее всего семантическое версионирование вам не нужно. Прежде всего, посмотрите на цели и статус вашего
проекта, возможно он находится на поддержке, всё, что вы делаете, - исправляете ошибки, то есть &amp;ldquo;новая функциональность&amp;rdquo; не появляется, это значит, что первые две цифры будут
вечно неизменными, тогда какой в этом смысл? С другой стороны, если взглянуть категорично, то так и должно быть,
каждый раз закрывая пачку багов, вы обновляете PATCH версию, а при необходимости хот-фиксов просто расширяете её
дополнительными идентификаторами.&lt;/p&gt;

&lt;h1 id=&#34;для-кого-это-подходит&#34;&gt;Для кого это подходит?&lt;/h1&gt;

&lt;p&gt;Иногда, мы пишем библиотеки, иногда мы пишем модули от которых будет зависеть остальная часть системы, иногда мы
пишем микросервисы с API которых будут взаимодействовать другие команды. Всё это отличные примеры того, где семантическое
версионирование преобретает смысл. Семантическое версионирование - это язык, в трёх словах которого общаются
независимые проекты.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://semver.org&#34;&gt;Сайт Семантического Версионирования&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблон TolerantReader и Закон Постела</title>
      <link>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</link>
      <pubDate>Mon, 22 Jan 2018 08:51:45 +0400</pubDate>
      
      <guid>https://i-osipov.ru/post/postels-law-and-tolerant-reader/</guid>
      <description>&lt;p&gt;При взаимодействии множества систем постоянно встает вопрос об интеграции. Когда мы начинаем работать с чьим-то API,
существует риск, что с представители API могут его изменить и мы будем к этому не готовы. Системы эволюционируют,
развиваются и, порой, следствие этой эволюции - развитие API. По началу, изменения могут быть незначительными, почти совместимыми,
но даже к таким изменениям мы должны быть готовы. С обратной стороны, когда мы кому-то отдаем своё API, нам нужно понимать, что
наши клиенты могут быть готовы к переменам, если мы будем осторожны, консервативны к изменениям.&lt;/p&gt;

&lt;p&gt;Закон Джона Постела гласит:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;будь консервативным к тому, что делаешь, будь либеральным к тому, что получаешь от других&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Для успешного развития распределенных систем, сервис предоставляющий API, будем называть его &lt;em&gt;поставщик&lt;/em&gt;, должен
отдавать клиенту API, будем называть его &lt;em&gt;потребитель&lt;/em&gt;, такое API, которое в минимальном виде может что-то сломать.
От части этому способствуют такие форматы общения как Thrift и Protocol Buffers. Однако, всё не ограничивается одним
только способом транспортировки данных и преобразования их в конечных точках, хотя это тоже важно.&lt;/p&gt;

&lt;p&gt;Как быть либеральным к входящим данным? Можно выстроить следующий свод павил:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Используйте только те поля в данных, которые вам нужны, не используйте лишнего.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Допустим, к вам прилетел JSON объект со следующей структурой:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;Россия, Самара, Московское шоссе, д. 1, кв. 1&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для наглядности примера, представим, что вы фронтенд. Вы отображаете главную
страницу, на которой есть имя пользователя, а адрес будет нужен только в личном кабинете. Конечно, следовало бы не
отправлять все данные в принципе, но на практике, такие упущения случаются. Однажды, бекэнд меняет формат JSON на следующий:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В тот момент, когда вы получите эти изменения, для успешной интеграции, всё что вам будет нужно, это изменить обработку
адреса в личном кабинете, т.к. на главной странице вы не стали трогать поле, которое вам не нужно.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Делайте минимальные предположения о структуре данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим, еще один интересный случай. Допустим, вы извлекаете поля из json напрямую, для упрощения примера представим
что перед вами динамически типизируемый язык. Самый простой способ получить из &lt;code&gt;jsonObject&lt;/code&gt; поле &lt;code&gt;username&lt;/code&gt;, это явно
его запросить, напимер, так &lt;code&gt;jsonObject.username&lt;/code&gt;. Но это не совсем толератно, не так ли? Когда мы работаем с XML
Martin Fowler предлагает воспользоваться XPath, для получения имени пользователя, для json же существует
&lt;a href=&#34;https://github.com/json-path/JsonPath&#34;&gt;JsonPath&lt;/a&gt;. Как это использовать? Представим, что &lt;em&gt;поставщик&lt;/em&gt; изменяет структуру
JSON объекта следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;naming&amp;quot;: {
    &amp;quot;username&amp;quot;: &amp;quot;myusername&amp;quot;,
    &amp;quot;firstname&amp;quot;: &amp;quot;myfirstname&amp;quot;,
    &amp;quot;lastname&amp;quot;: &amp;quot;mylastname&amp;quot;
  },
  &amp;quot;address&amp;quot;: {
    &amp;quot;country&amp;quot;: &amp;quot;Россия&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Самара&amp;quot;,
    &amp;quot;street&amp;quot;: &amp;quot;Московское шоссе&amp;quot;,
    &amp;quot;house_number&amp;quot;: &amp;quot;1&amp;quot;,
    &amp;quot;apartment_number&amp;quot;: &amp;quot;1&amp;quot;
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если бы мы жестко завязались на структуру, то наш потребитель API пришлось бы знатно переделывать, но если мы воспользовались
JsonPath, и получали имя пользователя, выполняя поиск по выражению &lt;code&gt;$..username&lt;/code&gt;, то мы бы просто не заметили изменения
входного объекта и в перспективе сумарно проделали бы на много меньше работы. Естественно, такой подход кроет в себе
угрозу, например, если в json объекте окажется два поля с именем &lt;code&gt;username&lt;/code&gt;, то какое нужно выбирать? Однако, в простых
случаях это нас защитит. Такое чтение должно происходить для одной цели в одном месте, чтобы остальная часть системы
могла без труда оттуда получить данные, не задумываясь о том как именно они получены.&lt;/p&gt;

&lt;p&gt;Этот пост вдохновлён &lt;a href=&#34;https://martinfowler.com/bliki/TolerantReader.html&#34;&gt;вот этой&lt;/a&gt; статьёй.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>