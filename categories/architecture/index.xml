<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Ivan Osipov</title>
    <link>https://i-osipov.ru/categories/architecture/index.xml</link>
    <description>Recent content in Architecture on Ivan Osipov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <atom:link href="https://i-osipov.ru/categories/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>REST is not RPC</title>
      <link>https://i-osipov.ru/post/rest-is-not-rpc/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-osipov.ru/post/rest-is-not-rpc/</guid>
      <description>&lt;p&gt;Тебе не приелось слово REST? Нет, я не говорю об отдыхе, я говорю про тот самый архитектурный стиль.
Пожалуй, слишком часто я слышу о том, что у тех REST API, у этих REST API, а потом, оказывается что всё не так просто.
Здесь пойдет речь о том какой смысл в этой аббревиатуре и что в неё вкладывают все вокруг, мы вспомним идеи и посмотрим как их реализуют.&lt;/p&gt;

&lt;p&gt;Индустрия парализована. Парализована банально не правильным пониманием концепции и эхолалией. Одна хорошая идея в неправильной трактовке может принести много вреда. Всё было довольно просто, хотелось оформить всё единообразно, а получилось&amp;hellip; безобразно! Удивительно, как крайне компетентные, уважаемые люди и те попадают под власть красивых сокращений.&lt;/p&gt;

&lt;p&gt;Часто ли тебе говорили, &amp;ldquo;посмотри на REST API сервиса Х&amp;rdquo; или &amp;ldquo;у нас реализовано REST API&amp;rdquo;, ты приходил и видел, что на самом деле никакого REST API нет и в помине, обычный HTTP API, хаотичным образом разбросанные HTTP глаголы в купе с уродливыми URL. Со мной такое случалось последние несколько лет и если раньше я не особо обращал внимание на это, то спустя время ошибочная трактовка REST начала бросаться в глаза. Позволь объяснить, что я понимаю под &amp;ldquo;правильным&amp;rdquo; пониманием REST. С одной стороны, можно трактовать REST по Филдингу. Тогда, мы обязаны обеспечить следующие условия:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Клиент-серверная модель взаимодействия;&lt;/li&gt;
&lt;li&gt;Stateless;&lt;/li&gt;
&lt;li&gt;Кеширование;&lt;/li&gt;
&lt;li&gt;Единообразие интерфейса;&lt;/li&gt;
&lt;li&gt;Слоистая архитектура со стороны сервера;&lt;/li&gt;
&lt;li&gt;Код по требованию, расширяющий функциональность клиента.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Хм, многовато сложности, давай упростим и предположим, что когда говорят о REST API, то в идеале имеют ввиду соблюдение условия &amp;ldquo;4 Единообразие интерфейса&amp;rdquo;. Кстати, окинь взглядом этот список еще раз и подумай, как близко твоя система, которую ты в данный момент разрабатываешь. Я могу честно отметить, что ни в одной системе мне не приходилось реализовывать пункт 6, хотя возможно под него подойдет загрузка JS из CDN,  тогда всё в порядке.&lt;/p&gt;

&lt;p&gt;Можно выделить несколько важных пунктов о единообразии интерфейса, т.е. о создании REST API:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Явно выделенные ресурсы (например, пользователь). Метод HTTP API, который называется &amp;ldquo;/createUser&amp;rdquo; очевидно нельзя называть частью REST API - это отличный пример реализации RPC поверх HTTP. Думая о пользователях, как о ресурсах мы получаем uri, который заканчивается на &amp;ldquo;/users&amp;rdquo;. Обрати внимание, &amp;ldquo;users&amp;rdquo; это множественное число. Из собственной практики могу заключить, что такой вариант воспринимается лучше, это выглядит более естественным при запросе множества пользователей. К сожалению, не во всех проектах мне удается этому следовать, но помни, главное - единообразие. Если в большей части системы для получения множества ресурсов уже используется единственное число, лучше так и оставить - меньше будет ошибок у пользователей твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP глаголы это не просто глаголы. Во первых, REST это не обязательно про HTTP. Вот так, теперь живи с этим. Суть HTTP глаголов в REST - помочь тебе манипулировать ресурсами через их представления. Кроме очевидной логики в названиях HTTP глаголов POST, PUT. DELETE, GET, есть один важный момент который мы часто упускаем. Имя его - &lt;strong&gt;идемпотентность&lt;/strong&gt;. Тебя когда-нибудь спрашивали на собеседовании &amp;ldquo;почему для update используют глагол PUT&amp;rdquo;? Обычно, я в таких ситуациях отвечал &amp;ldquo;ну, логично же&amp;rdquo; и с этим никто не спорил, хотя есть и другое объяснение. Основное различие между PUT и POST это идемпотентность. Это обозначает, что PUT, как идемпотентный метод, можно запустить многократно с одинаковым результатом, а вот POST нельзя. Предположим, что у вас есть реализация &amp;ldquo;POST /users&amp;rdquo; и &amp;ldquo;PUT /users&amp;rdquo;, естественно, в теле запроса находится user. Если запустить первый метод 20 раз, то будет создано 20 пользователей (при условии отсутствия уникальных индексов), а если запустить 20 раз второй запрос, то результирующее состояние будет тем же, что и при первом вызове. Идемпотентность это важное свойство, которое следует соблюдать для избежания несогласованой трактовки работы твоего API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Гипермедиа. Пункт, который на моей практике не так часто соблюдают, возможно из-за отсутствия единого стандарта, но скорее из-за лени и нежелания это поддерживать. Сама по себе концепция проста, действия определяются на сервере, т.е. ссылки которые могут повлиять на состояние системы. Кроме простых точек входа в систему могут быть и более сложные действия, которые необходимо определять. Однако, складывается впечатление, что это несколько вырожденный пункт, который сегодня перекрывается возможностями автоматически генерируемой документации.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Content-Type &amp;amp; Accept заголовки помогают понять как же именно обрабатывать запрос, что находится в его теле и какой формат ожидается в ответ. Когда у вас один веб клиент, этот пункт кажется излишним, но на практике, это хорошее ребро жесткости для API, которое позволяет получать именно то, что ожидается в ответ.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Итак, мы разобрались, что RESTful системы делает вовсе не каждый. Достаточно завести базу в которой ты будешь хранить состояние сессии и всё, по условию Stateless ты уже не проходишь. Окей, но что нам стоит построить хотя бы RESTful API? Дисциплина помогает писать в REST стиле конечные точки: правильные url, корректное использование глаголов и даже заголовки приведены в порядок. Осталось гипермедиа&amp;hellip; Один шаг и у нас по настоящему RESTful API. Что-то внутри мне подсказывает, что это непреодолимый в общем случае шаг, что это достаточно много трудозатрат ради минимального выхлопа, при том, что закрыть проблему, которую закрывает hypermedia можно и с помощью swagger, не так гибко, но всё же.&lt;/p&gt;

&lt;p&gt;В сухом остатке, по моему субъективному опыту мало кто пишет настоящий REST API, однако, мы можем довольно просто приблизиться к нему. Но зачем обманывать себя? Почему недостаточно сказать &amp;ldquo;посмотри на сервис Х у них HTTP API&amp;rdquo; или &amp;ldquo;у нас HTTP API&amp;rdquo;? Видимо, люди надеятся спрятать за словом, которое должно характеризовать надежные, производительные и масштабируемые системы, то, что они делают. Получается, даже приведение интерфейса к единообразному виду делает далеко не каждый, зато мы спешим повесить лейбл &amp;ldquo;RESTful&amp;rdquo; на свой RPC.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Книга: Создание микросервисов</title>
      <link>https://i-osipov.ru/post/building-microservices/</link>
      <pubDate>Fri, 07 Sep 2018 23:59:28 +0300</pubDate>
      
      <guid>https://i-osipov.ru/post/building-microservices/</guid>
      <description>

&lt;p&gt;Параллельно с прослушиванием аудиокниг я не расстаюсь с классическим форматом. Не всегда удается читать бумажную версию, благо, гаджеты сегодня не отстают. На днях я закончил книгу, которую начал читать еще в январе этого года, но спустя время прервался и вот, в связи с новым местом работы и новыми задачами книга стала для меня снова актуальна - книга &lt;a href=&#34;https://www.ozon.ru/context/detail/id/135199296/&#34; target=&#34;_blank&#34;&gt;Создание микросервисов&lt;/a&gt;  от автора Сэма Ньюмана.&lt;/p&gt;

&lt;h3 id=&#34;об-авторе&#34;&gt;Об авторе&lt;/h3&gt;

&lt;p&gt;Ты не знаешь кто такой автор? Не беда! Знаешь Мартина Фаулера? Да, того мужика, который топит за Рефакторинг, Шаблоны корпоративных приложений и UML (это всё его книжки), ну и конечно за микросервисы в своем блоге. Так вот, Сэм и Мартин работают в одной конторе ThoughtWorks. На сколько я понимаю, эти ребята занимаются консалтингом в построении всяких разных систем и в использовании микросервисных архитектур. Занятная работенка. Между делом ребята пишут книги, вот сегодня и поговорим про одну из них.&lt;/p&gt;

&lt;h3 id=&#34;обзор&#34;&gt;Обзор&lt;/h3&gt;

&lt;p&gt;Сразу скажу, впечатления от книги хорошие. На многие вопросы она дает ответы, но не на все. Такс, давай по порядку.&lt;/p&gt;

&lt;p&gt;Прежде всего я для себя усвоил из книги интересную и, пожалуй, самую главную мысль. Твои и мои системы будут падать, обязательно будут падать. Вот так, без этого в нашем производстве никак. Сэм обращает внимание на одну забавную вещь. В действительности среди наших коллег можно наблюдать Архитекторов, Инженеров и другие громкие названия должностей, при том, что это всё заимствованные слова из других профессий. Архитектор софта и архитектор здания или моста это совершенно несравнимые люди. За архитекторами, которые проектируют очередной мост, стоит огромная история, тонна знаний, которые передаются из века в век, снова и снова. Какой релевантный багаж у наших архитекторов, ну, например, банковских систем? 20-40 лет? В масштабах реальной архитектуры это практически ничто. Мы пытаемся навешать ярлыков, чтобы ощутить ложное чувство защищенности, но от правды никуда не скроешься. Наши системы обязательно будут где-то падать, где-то работать не так как ожидалось и это нормально, для текущего этапа прогресса, это вполне приемлемо. Наша же задача, быть к этому готовыми. В общем, мне нравится эта мысль, особенно на фоне прочтения статей о &lt;a href=&#34;https://en.wikipedia.org/wiki/Crash-only_software&#34; target=&#34;_blank&#34;&gt;crash-only software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Второй, важный пункт, который отмечает автор - это моделирование сервисов на основе ограниченных контекстов. Я не буду углубляться в детали, но об этом можно думать как о моделировании опираясь на бизнес потебности, а не на технологии. Например, автор описывает жуткую луковую архитектуру, где разделение проходит по технологической грани, т.е., например, для работы с общей базой данных создают отдельный сервис. Как верно замечает автор, от луковой архитектуры хочется плакать.&lt;/p&gt;

&lt;p&gt;Здесь правильнее же разбивать сервисы на слабо связанные (минимально зависимые) системы с сильным зацеплением. Это значит, что сервисы должны по минимуму соприкасаться и при этом функции, которые обеспечивают взаимодействие должны покрывать потребности по максимуму. Я сформировал некоторое представление о том, как должна развиваться микросервисная архитектура начиная с нуля и заканчивая продакшен окружением, с чего она должна начинаться и куда двигаться. И, хотя, сначала я хотел описать это здесь, решил, что это большая тема для отдельной статьи.
&lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;Подписывайтесь&lt;/a&gt; чтобы не пропустить.&lt;/p&gt;

&lt;p&gt;Пара важных паттернов, которые вы встретите в книге, это Backends for Frontends и Tolerant Reader. Про последний я уже писал вот &lt;a href=&#34;https://i-osipov.ru/post/apostels-law-and-tolerant-reader&#34; target=&#34;_blank&#34;&gt;здесь&lt;/a&gt;.  Backends for Frontends это когда вы под кажный тип клиента имеете по сути свой gateway, который контролирует объем данных, необходимый этому виду клиента, например, когда нам нужно получить данные на мобильный клиент их, во-первых, должно быть по минимуму, во-вторых, для экономии батареи устройства использовать минимум запросов. Дроссель - это еще один интересный паттерн, который описывает автор, как полезный подход при миграции с legacy систем.&lt;/p&gt;

&lt;p&gt;Многие вещи довольно очевидны, как мне кажется, но когда ты видишь подтверждение собственных мыслей в виде паттернов, то на душе становится легче.&lt;/p&gt;

&lt;p&gt;Помните, что не стоит спешить плодить нано-сервисы, т.к. ни к чему хорошему это не приведет. Растите сервис, а когда внутри него сформируются собственные домены, то это хороший знак, чтобы разбить сервис на две независимых части, кстати, как это сделать в книжке тоже рассказывается.&lt;/p&gt;

&lt;p&gt;Разделы о развертывании и тестировании хорошо пересекаются с видео, которое я упоминал на своем &lt;a href=&#34;https://i-osipov.ru/telegram&#34; target=&#34;_blank&#34;&gt;телеграм канале&lt;/a&gt;&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/K1l8717tN2c&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Достаточно плотно автор обрисовал масштабирование микросервисов. Представил различные способы, в том числе и упреждающие, для мониринга и локализации проблем в микросервисной архитектуре, например, прокидывание ID запроса по всей цепочке вызовов для удобного дальнейшего поиска по логам.&lt;/p&gt;

&lt;p&gt;Из недостатков, я не увидел практически никакой информации о том какие практики используются для авторизации действий пользователей в системе. JWT токен был упомянут единожды вскользь. Как автор администрировал одновременно множество сервисов также остается загадкой, возможно никак. Хотя у меня есть представление как реализовать всё, что меня интересует, в книге этой информации нет.&lt;/p&gt;

&lt;h3 id=&#34;заключение&#34;&gt;Заключение&lt;/h3&gt;

&lt;p&gt;Я не претендую на роль лучшего обзорщика книг этого года, но хотел в первую очередь поделиться с вами впечатлениями о книге. Резюмируя вышесказанное: книга хороша, особенно, если вы не знаете как подобраться к задаче проектирования микросервисной архитектуры, в таком случае книга точно для вас. Больше всего, сама книга напоминает обзор возможных действий и вариантов реализации при проектировании микросервисных систем, к счастью, автор упоминает достаточное обилие тулов, которые упрощают жизнь. Уже сформировал себе список инструментов с которыми еще предстоит познакомится. В целом, рекомендую к прочтению, особенно, если ты на стороне бекенда.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>